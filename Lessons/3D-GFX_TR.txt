
   ************************************************************************
 ****************************************************************************
************                                                      ************
**********            Bilgisayarla 3D grafik motorlarının           **********
**********             gerçekleştirilmesi için teknikler              **********
**********               ve uygulama algoritmaları                 **********
************                                                      ************
 ****************************************************************************
   ************************************************************************

Hazırlayan: -+- Cristiano Tagliamonte -+- Aceman/BSD -+-

Son güncelleme: 29 Eylül 1996


				              !     !
		        _..-/\        |\___/|        /\-.._
		     ./||||||\\.      |||||||      .//||||||\.
	  	  ./||||||||||\\|..   |||||||   ..|//||||||||||\.
	     ./||||||||||||||\||||||||||||||||||||/|||||||||||||\.
	   ./|||||||||||||||||||||||||||||||||||||||||||||||||||||\.
	  /|||||||||||||||||||||||||||||||||||||||||||||||||||||||||\
	 '|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||`
	'||||'     `|||||/'   ``\|||||||||||||/''   `\||||||'     `|||`
	|/'          `\|/         \!|||||||!/         \|/'          `\|
	V              V            \|||||/            V              V
	`              `             \|||/             '              '
				                  \./
				                   V


İÇİNDEKİLER
==========================================================================

° Giriş
° Vektörler
° Perspektif
° Döndürme
° Döndürme optimizasyonu
° Tel kafes
° Gizli yüz
° Dolgulu vektör ve tarama çizgisi
° Düz gölgeleme
° Işık kaynağı hesaplaması için optimizasyonlar
° Gouraud gölgeleme
° Phong gölgeleme
° Yansıma eşlemesi
° Doku eşlemesi
° Serbest yönlü doku eşlemesi
° Bilineer doku eşlemesi
° Biquadratik doku eşlemesi
° Kabartma eşlemesi
° 2D kırpma
° Dolgu optimizasyonu
° Ek A: Sabit virgül notasyonu
° Ek B: Kutup koordinatları
° Ek C: Nesne yönetimi
° Son notlar


GİRİŞ
==========================================================

Bu kısa metin, zorlu
ve büyüleyici 3D grafik motoru programlama yolculuğuna çıkmak isteyenlere yardımcı olmak amacıyla hazırlanmıştır.
Öncelikle temel kavramları keşfederek, daha sonra daha
karmaşık ve muhteşem efektleri gerçekleştirmeyi öğreneceksiniz. “Motor” terimi
belirli verilerin yönetimi ve işlenmesine yönelik bir dizi rutin işlemdir
ve bu veriler uygun şekilde işlendikten sonra
gerçek zamanlı olarak 3D ortamın görüntülenmesini sağlar.
Aşağıdaki metin, 3D uygulamalarına yönelik bir programlama kursu değildir
 , birçok 3D motorun temelini oluşturan kavramları daha
basit bir şekilde sunan bir çalışmadır.
Tam bir anlayış için
trigonometri, lineer cebir ve bir programlama dili
(tercihen gelişmiş olmayan) hakkında temel bilgilere sahip olmanız önerilir.


VEKTÖRLER
==========================================================

Bir vektör, yönü ve
bir yönü olan bir değer miktarından başka bir şey değildir, ya da basitçe bir çizgi. Bu bağlamda, her zaman
(0,0,0) koordinat noktası (eksenlerin başlangıç
noktası) ile başka bir nokta (x,y,z) arasında uzanan vektörler belirtilecektir. Böylece,
bu vektörün miktarının (x,y,z) olduğunu söyleyebiliriz.
_
| /| Bir vektör bir harfle gösterilir,
| / örneğin yanındaki şekilde
(0,0,0)|/ x vektör V(x,y,z) temsil edilmektedir. Referans sistemi
----+------------> kullanılır ve üç değişkenle verilir,
/|\ z eksenine dik
z / | \ basit bir kartezyen düzlem olarak düşünülebilir. Basitlik için
/ | \ y ekseninin aşağıya doğru (yukarıya doğru değil) uzadığını
| \ varsayalım, böylece yapılacak hesaplamalar azalır
| \. V ekran üzerinde bir noktanın görüntülenmesi için.
y| z ekseni, gözlemciden (hareketsiz olan) uzaklaştıkça
v artar,
gözlemciye yaklaştıkça ise azalır.
Vektörleri uzaydaki her noktayı tanımlamak için kullanacağız, bu
, pratik olarak bir vektörün ekranda görüntülenen bir çizgi
olduğu anlamına gelmez, aksine eksenlerin başlangıç noktası ile uzayda bir nokta arasında kalan hayali parçayı
belirtir.


PERSPEKTİF
==========================================================

Bir 3D motorunun oluşturulmasında ortaya çıkan ilk sorunlardan biri,
 uzayda bir noktayı ekranda nasıl görüntüleyeceğimizdir.
Her nokta üç koordinat içerirken, monitörde
sadece iki koordinat mevcuttur: z ekseni eksiktir! Bunu çözmek için
tek yapmamız gereken, noktaların ekranla
örtüşen düzlemdeki izdüşümünü hesaplamaktır, ki bu aslında hiç de karmaşık değildir.
Monitörümüzün şeffaf olduğunu, yani içindekileri görebildiğimizi
varsayalım ve içinde zıplayan bir
küp olduğunu varsayalım. Ekranımızda göreceğimiz görüntü şöyledir:
________________________________
| |
| |
| ____ |
| / /\ |
ekran --> | /___/ \ |
| \ \ / |
| \___\/ |
| |
| |
|________________________________|

Bakışımızın z ekseniyle çakıştığını ve
monitörün merkezinin üç eksenin başlangıç noktasıyla çakıştığını varsayalım:

+ monitör +----------+ monitör
z ekseni | _ | |
<---------|- - - - - ¢_> | . |
| göz | (0,0,0) |
+ +----------+

Şimdi, yan taraftan baktığımızda durum şu şekildedir:

(küp)
___________________ A
| |-_ + (ekran)
| | -_ |
a | | -_ |
s | | -_|A'
s | | +_
e | | | -_
| | | -_
Y | | | -_
| | | -_ _
|___________________|B_______|B'_______- ¢_> (göz)
(0,0,0)
<---- Z ekseni ---->

göz = bizim bakış açımız (buna O diyelim, başlangıç noktası değildir!)
A,B = xyz uzayındaki noktalar
A',B' = monitöre yansıtılan noktalar (B' başlangıç noktasıyla çakışır)
AB = üç boyutlu A'nın y koordinatına eşit segment
A'B' = A'nın y koordinatına eşit segment (çünkü B'=0)
^^^^^^^^^^^^^^^^^^ monitöre yansıtılan y!
BO = gözlemci-nokta mesafesi
B'O = gözlemci-ekran mesafesi (buna d diyelim)

Monitördeki koordinatlar, yansıtılan noktaların koordinatlarını tam olarak temsil eder,
 bu nedenle bunları hesaplamamız gerekir. Dik üçgenler
AOB ve A'OB' nin ortak bir açıya sahip oldukları ve her ikisinin de bir dik açısı olduğu için benzer oldukları görülebilir,
 bu nedenle aşağıdaki orantıyı yazabiliriz
:
A'B'/AB=B'O/BO bu da şuna eşittir...
A'B'=AB*B'O/BO

B' xyz eksenlerinin başlangıç noktasına karşılık geldiğinden, BB' A noktasının
z koordinatıdır, dolayısıyla BO=BB'+B'O=z+d. Gözlemci-ekran konumunu rastgele belirlemek mümkündür
(256
değerini kullanmak tavsiye edilir, böylece 8 bit sola kaydırma yaparak çarpma işlemlerinden kaçınılabilir
).
A'B' olarak tanımlanan yansıtılan y koordinatı (yp) şu şekilde eşittir:

yp=d*y/(z+d) çünkü A'B'=yp AB=y B'O=d BO=z+d

Böylece ekran üzerindeki noktamızın y koordinatını hesapladık!
X ekseni için de durum aynıdır:
küpün hafifçe sağa kaymış olduğu yukarıdan bakıldığında durumu düşünmek yeterlidir:

(küp)
___________________ A
| |-_ |(ekran)
| | -_ |
a | | -_ |
s | | -_|A'
s | | +_
e | | | -_
| | | -_
X | | | -_
| | | -_ _
|___________________|B_______|B'_______- ¢_> (göz)
(0,0,0)
<---- Z ekseni ---->
xp=d*x/(z+d)

Yukarıdan ve yandan görünüm arasındaki farkları açıklığa kavuşturmak için aynı modelin iki
resmi aşağıda verilmiştir. İlk resim,
Enterprise (StarTrek filmindeki uzay gemisi) yan görünüşüdür,
ikincisi ise yukarıdan görünüşüdür.


\==================================| _=_
\_________________________________/ ___/==+++==\___
“”“\__ \”‘’ |======================================/
\__ \_ / .. . _/--===+_____+===--“”
\__ \ _/. .. _/ `+'
USS ENTERPRISE \__ \ __/_______/ \ /
NCC-1701 ___-\_\-‘---==+____| ---==O=-
__--+“ . . . ”==_ / \
/ |. . .. -------- | \
“==+_ . . -------- | / yandan görünüm
”“\___ . .. __==”
“”‘’--=--“”

_____
_.-’ `-._
.-‘ ` || || ’ `-.
_______________ _ ,‘ \\ // `.
/ || \ /’ \ _,-----._ / \
|_______________||_/ / \\ ,' \ | | / `. // \
| | _] \ / \ ,---. / \ // \
| \__,--------/\ ` | \ / \ / |/ - |
) ,-‘ _,-’ |- |\-._ | .---, | -| == |
|| /_____,---‘ || |_|= || `-’,--. \| -| - ==|
|:(==========o=====_|- || ( O )|| -| - --|
|| \~~~~~`---._|| | |= || _,-.`--' /| -| - ==|
) `-.__ `-. |- |/-‘ | `---’ | -| == |
| / `--------\/ , | / \ / \ |\ - |
__|____|_______ _ ] / \ / `---‘ \ / \\ /
| || \ \ // `._/ | | \_.’ \\ /
\_______________||_/ \ / `-----' \ /
`. // \\ ,‘ yukarıdan bakıldığında
`-._ || || _,-’
`-._____,-'


Videoda koordinatların kökeninin
sol üst köşe olduğu, 3D->2D dönüşümünde ise
monitörün ortası olduğu dikkate alınmalıdır. Bu sorunu gidermek için
, projeksiyon hesaplamalarının sonunda xp ve yp'ye bir sabit eklemek
yeterlidir. Bu sayede ilgili eksenler, sabite eşit sayıda
piksel kaydırılacaktır. Özetle, d=256 olarak kabul edildiğinde,
ekrana yansıtılan koordinatlar (A(x,y,z) ‘den A’(xp,yp) 'ye) eşittir:

cx = ekran genişliği/2, x eksenini sağa kaydırmak için
cy = ekran yüksekliği/2, y eksenini aşağı kaydırmak için

xp=256*x/(z+256)+cx
yp=256*y/(z+256)+cy

Noktanın z koordinatı, bakış noktasıyla çakışmamasına dikkat edin
çünkü bu durumda sıfır bölme işlemi gerçekleşir.
Bir noktanın derinliği de bakış noktasının derinliğinden daha az olamaz
: gözlemcinin arkasında bulunan noktaları görebilmek saçma olurdu
!


DÖNME
==========================================================================

Sadece x, y ve z eksenleri etrafındaki dönmeleri ele alacağız. 
Bir eksen etrafında yapılan diğer dönme formülleri
aşağıda göreceğimiz formüllerden türetilebilir.
Öncelikle, bir eksen etrafında dönmenin anlamını açıklayalım.
Bir analog saati ele alalım, saatin ibreleri saatin merkezinden geçen ve saate dik olan eksen etrafında dönüyor:
\ \ ______________ X____________ / //\ 12 // saat // \ / // //9 \/___ 3// // // // // // 6 // //___________/X /_____________/ \ hayali eksen

\
\ ______________
X____________ /
//\ 12 // saat
// \ / //
//9 \/___ 3//
// //
// //
// 6 //
//___________/X
/_____________/ \ hayali eksen
\ ibrelerin döndüğü

Teknik olarak, bir noktanın bir eksen üzerinde dönmesinden bahsederiz,
nokta, noktaya ait ve eksene dik olan düzlem üzerinde
nokta-eksen mesafesini değiştirmeyecek şekilde (sabit kalacak şekilde) hareket ettiğinde.
Bu şekilde nokta, eksen etrafında dairesel bir hareket yapar
yani eksen etrafında döner ve nokta-eksen mesafesi, söz konusu noktanın dönüşünün çizdiği daire için yarıçap görevi görür
olarak işlev görür.
Y ekseni etrafında dönme, y ekseni etrafında kendi
ordinatını değiştirmeden, yani değişmeden kalan bir noktanın izlediği yörünge
olarak düşünülebilir.

Şimdi dönmeyi gerçekten nasıl yapacağımızı görelim. 
Referans sistemi olarak 2 boyutlu bir düzlem kullanarak,
bir noktanın kartezyen koordinatlarını (x,y) kutup koordinatlarına (r,t) dönüştürebiliriz:

_ V V(x,y)=V'(r,t) _ V' r=mesafe
y| /| | /| başlangıç noktası
| / r=sqrt(x*x+y*y) | r/
| / t=arctan(y/x) | / t=açılı
|/ |/) t vektörü
+-------> x=r*cos(t) +-------> ve pozitif x ekseni
x y=r*sin(t) arasındaki açı

Ardından, noktayı
noktanın döndürülmesi istenen açı t değişkenine eklenmeli ve
ortaya çıkan kutup koordinatları kartezyen koordinatlara dönüştürülmelidir. Bu yöntem, kareler,
arkotanjanslar ve karekökler içerdiğinden gerçek zamanlı uygulamalar için çok yavaştır; ayrıca z değişkeni eklenirse
kutup koordinatlarının yönetimi çok karmaşık hale gelir
(üçlü integrallerin kullanımı vb.):
daha basit ve hızlı bir çözüm bulmak daha iyidir. daha basit ve hızlı bir çözüm bulmak daha iyidir.
Yatay ekseninde sıfır olan bir vektör V(x,0) olduğunu ve
bunu a açısı kadar döndürmek istediğimizi varsayalım:

y vektör y _ Vr(xr,yr) vektör
| çakışan | /| döndürülmüş
| x ekseni | / a
| | / radyan
| V(x,0) |/) a
+----->-> +------->
x x

V koordinatlarını kutupsallara dönüştürmek istersek, r=x
(x=sqr(x*x+0*0)) ve t=0 (0=arctan(0/x) olur. Vektörü döndürmek için
t'yedönüş açısını eklemek yeterlidir. Dolayısıyla:

(V = kartesyen koordinatlarda genel vektör)
(V' = kutupsal koordinatlarda genel vektör)
(Vr = kartesyen koordinatlarda a radyan döndürülmüş vektör)
(Vr' = kutupsal koordinatlarda a radyan döndürülmüş vektör)
(Vxr = kartesyen koordinatlarda sadece x bileşeni ile döndürülmüş vektör)
(Vyr = kartesyen koordinatlarda sadece y bileşeni ile döndürülmüş vektör)

V(x,y) = V'(r,t)
Vr(xr,yr) = Vr'(r,t+a) -> xr=r*cos(t+a) yr=r*sin(t+a)
xr ve yr'yi ilgili formüllerle değiştirelim:
Vr(r*cos(t+a),r*sin(t+a)) -> r=x t=0
r'yi x ile ve t'yi 0 ile değiştirelim:
Vxr(x*cos(a),x*sin(a))

Ve bu, y bileşeni olmayan bir vektörün dönüşü için formüldür
.
 Şimdi, x bileşeni sıfır olan bir vektörü ele alalım V(0,y):

r=y (=sqr(0*0+y*y)) 
t=pi/2 (=arctan(y/0)=arctan(sonsuz))
Vyr(y*cos(pi/2+a),y*sin(pi/2+a))

Birkaç trigonometrik formül bize şunu söyler:

cos(pi/2+a)=-sin(a)
sin(pi/2+a)=cos(pi/2)

ancak y ekseni “ters” bir referans sistemi kullandığımız için
formülleri kullanabilmek için her ikisinde de bir işareti değiştirmeliyiz,
böylece formüller şu hale gelir:

cos(pi/2+a)=sin(a)
sin(pi/2+a)=-cos(a)

Şimdi, x bileşeni olmayan bir vektörü döndürmek için formül şöyledir:

Vyr(y*sin(a),-y*cos(a))

Ancak genel duruma bakarsak, hem x hem de y bileşenlerine sahip bir vektör V vardır.
 Aslında, x ve y bileşenlerine sahip genel bir vektör
şöyledir:

V1(x,0)+V2(0,y)=V(x+0,0+y)=V(x,y)

Şimdi, tek tek durumlar için döndürme formüllerini kullanarak
vektörlerin toplamı olan genel durumu hesaplayabiliriz:

Vxr(x*cos(a) ,x*sin(a) ) +
Vyr( +y*sin(a), -y*cos(a)) =
------------------------------------------
Vr (x*cos(a)+y*sin(a),x*sin(a)-y*cos(a))

Bu formül sayesinde, herhangi bir vektörü iki boyutlu bir uzayda döndürebiliriz.
 3D ortamda, az önce açıklanan formül
z ekseni etrafında dönme ile aynıdır (z koordinatı değişmez).
 Noktayı başka bir eksen etrafında döndürmek için, ilgili değişkeni dışarıda bırakıp
ilgili değişkeni dışarıda bırakıp diğerlerini önceki ifadede kullanmak yeterlidir.
Bu, şu şekilde özetlenebilir:

z ekseni etrafında y ekseni etrafında x ekseni etrafında
-------------------- -------------------- --------------------
xr=x*cos(a)+y*sin(a) xr=x*cos(a)+z*sin(a) yr=y*cos(a)+z*sin(a)
yr=x*sin(a)-y*cos(a) zr=x*sin(a)-z*cos(a) zr=y*sin(a)-z*cos(a)


DÖNÜŞLERİN OPTİMİZASYONU
==========================================================================

Her eksen (x, y ve z) için bir dönüş açısı verildiğinde, önceki
formüllerle tek bir noktayı döndürmek için 12 çarpma işlemi yapılması gerekirdi.
 Burada, her nokta için 9 çarpma işlemi yaparak dönüşleri nasıl gerçekleştireceğimizi göreceğiz.
 Şunu ele alalım:

ax=x ekseni etrafındaki dönme açısı s1=sin(ax) c1=cos(ax)
ay=y ekseni etrafındaki dönme açısı s2=sin(ay) c2=cos(ay)
az=z ekseni etrafındaki dönme açısı s3=sin(az) c3=cos(az)

x, y ve z değişkenlerinin her biri iki eksen etrafındaki dönüşleri etkiler
(kendi ekseni etrafındaki dönüşte değişken değişmez),
böylece x' y' ve z' ile kısmen döndürülen değişkenleri
(yani ilk dönüşten sonra) ve x'‘ y’' ve z'' ile
tamamen döndürülen değişkenleri Bunu söyledikten sonra, daha önce gördüğümüz formüller
şunlara karşılık gelir:

x' = x*c1+y*s1
y' = x*s1-y*c1

x'‘= x’*c2+z*s2 <- tamamen döndürülmüş x koordinatı
z' = x'*s2-z*c2

y'‘= y’*c3+z'*s3 <- tamamen döndürülmüş y koordinatı
z'‘= y’*s3-z'*c3 <- tamamen döndürülmüş z koordinatı

Bu, aşağıdaki şekilde yazılabilir:

x'‘= (x*c1+y*s1)*c2+z*s2=c2*c1 *x + c2*s1 *y + s2 *z

y’'= (x*s1-y*c1)*c3+((x*c1+y*s1)*s2-z*c2)*s3=
c3*s1 *x - c3*c1 *y + s3*s2*c1 *x + s3*s2*s1 *y - s3*c2 *z=
(s3*s2*c1+c3*s1) *x + (s3*s2*s1-c3*c1) *y + (-s3*c2) *z

z''= (x*s1-y*c1)*s3-((x*c1+y*s1)*s2-z*c2)*c3=
s3*s1 *x - s3*c1 *y - c3*s2*c1 *x - c3*s2*s1 *y + c3*c2 *z=
(-c3*s2*c1+s3*s1) *x + (-c3*s2*s1-c3*c1) *y + (c3*c2) *z

Bu formüllerin son adımından, kısmen döndürülmüş koordinatların hesaplanmadığı ve her döndürülmüş koordinatın
(döndürülmemiş) değişkenlerin belirli bir faktörle çarpımına eşit olduğu görülebilir.
 Bu faktörleri önceden hesaplarsak, aynı yönde döndürülmesi gereken tüm noktalar için bunları kullanabiliriz.
 Bu şekilde, her nokta için sadece 9 çarpma işlemi yapmış oluruz (faktörler için ön hesaplamalar hariç).
aynı yönde döndürülmesi gereken tüm noktalar için kullanabiliriz.
 Bu şekilde, her nokta için sadece 9 çarpma işlemi yapmış oluruz
(faktörler için ön hesaplamalar hariç).
Esasen, önce şu sabitleri hesaplamamız gerekir:

xx=c2*c1
xy=c2*s1
xz=s2
yx=c3*s1+s3*s2*c1
yy=-c3*c1+s3*s2*s1
yz=-s3*c2
zx=s3*s1-c3*s2*c1=s2*c1+c3*s1
zy=-s3*c1-c3*s2*s1=c3*c1-s2*s1
zz=c3*c2

daha sonra her nokta için şu hesaplamalar yapılmalıdır (aynı faktörleri kullanarak
):

x'‘=xx * x + xy * y + xz * z
y’'=yx * x + yy * y + yz * z
z''=zx * x + zy * y + zz * z

Böylece üç döndürülmüş koordinatı elde ederiz.
Bu algoritma, az sayıda nokta kullanıldığında önceki algoritmadan daha az verimli olur,
 ancak çok sayıda vektör söz konusu olduğunda
hesaplama süresinde önemli ölçüde tasarruf sağlanabilir.


wIREFRAME
==========================================================

Wireframe, poligonları yeniden üretmek için kullanılan en basit ve en eski tekniktir.
 Bu teknik, temsil edilecek poligonun
köşelerini birleştiren çizgiler çizmekten ibarettir, başka bir şey değildir. Çizgilerin çizilmesi
, noktaların yansıtılmış koordinatları (
xyz üç değişkenli koordinatlar değil) kullanılarak yapılmalıdır.
Öyleyse, bu işlevi doğrudan gerçekleştirmeyen bir dilde
(C ve Assembler gibi) programlama yaparken çizgileri nasıl çizeceğimize bakalım.
Bresenham algoritmasını inceleyelim. 
P1(x1,y1) ve P2(x2,y2) olmak üzere iki nokta var ve bunları birleştiren çizgiyi görüntülemek istiyoruz
:

P1(x1,y1)
.------______ ^
------______ P2(x2,y2) | dy
------______. v
dx
<------------------------------------>

şunu düşünelim:
x2 > x1
y2 > y1
dx = x2-x1
dy = y2-y1
dx > dy

Diğer tüm çizgi türleri bu türden türetilebilir.
Ardından şu değerleri hesaplayalım:

xl = x1 -> noktanın mevcut x koordinatı
yl = y1 -> noktanın mevcut y koordinatı
d = 2*dx-dy -> karar değişkeni
d1 = 2*dy -> d'nin artışı (eğer d<0 ise)
d2 = 2*(dy-dx) -> d'nin artışı (eğer d=>0 ise)

Sonunda gerçek algoritmayı görelim:

> dx yinelemeleri döngüsü
> (xl,yl) konumundaki pikseli görüntüle
> xl=xl+1
> eğer d<0 ise:
> d=d+d1
> aksi takdirde:
> d=d+d2
> yl=yl+1
> sonraki yineleme

Bir çizgi, bir dizi pikselden oluşur; bizim durumumuzda, çizgiyi oluşturan piksel sayısı
dx'e eşittir, bu nedenle
dx kez tekrarlanan bir döngü oluşturmalıyız ve her yinelemede
bir nokta görüntülemeliyiz. Peki bu noktanın koordinatları ne olmalıdır?
Videoya yansıtılacak noktanın koordinatlarını xl ve yl ile gösterelim.
başlangıçta P1(x1,y1) ile çakışacaktır. Her yinelemenin sonunda
xa'yı artırırız, böylece döngüden çıktığımızda
xa, x2 ile çakışacaktır (çünkü x2=x1+dx). Piksellerin
ordinatında ne olur? Değişken d
pozitif olduğunda artırıyoruz.
Çizgileri çizmek için başka bir algoritma da kullanılabilir.
Bu algoritma, Bresenham algoritmasından (özellikle
Assembly ile gerçekleştirildiğinde) daha verimlidir ve doğrusal interpolasyon prensibini kullanır.
Bunu, dolgu ve tarama çizgileri ile ilgili paragrafta daha ayrıntılı olarak göreceğiz.
hIDDEN fACE ==========================================================================


hIDDEN fACE
==========================================================

Hidden face, gizli yüz anlamına gelir. Bu paragrafta, bunu nasıl
kaldıracağımızı göreceğiz. Gerçekte, şeffaf olmayan bir katı cisimde
. Monitörde sadece görünür yüzleri görüntülemek,
 hepsini çizmekten kesinlikle daha gerçekçidir.

En basit ve sezgisel algoritma “ressam” algoritmasıdır. Bu algoritma,
 nesneyi oluşturan yüzleri z bileşenine göre sıralamaktır.
Daha sonra, en uzak yüzden başlayarak en yakına doğru yüzleri çizmek gerekir
; bu şekilde, en son çizilen yüzler
görünür olurken, gizli yüzlerin üzerine görünür olanlar çizilir
. Dezavantajı olarak, bu algoritma
makine zamanında büyük bir israf içerir ve ayrıca tel kafes grafikler için
pratik olarak kullanılamaz, ancak tel kafes olmayan herhangi bir nesnenin
doğru şekilde görüntülenmesini sağlar.

Başka bir yol, her yüzün normalini (dik çizgi)
hesaplamak, izleyiciye doğru işaret edip etmediğini kontrol etmek ve
etmiyorsa görüntülememektir. Bu algoritma, yüzü sınırlayan köşeler
saat yönünde bellekte yer alıyorsa geçerlidir, çünkü
göreceğimiz hesaplamalar bu özelliği kullanır. Ayrıca nesneler
mutlaka dışbükey olmalıdır, yani diğer yüzleri
“gölgeleyebilecek” (gizleyemeyecek!) yüzler olmamalıdır.
Normal doğruyu, uzayda üç bileşeni olan ortak bir vektör olarak gösterilen bir vektör büyüklüğü olarak düşünebiliriz.
Bir poligonun görünürlüğü, yalnızca z ekseni boyunca yönelimine bağlıdır. Daha kesin olmak gerekirse, yüzün gizli olup olmadığını bilmek için yalnızca z bileşeni gereklidir.

Bir poligonun görünürlüğü, yalnızca z ekseni boyunca yönelimine bağlıdır.
Daha kesin olarak, yüzün gizli olup olmadığını anlamak için yalnızca z bileşeninin gerekli olduğunu söyleyebiliriz.
Yüzümüzü aşağıdaki gibi ele alalım:
Bir düzlemi belirlemek için üç nokta yeterlidir.
A(x1,y1) Sonuç olarak, yüzümüzle çakışan düzlemdeki normali bulmak için yüzün ilk üç köşesinin koordinatları yeterli olacaktır. D / \ B(x2,y2) Herhangi bir kanıtı bir kenara bırakarak,
 
/\ ile normalini bulmak için yüzümüzün ilk üç köşesinin koordinatları yeterlidir.
/ \ D / \ B(x2,y2)
Herhangi bir kanıtı bir kenara bırakırsak, normalin z bileşeninin
\ / eşdeğer olduğunu söyleyebiliriz:
\ /
\/
C(x3,y3) (x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)

Sonuç sıfırdan küçük veya sıfıra eşitse yüz gizlidir,
aksi takdirde görünürdür. Bu z bileşeninin sıfırdan büyük veya küçük olup olmadığını basitçe öğrenmek için
izdüşen koordinatları da kullanabiliriz, yani:
(xp2-xp1)*(yp3-yp1)-(xp3-xp1)*(yp2-yp1)

(xp2-xp1)*(yp3-yp1)-(xp3-xp1)*(yp2-yp1)

Koncav bir nesneyi görüntülemek için en iyi yol, gizli olmayan yüzleri bir
tampona kaydetmek (normal yönünü kontrol ederek),
 ardından yüzleri z bileşenlerine göre sıralamak
ve en uzak olandan en yakına doğru çizmek.


DOLMUŞ VEKTÖR ve TARAMA ÇİZGİSİ
==========================================================================

Dolgulu vektörler, belirli bir renkle “dolgulu” poligonlardan başka bir şey değildir.
Bir dolgu rutini oluşturmak, bir poligonun içeriğini, köşelerinin izdüşüm koordinatlarını bilerek renklendirmek anlamına gelir.
Dolgulanacak poligonun aşağıdaki gibi olduğunu varsayalım:
| A|\ Aşağıdaki şekilde ilerleyebiliriz:

| | \ poligonun en küçük y koordinatından başlayarak
| | \ (bu durumda A'nın koordinatı) ve sırayla
| | \ son dikey konuma (yani D'nin y koordinatı)
| | \ x konumlarıyla sınırlanan satırı
| | B'nin o y konumundaki kenarları renklendiririz.
| D \ |
| \ | Dolgu ilkesi,
| \ | üst satırdan başlayarak
| \ | poligonun en üst satırından en alttaki satıra kadar.
|y \ |
v \|C Tek bir satırla ilgili bir örnek görelim:

| A|\
| | \ Şekilde gösterilen satırı doldurmamız gerekiyor.
| | \ AD kenarının x koordinatından başlayalım.
| satır | \ Bu noktayı renklendirelim.
| da -->|****\ Bir sonraki noktaya (yani
| doldurulacak| \ B sağdaki) geçelim ve onu da renklendirelim;
| D \ | sonraki pikselleri renklendirmeye devam edelim,
| \ | AB kenarındaki noktayı renklendirdikten sonra
| \ | bir sonraki satıra geçelim.
| \ | Bu, her satır için
|y \
 | koordinatlarına ihtiyacımız var.

Ne yapacağımızı anladığımıza göre, şimdi bunu nasıl gerçekleştireceğimize bakalım.
Bellekte,
ekranda gösterilebilen dikey piksel sayısına eşit boyutlarda iki tablo (tek boyutlu matris)
kullanılmalıdır (örneğin: 
320*200 çözünürlükte iki tablo
200 değer içermelidir). Tabloların her bir konumunu ekrandaki
y konumu ve ilk dizinin içeriğini sol uç noktanın karşılık gelen x bileşeni
olarak, ikinci dizinin değerini ise sağ uç noktanın x bileşeni olarak kabul edelim.
Böylece, ilk tablonun x konumunu içeren ilk tablodan başlayarak ikinci tablonun x konumunu içeren son tablo
Böylece, tablolardaki konumlara karşılık gelen satırdaki tüm pikselleri
boyamak yeterli olacaktır.
İlk tablodaki x konumundan başlayarak ikinci tablodaki x konumuna kadar (bir satırdaki tüm noktalar aynı ordinat değerine sahiptir).
Pratik bir örnek verelim:

0| x=0 ->A. <- x=0 basitlik için AB ve CD segmentlerini ele alalım
1| x=0 -> .. <- x=1 45 derece eğimli. Köşeler şunlardır:
2| x=0 -> . . <- x=2 A(0,0) B(5,5) C(5,10) D(0,5)
3| x=0 -> . . <- x=3 iki tablomuz şöyle olacaktır:
4| x=0 -> . . <- x=4 +-------------------------------------------+
5| x=0 ->D. .B<- x=5 |TAB1| 0| 0| 0| 0| 0| 0| 1| 2| 3| 4| 5|..|..|
6| x=1 -> . . <- x=5 +-------------------------------------------+
7| x=2 -> . . <- x=5 |TAB2| 0| 1| 2| 3| 4| 5| 5| 5| 5| 5| 5|..|..|
8| x=3 -> . . <- x=5 +-------------------------------------------+
9| x=4 -> .. <- x=5 Poligonu doldurmak için
10|y x=5 -> .C<- x=5 iki tablonun karşılık gelen
v değerleri arasındaki pikselleri
y bileşeni olarak tablo indeksini (her ikisi için de aynıdır)
 Bazen,
tabloların en uçtaki iki değeri, o satırlarda tek bir piksel olduğunda (örneğimizde olduğu gibi
)
 silinebilir. Şimdi geriye, bu
iki dizinin içeriğini
Tablolar, poligonun kenarlarını oluşturan tüm noktaların x koordinatlarını içerir
; ayrıca bu x koordinatları y bileşenlerine göre sıralanmıştır.
 Pratikte, yüzün tüm kenarları için bir çizgi izleme rutini gerçekleştirmeliyiz,
 burada pikselleri görüntülemiyoruz, ancak x bileşenini o noktanın y konumuna eşit olan bir diziye kaydediyoruz.
 Bu prosedür, “tarama çizgisi” adını alır
“tarama çizgisi” olarak adlandırılır. Başka bir deyişle, tarama çizgisi,
iki nokta verildiğinde, bilinen iki noktayı birleştiren
segment boyunca yer alan tüm noktaların koordinatlarını temsil eder. Bir poligonun tüm kenarları için bir tarama çizgisi oluşturma prosedürü
“tarama dönüşümü” olarak adlandırılır ve pratikte poligonu bir
dizi satır ve sütuna bölmek anlamına gelir.
Bir tarama çizgisi oluşturmak için Bresenham algoritması kullanılabilir,
 ancak daha verimli olan doğrusal enterpolasyon
işlemini kullanmak daha uygundur. Bunun ne olduğunu kısaca görelim
.
İki genel nokta A(x1,y1) ve B(x2,y2) düşünelim, burada y2>y1.
Şimdi şunu hesaplayalım:

dx=x2-x1 <-- A ve B'yi birleştiren çizginin uzunluğu
dy=y2-y1 <-- A ve B'yi birleştiren çizginin yüksekliği
stepx=dx/dy <-- her satırdaki yatay piksel sayısı

Genel algoritma ise şöyledir:

> x=x1
> y=y1
> dy yinelemeleri döngüsü
> tab1'deki y konumu boşsa:
> x'i tab1'deki y konumuna kaydet
> aksi takdirde:
> x'i tab2'deki y konumuna kaydet
> x=x+stepx
> y=y+1
> sonraki yineleme

Bu algoritma, y2>y1 durumunda bir tarama çizgisinin hesaplanmasını sağlar,
y1>y2 ise, iki noktanın koordinatlarını değiştirmek yeterlidir
(yani y1'i y2 ve x1'i x2 olarak kabul etmek).
Tab1, soldaki uç noktaları içeren dizidir, tab2 ise
sağdaki uç noktaları içerir. Algoritmamızda, tab1'de yazan bazı
değerlerin tab2'ye ait olması ve tersi durumlar olabilir. Bu sorunu
önlemek için ne yapmamız gerektiğini görelim.

Noktaları saat yönünde kaydettiğimizde her şey daha basit
ve hızlı olur. A(x1,y1) ve B(x2,y2) saat yönünde yer alıyorsa, y1
y2'den büyükse tarama çizgisi tab1'e (
daha küçük x konumlarını içeren) ait olur, aksi takdirde tab2'ye
(daha büyük x konumlarını içeren) ait olur. İşte bir tarama çizgisini izlemek için
kullanılan tam algoritma:

> y1 ile y2'yi karşılaştır
> y1>y2 ise:
> doğru tab tab1'dir
> y1<y2 ise:
> doğru tab tab2'dir
> y1 ile y2'yi değiştir
> x1 ile x2'yi değiştir
> y1=y2 ise: tarama çizgisini izleme!
> dy=y1-y2
> dx=x1-x2
> stepx=dx/dy
> x=x2
> y=y2
> dy yinelemeleri döngüsü
> x'i doğru tab'da y konumuna kaydet
> x=x+stepx
> y=y+1
> sonraki yineleme

Poligonun tarama dönüşümü gerçekleştirildikten sonra,
poligonun köşelerini oluşturan dört noktanın en küçük y bileşenini
ve poligonun piksel cinsinden yüksekliğini hesaplamamız gerekir. En küçük y koordinatı,
 poligonu doldurmak için başlangıç noktası olan tabloları
ve dolayısıyla poligonun en üst y konumunu temsil eder. Poligonun yüksekliği
, en büyük y ile en küçük y arasındaki farka eşittir ve
mevcut poligonu doldurmak için kaç satır doldurmamız gerektiğini bilmek için kullanılır.

Özetle, bir poligonu doldurmak için aşağıdaki adımları izlemelisiniz
:

- bellekte ys değerlerine göre boyutlandırılmış iki tablo tanımlayın (burada ys
ekranın piksel yüksekliğini temsil eder);
- köşelerin en küçük y değerini ve poligonun yüksekliğini hesaplayın;
- poligonun her bir kenarının tarama çizgisini elde edin ve
uygun şekilde doğru tabloya kaydedin (tarama dönüştürme);
- küçük y konumundan başlayarak, tabloların içerdiği x konumları ile sınırlanan satırı
poligonun yüksekliğine eşit sayıda
doldurun.


fLAT sHADING
==========================================================================

İlk (ve en basit) gölgelendirme algoritmasının analizine geldik.
 Bu algoritma sayesinde, nesneyi içeren her poligona
kesin bir ışık yoğunluğu atayabiliriz Bu yoğunluk,
yüzün ışık kaynağına göre yönüne göre belirlenir.
Düz gölgeleme, her yüze tek bir renk atayarak
poligonun ne kadar aydınlatılacağını belirler. Bir örnek verelim:

+-------------+
görünüm | |
yukarıdan | | <--- teorik 3D nesne (teorik
| | çünkü gerçekte yoktur, biz
| | yansıtılan koordinatları
+-------------+ görüntülüyoruz)
|
| <--- ışık kaynağının yönü
______________|_____________ <--- monitör ekranı
|
|
veya <--- gözlemcinin bakış açısı

Işık kaynağının bakış açısıyla aynı olduğunu varsayalım,
yönü ekrana diktir. Yüzün ışık kaynağına göre eğim açısını
ışığın yönüne karşılık gelen doğru ile yüzün vektörünün
(yani normal doğru) arasındaki açı olarak tanımlayalım.
Bu açı ne kadar küçükse, çokgen o kadar gözlemciye doğru yönelir.
 Yüzün gözlemciye ne kadar yakın olduğu,
 o yüze uygulanan ışık yoğunluğunun o kadar fazla olacağını tahmin edebiliriz.
 Sonuç olarak, daha küçük bir açı, yüzün daha fazla parlaklığına karşılık gelir.
 İşte başka bir örnek:

/\
/ \ yukarıdan bakıldığında
/ \
3B nesne --> / \
hayali / \
/ \
\ /
\ / a = yüzün vektörünün
\ / ışığın yönü ile arasındaki açı
/|\ /
/-| \ /
/ a| \/
vektör / |
yüz --> / | <-- ışığın yönü (bu durumda
/ | bakış noktası ile çakışıyor)
/ |
-----------|------------- <-- monitör ekranı
veya <-- gözlemcinin bakış açısı

Poligona atfedilebilen ışık duyarlılığı, bu açının kosinüsü ile orantılıdır.
 Cos(a) genellikle -1 ile 1 arasında bir değer alır.
 Poligon görünürse, açımızın
0 ile 90 derece arasında değişir, aksi takdirde yüz gizlenir (bu özelliği gizli yüzleri ortadan kaldırmak için kullanabilirsiniz!).
Dolayısıyla, açımıza ilişkin kosinüs değeri 0 ile 1 arasında bir aralıkta değişir.
Bu nedenle, açımıza ilişkin kosinüs değeri
0 ile 1 arasındaki bir aralığı kapsar.
Ayrıca, 256 renk kullanarak, kosinüsü 256 ile çarpmak
(veya 8 bit sola kaydırmak) yeterlidir ve ilgili yüzü doldurmamız gereken
piksel chunky'yi elde ederiz!
Bu değeri nasıl elde edeceğimize bakalım.

Öncelikle, kullanılacak renk paletini belirlemeliyiz.
Bu, video belleğinde
en düşük parlaklık renginden başlayıp kademeli olarak en açık renge kadar uzanan bir palet tanımlayarak yapılabilir
.
Kosinüs hesaplaması için Lambert kuralını kullanmak uygun olur.
Bu kural, iki doğru vektör olarak ifade edilen iki doğru arasındaki skaler çarpımın
ilgili vektörlerin uzunluklarının çarpımına ve
düzgünlerin sınırladığı açının kosinüsüne,
yani a açısına eşit olduğunu belirtir. Dolayısıyla, cos(a) değerini bulmak için, bu skaler çarpımı hesaplayıp
bu skaler çarpımı yapmak ve sonucu iki vektörün uzunluklarının çarpımına bölmek
.

İki vektörün skaler çarpımını hesaplamak için, karşılık gelen bileşenlerin çarpımı yapılır
ve sonuçlar toplanır, örneğin:

H=(xh,yh,zh) ; K=(xk,yk,zk)
H*K=xh*xk+yh*yk+zh*zk <-- skaler çarpım

Bir vektörün uzunluğunu bulmak için Pisagor teoremini kullanabiliriz.
 Bu teorem sayesinde, uzunluğun her bileşenin karesinin toplamının kareköküne eşit olduğunu söyleyebiliriz
.

Yüzün vektörünün x, y ve z katsayılarını nasıl hesaplayacağımızı kontrol edelim
:

Nx=(y2-y1)*(z3-z1)-(y3-y1)*(z2-z1) <-+--- üç katsayı
Ny=(z2-z1)*(x3-x1)-(z3-z1)*(x2-x1) <-| normal doğrunun
Nz=(x2-x1)*(y3-y1)-(x3-x1)*(y2-y1) <-+

Not: Noktalar saat yönünde belleğe kaydedilmelidir!

x1, y1, z1 = poligonun ilk noktasının bileşenleri
x1, y2, z2 = poligonun ikinci noktasının bileşenleri
x3, y3, z3 = poligonun üçüncü noktasının bileşenleri

Son olarak, chunky pikseli hesaplamak için formül:

Nx*lx + Ny*ly + Nz*lz
cos(a)=-------------------------------------------------
sqrt(Nx*Nx+Ny*Ny+Nz*Nz) * sqrt(lx*lx+ly*ly+lz*lz)

pixel chunky = 256*cos(a)

a = ışık kaynağının yönü ile vektör arasındaki açı
lx = ışık kaynağının x bileşeni
ly = ışık kaynağının y bileşeni
lz = ışık kaynağının z bileşeni

lx, ly ve lz koordinatları ışık kaynağının konumunu temsil eder.
 Işık, gözlemcinin bakış açısıyla çakışırsa,
 ilgili koordinatlar şu şekilde olacaktır:

lx=0 ; ly=0 ; lz=-256

zl, gözlemci ile ekran arasındaki mesafenin tersine eşittir
(bizim durumumuzda gözlemci ile ekran arasındaki mesafe 256'dır).


IŞIK KAYNAĞININ HESAPLANMASI İÇİN OPTİMİZASYONLAR
==========================================================

Bu bölümde, 3D motorumuzu hızlandırmak için
gerçek bir ışık kaynağı uygulamasını nasıl kullanacağımızı göreceğiz.

İlk optimizasyon, tüm yüzlerin (veya gouraud gölgeleme durumunda her bir köşenin)
tüm normallerini önceden hesaplayacağımız bir tampon kullanmaktır
; ardından her karede tüm
normalleri hesaplamak yerine, önceden hesapladığımız vektörleri,
nesnenin köşelerini döndürdüğümüzle aynı açıyla
döndürerek, daha önce açıklanan prosedürü kullanarak (tercihen 9 çarpma algoritmasını kullanarak)
9 çarpma algoritmasını kullanarak).

Normal vektör ile
ışık kaynağına karşılık gelen vektörün çarpımı 256 ile çarpıldığında
piksel chunky'yi bulabileceğimizi söylemiştik. Şimdi karekökleri
ve bölmeyi nasıl ortadan kaldıracağımızı görelim. Formülü tekrar inceleyelim:

Nx*lx + Ny*ly + Nz*lz
cos(a)=-------------------------------------------------
sqrt(Nx*Nx+Ny*Ny+Nz*Nz) * sqrt(lx*lx+ly*ly+lz*lz)

Bu optimizasyonu gerçekleştirmek için normal vektörü
ve ışık kaynağına karşılık gelen vektörü birimleştirmeliyiz. Bir vektörü birimleştirmek,
 her bir bileşeni
kökünden bölmektir; bu, yeni bileşenlerin aralığının
-1 ile +1 arasında olmasını sağlar, bu yüzden birimsel denir.
Herhangi bir vektörü birimsel hale getirmeyi cebirsel olarak görelim:

Nx
uNx=---------------------------
sqrt(Nx*Nx + Ny*Ny + Nz*Nz)

Ny
uNy=---------------------------
sqrt(Nx*Nx + Ny*Ny + Nz*Nz)

Nz
uNz=---------------------------
sqrt(Nx*Nx + Ny*Ny + Nz*Nz)

Daha genel olarak, bir vektör V(x,y,z) verildiğinde, ilgili birim vektör uV(ux,uy,uz) bileşenlerini hesaplamak için:
x

ux=--------------
y-------
sqrt(x*x + y*y + z*z)

y
uy=---------------------
sqrt(x*x + y*y + z*z)

z
uz=---------------------
sqrt(x*x + y*y + z*z)

Işık kaynağını birim haline getirmek için, her bir bileşenini uzunluğu ile bölmekten de kaçınabiliriz,
 çünkü
konumunu biz belirliyoruz, dolayısıyla keyfi olarak birim koordinatlar atayabiliriz.
 Örneğin, ışığın bakış açısı ile çakıştığı duruma geri dönersek
:

ulx=0 ; uly=0 ; ulz=-1

Böylece ışık yoğunluğunu hesaplamak için formül şu şekilde basitleştirilir:

cos(a) = uNx*ulx + uNy*uly + uNz*ulz
piksel chunky = 256*cos(a)

Bir vektörü birim haline getirmek ve ardından döndürmek veya bir vektörü döndürmek ve ardından
birim haline getirmek aynı işlevi yerine getirir; bu nedenle
normalleri önceden hesapladığımızda, bunları hemen birim haline getirebiliriz,
daha sonra birim haline getirilmiş vektörleri döndürürüz. Bu şekilde
her karede 2 karekök ve bir bölme işlemi yapmaktan kaçınırız
!

Not: Işık kaynağını hareket ettirmek isterseniz, bu
optimizasyonu kullanarak ışık kaynağını
yerinde hareket ettiremezsiniz, sadece döndürebilirsiniz, çünkü ışık kaynağı ile başlangıç noktası arasındaki mesafe
sabit kalmalıdır.

Son optimizasyon, ışık kaynağını bir noktada sabit tutmaktır,
 daha kesin olarak, her zaman gözlemcinin bakış açısıyla çakışması gerektiğini söyleyebiliriz.
 Elbette, vektörler ve ışık için birim koordinatlar kullanacağız.
 Bu özel durumda chunky pikseli hesaplamak için formülü görelim
:

piksel chunky = 256*( uNx*ulx + uNy*uly + uNz*ulz) =
= 256*( uNx*0 + uNy*0 + uNz*(-1))=
= -256*uNz

Artık chunky pikselimiz sadece uNz'ye bağlıdır, bu nedenle
her bir köşe için basit uNz yerine -256*uNz'yi önceden hesaplayabilir, döndürebilir
ve bu değeri hemen chunky piksel olarak kullanabiliriz. Bu şekilde
3 çarpma ve 2 toplama işleminden kurtuluruz. 
Ayrıca, sadece uNz'ye ihtiyacımız olduğu için
, uNx ve uNy'yi döndürmekten kaçınabilir ve yüz başına
6 çarpma işlemi daha (veya gouraud durumunda köşe başına)
. Toplamda,
yüz başına (veya gouraud durumunda köşe başına) 9 çarpma ve 2 toplama işleminden tasarruf ediyoruz!
Tabii ki, -256*uNz'nin yanı sıra uNx ve uNy'yi de önceden hesaplamamız gerekecek
256 ile çarpılmış (256*uNx, 256*uNy) değerleri de önceden hesaplamamız gerekir.
Ayrıca, paletimizi ters çevirirsek, -256*uNz yerine 256*uNz kullanabiliriz
.


gOURAUD gölgeleme
==========================================================================

Bu gölgeleme algoritması, her poligonun içini gölgelendirmeye olanak tanır.
 Bu, her poligona tek bir renk atayan düz gölgelemenin aksine
renk atan flat shading'in aksine, her poligonun içini ters yönde gölgelendirebilir.

Öncelikle, her poligonun değil, nesnenin her bir köşesinin vektörünü hesaplamak gerekir.
 Köşedeki normal bileşenleri,
 o köşeye değen tüm yüzlerin normal bileşenlerinin aritmetik ortalamasına eşittir.
 Bir örnek verelim:

____ V, f1, f2 ve f3 yüzlerine ait bir küpün genel bir köşesi olsun
/f2 /\. Bu yüzlerin normallerini
/___/V \ ele alalım ve bu vektörleri N1, N2, N3 olarak adlandıralım.
\f1 \f3/
\___\/ N1(Nx1,Ny1,Nz1) N2(Nx2,Ny2,Nz2) N3(Nx3,Ny3,Nz3)


O halde V üzerindeki normal vektör şuna eşittir:

NV( (Nx1+Nx2+Nx3)/3, (Ny1+Ny2+Ny3)/3, (Nz1+Nz2+Nz3)/3 )

Bu durumda V'ye ait yüzler 3'tür, kullanmak istediğiniz nesneye bağlı olarak
bir köşeye ait çokgenlerin sayısı
değişir.

Tüm normaller (tercihen birim normaller) önceden hesaplandıktan sonra
her kenarda, her bir köşeye düşen ışık miktarını
yani chunky pikseli, daha önce incelenen düz gölgeleme
(önceki paragrafta bahsedilen optimizasyonları kullanarak
)

daha sonra, tüm görünür poligonların tarama dönüşümünü (dolgu ve tarama çizgisine adanmış paragrafta açıklanmıştır) yapıyoruz.

Şimdi, her yüz için o yüzün köşelerine ait chunky pikselleri
doğrusal olarak interpolasyon yapmalıyız. Pratikte, köşelerin x koordinatları yerine
chunky pikselleri kullanarak poligonu basit bir tarama dönüşümü yapmalıyız,
 hepsi bu kadar. Tabii ki bu, yüz görünürse
yapılmalıdır.

Geriye, poligonları gerçekten doldurmak kalıyor.
Normal bir dolguda olduğu gibi, poligonun piksel yüksekliğine eşit sayıda yineleme içeren bir döngü gerçekleştirmeliyiz.
 Her yinelemede,
tarama satırları tablosundan başlangıç ve bitiş x koordinatlarını
(normal bir dolguda olduğu gibi) alırız, ancak bu sefer başlangıç ve bitiş chunky pikselleri de alırız
.
Şimdi, başlangıç chunky pikselini son chunky pikseliyle
başlangıç x koordinatından son koordinata kadar interpolasyon yapmalıyız.
Bunu yapmak için, aşağıdaki değişikliklerle bir tarama çizgisi çizmek için algoritmayı kullanmak yeterlidir
:

- x1 koordinatı yerine başlangıç chunky pikselini kullanın;
- x2 koordinatının yerine son chunky pikseli kullanın;
- y1 koordinatının yerine ilk x'i kullanın;
- y2 koordinatının yerine son x'i kullanın;
- “doldurulacak” chunky ekran satırını tablo olarak kullanın
burada tarama çizgisi kaydedilecektir.

Ve işte gouraud gölgeleme tamamlandı!


pHONG gölgeleme
==========================================================================

Phong gölgeleme, her piksele gerçek
ışık yoğunluğunu atamaya olanak tanır, gouraud'da ise her yüzün içinde, her
nesnenin köşesinin ışık yoğunluğu arasında
tonlar oluşur.
Phong ile gouraud'a göre elde edilen daha yüksek çözünürlük
,
 aynı zamanda işlemcinin gerçekleştirmesi gereken işlemlerin sayısında da önemli bir artışa neden olur.
 Gerçekleştirilmesi gereken hesaplamaların ağırlığı,
mevcut işlemcilerin gerçek zamanlı olarak phong gölgeleme ile tatmin edici sahneler çizmesini
engellemektedir.

Gouraud'da her köşede gerçek ışık yoğunluğunu hesaplıyoruz,
daha sonra her renk poligonun her bir kenarı boyunca enterpolasyonlanır
ve son olarak sol uç kenarlardaki renkler sağ uç kenarlardaki renklerle enterpolasyonlanarak
tüm poligon doldurulur
.
Phong'da ise her zaman normalleri enterpolasyonlarız, renkleri asla enterpolasyonlamayız.
 Her köşede vektörler belirlendikten sonra, bunlar
her kenar boyunca enterpolasyon yapılmalıdır; daha sonra sol uç kenarlarda bulunan vektörler
sağ uç kenarlarda bulunan vektörlerle enterpolasyon yapılır,
 ardından her bir vektör için geleneksel formül kullanılarak renk hesaplanır
.

Phong, Gouraud gölgeleme ve düz gölgeleme ile mümkün olan çeşitli optimizasyonlardan yararlanmamızı engeller
. Aslında phong'da
birim normalleri kullanmak imkansızdır, çünkü bunlar
interpolasyon yapıldığında uzunlukları (sqrt(Nx*Nx+Ny*Ny+Nz*Nz) ifadesinin sonucuna eşdeğer) değişebilir. Bu nedenle, piksel başına en az
bir bölme ve bir karekök işlemi yapmak gerekir, bu da az bir işlem değildir.
rEFLECTION mAPPING


YANSIMA HARİTALAMA
==========================================================================

Bir katı her zaman ve yalnızca tek bir görüntüyü yansıtıyorsa (jargon
dilinde “doku” olarak adlandırılır), o katı üzerinde
yansıma haritalama uygulandığını söyleyebiliriz.
Doku, bir ışığın iki boyutlu temsiline (örneğin, merkezi çok açık olan ve kenarlarında daha koyu bir tona dönüşen bir daire) yaklaşık olarak karşılık geliyorsa, phong ile benzer (ve bazen daha üstün) efektler elde edilebilir.
(örneğin, merkezi çok açık olan ve kenarları daha koyu bir renge dönüşen bir daire),
phong ve gouraud'a benzer (ve bazen daha iyi) efektler elde edilebilir.
Bu efekt genellikle yanlışlıkla
environment mapping ile karıştırılır, ancak bu, nesneyi çevreleyen tüm ortamı yansıtmaya izin verir (bu ortam genellikle basitlik için bir küp olarak tanımlanır).

Bu efekt genellikle yanlışlıkla environment
mapping ile karıştırılır, ancak environment mapping, nesneyi çevreleyen tüm ortamı yansıtmaya
yarar (bu ortam, basitlik için genellikle
bir küp olarak tanımlanır, bu durumda katı cisim üzerinde altı
görüntü yansıtılır).

Bu paragrafta, yalnızca 256*256 piksel boyutlu dokular kullanarak yansıma
haritalamasının nasıl gerçekleştirileceği açıklanacaktır.
Farklı boyutlardaki dokuların uygulanması kolayca
türetilebilir.

Reflection
mapping'de yaygın bir nesneyi nasıl gerçekleştireceğimizi ayrıntılı olarak görelim.
İlk olarak, her bir köşe üzerinde tüm birim vektörleri önceden hesaplayacağız
(gouraud'da olduğu gibi) ve bunları 128 ile çarpacağız (veya
basit bir 7 bit sola kaydırma uygulayacağız), bu da
matematiksel olarak şu şekilde ifade edilir:
_ _
| PVx = 128*Nx / sqrt(Nx*Nx + Ny*Ny + Nz*Nz) |
PV | PVy = 128*Ny / sqrt(Nx*Nx + Ny*Ny + Nz*Nz) |
|_ PVz = 128*Nz / sqrt(Nx*Nx + Ny*Ny + Nz*Nz) _|

Bu 3 değeri bileşenleri olan vektöre PV diyelim.
Normal birim vektörün koordinatları, -1 ile +1 arasında gerçek sayıları içeren 3 değerdir.
 Şimdi PVx, PVy ve PVz değerlerine sahibiz.
128 ile çarpılmıştır, bu da -128 ile +128 arasında bir değer aralığını kapsayacakları anlamına gelir
(gerçekte bu değerler +127'yi asla aşmaz).
Burada ön hesaplama aşaması sona erer.

Gerçek zamanlı olarak, her bir köşe için PV vektörünü döndürmeliyiz (gerekirse
9 çarpma ile döndürme gerçekleştirilmişse, noktaların aynı döndürme faktörlerini kullanarak).
 PV vektörünün sadece döndürülmüş x ve y bileşenlerine ihtiyacımız var, bu nedenle PVz'yi döndürmeyebiliriz,
 böylece köşe başına en az 3 çarpma ve 2 toplama işleminden kurtulmuş oluruz
(tabii ki PVz'yi her bir köşe için önceden hesaplamak gerekir
PVx ve PVy'yi döndürebilmek için). PV vektörünün döndürülen x ve y bileşenlerinin her birine
128 değerini ekleriz. Bu hesaplamalar tamamlandığında, PVx ve PVy'nin alabileceği değer aralığı 0 ile 255 arasında olacaktır.
Aslında ((PVx döndürülmüş)+128) ve ((PVy döndürülmüş)+128)

Aslında ((döndürülmüş PVx)+128) ve ((döndürülmüş PVy)+128)
poligon üzerinde eşlenecek (yani çizilecek) dokunun koordinatlarını temsil eder. Bu,
 4 nokta ile sınırlanan bir poligonumuz varsa,
o poligon üzerinde 4 ilgili PVx
ve PVy (ve 128 ile toplanmış) ile sınırlanan doku kısmını o poligona haritalamamız gerekir. Ardından, doku “parçasını” o poligona haritalamak ve her görünür yüz için aynı işlemi tekrarlamak
yeterlidir
!

Şimdi, yeni PVx ve PVy hesaplandıktan sonra doku kısmını nasıl çizeceğimize bakalım.
Öncelikle poligonun tarama dönüşümünü gerçekleştirmeliyiz, ayrıca yüzümüzün tüm kenarları boyunca PVx ve PVy'yi enterpolasyon yapmamız gerekir, bu da poligonun 2 ek tarama dönüşümü anlamına gelir.
Öncelikle poligonun tarama dönüşümünü gerçekleştirmeliyiz, ayrıca
PVx ve PVy'yi yüzümüzün tüm kenarları boyunca interpolasyon yapmalıyız,
bu da poligonu PVx ve PVy'yi köşelerin x koordinatları yerine kullanarak
2 ek tarama dönüşümü yapmak anlamına gelir. Böylece toplamda
3 tarama dönüşümü vardır: ilki geleneksel olanıdır, ikincisi
köşelerin x'lerini PVx ile değiştirerek yapılır, üçüncüsü ise
x'lerin yerine PVy'leri kullanır (phong'daki normallerde yaptığımız gibi,
farklılık olarak 3 bileşen (Nx, Ny ve Nz) yerine 2 bileşen (PVx ve PVy) dikkate alırız).
Poligonun tarama dönüşümünü gerçekleştirdik, şimdi ihtiyacımız olan şey, yüze ait her noktaya dokunun belirli bir pikselini ilişkilendirebilen bir algoritmadır.
Poligonun tarama dönüşümünü gerçekleştirdik, şimdi
ihtiyacımız olan şey, yüze ait her noktaya
tek bir pikseli ilişkilendiren bir algoritmadır.
Aşağıdaki şekli ekrana yansıtılmış yüzümüz olarak düşünelim:.

 PVx ve PVy'yi enterpolasyon yaptıktan ve.
 . tarama dönüşümünü gerçekleştirdikten sonra,
P1 -> . . <- P2 ekranında, örneğin P1 ve P2,.
 . bunların x koordinatlarını PVx ve PVy ile birlikte biliyoruz..
 . Şimdi PVx ve PVy'yi.
 . P1 noktasından P2 noktasına interpolasyon yapmalıyız, böylece
. . tüm
poligon noktalarının PVx ve PVy değerlerini öğrenmiş oluruz. Bu 2 değeri bir satır boyunca interpolasyon yapmak için
P1 -> x1, y, PVx1, PVy1 genel tarama çizgisi izleme algoritmasını
P2 -> x2, y, PVx2, PVy2
dPVx = PVx1-PVx2 dx yerine dy, dPVx (PVx'i interpolasyon için
dPVy = PVy1-PVy2 PVx) ve dPVy (PVy'yi interpolasyon için) yerine
dx = x1-x2 dx, tıpkı
gouraud'da chunky pikselleri interpolasyon için yaptığımız gibi.

Daha önce de belirtildiği gibi, PVx ve PVy izlenecek piksel
dokusunun koordinatlarını temsil eder. 3 tarama dönüşümü tamamlandıktan sonra, yüzün her bir köşesine ait PVx ve
PVy değerlerini biliyoruz. Ardından, PVx ve
PVy değerlerini tüm poligon boyunca enterpolasyon yaparak, yüzün tüm noktaları için
dokunun koordinatlarını elde ederiz! Şimdi, basit
kopyalama işlemleriyle, poligonu, her noktasına
(PVx,PVy) konumundaki doku chunky pikselini ilişkilendirerek eşleyebiliriz.


DOKU EŞLEŞTİRME
==========================================================================

Bu efekt, bir görüntünün tamamını bir poligon üzerine izlemeye olanak tanır.
 Pratikte, her yüze bir doku “yapıştırmış” gibi olur
.
Bu paragrafta, perspektifsiz doku eşlemeyi ele alacağız.
Bu, bir görüntüyü bir poligon üzerine eşlemek için en hızlı algoritmadır,
 ancak aynı zamanda en gerçekçi olmayan algoritmadır.

4 kenarlı poligonlar kullandığımızı varsayalım, poligonun her kenarı yüzün bir kenarıyla çakışır, yapmamız gereken
tek şey tüm dokuyu poligonun üzerine izlemektir. Pratikte bu,
izlenecek dokunun koordinatlarının her zaman sabit olduğunu ve dokunun
4 köşesiyle tam olarak çakıştığını bilerek yansıma haritalama yapmamız
gibi bir şeydir. Dokunun 256*256 piksel ise, PV1(0,0), PV2(255,0), PV3(0,0)
köşesi ile tam olarak çakıştığını bilerek yansıma haritalama yapmamız gibi. Doku 256*256 piksel ise, PV1(0,0), PV2(255,0),
PV3(255,255), PV4
(0,255)(0,255) 'in her poligon için aynı olduğunu bilerek bir yansıma haritalama algoritması gerçekleştireceğiz. Başka
bir deyişle, dokunun x ve y koordinatlarını
tüm poligon boyunca, izlenecek yüze ait her piksel için
dokunun ilgili noktasının hangisi olduğunu bilmek için enterpolasyon yapacağız. Hepsi bu kadar.


fREE dIRECTION tEXTURE mAPPING 
==========================================================================


tEXTURE mAPPING bILINEARE
==========================================================================


tEXTURE mAPPING bIQUADRATICO
==========================================================================


bUMP mAPPING
==========================================================================


cLIPPING 2d
==========================================================================


oTTIMIZZAZIONE dEL fILL
==========================================================================


EK a: KAYITLI VİRGÜL NOTASYONU
==========================================================================

3D nesnelerin işlenmesinde genellikle tamsayı olmayan gerçek sayılarla
karşılaşılır. Gelişmiş dillerin çoğu, bu sayıların doğrudan
işlenmesine izin verir, gerekirse bir matematiksel
matematiksel koprosesörden yararlanarak veya bunları yazılımla taklit ederek. Mevcut derleyicilerin sağladığı taklit,
 gerçek zamanlı uygulamalar için oldukça yavaştır.
 Ayrıca, Assembly ile çalışılıyorsa,
matematiksel koprosesör kullanılmadıkça gerçek sayıları doğrudan yönetmek mümkün değildir.
 FPU'ya (
kullanır) yerine, sabit virgül formatını tercih edebilirsiniz.
 Sabit virgül formatı, kayan virgül formatına göre daha az hassas olmasına rağmen,
 bu formatta gerçekleştirilen işlemler daha hızlı olduğu için en iyi seçimdir
.
Prensip olarak, bir elektronik işlemcide, tüm sayılar
(gerçek sayılar da dahil) tamsayı olarak temsil edilir; sabit virgül notasyonu
bu temsilin doğrudan basitleştirilmesine dayanır,
 nasıl olduğunu görelim.

Bir gerçek sayı, gerçek sayının önceden tanımlanmış bir sabit ile çarpımının verdiği tamsayı değeri olarak temsil edilir
.
Tamsayı olmayan sayıların temsil edilebilme hassasiyeti bu sabite bağlıdır.
 İşte bir örnek:

3,25 <- gerçek sayı
256 <- sabit

3,25*256 = 832 <- 3,25 sabit virgülle

Bu şekilde, tüm gerçek sayıları, uygulamalarımız için pratikte önemsiz olan
bir hata payı ile temsil edebiliriz.
 Sabit olarak 2'nin bir kuvvetini kullanmak uygundur
(örneğin: 256, 65536) kullanmak uygundur, bu sayede bu gösterimde sayıların işlenmesi hızlandırılabilir.
 Bilindiği gibi, bilgisayar
herhangi bir sayıyı bir bit dizisi olarak gösterir, bu nedenle
2'nin kuvveti sabit olarak kullanıldığında, her basamak için 2 bit alanı tanımlanabilir
: biri tam kısma, diğeri kesirli kısma ayrılır.
Bir sabit virgülü sayının tam kısma ayrılan bit sayısı
<a> ve kesirli kısma ayrılan bit sayısı
<b> ise, o sayının “a:b” biçiminde olduğu söylenir.
Ayrıca, sabit virgülü bir sayının tam kısmının en yüksek bit alanına ait olduğunu, kesirli kısmının ise en düşük bit alanına ait olduğunu belirtmek gerekir. 
Ayrıca, sabit virgüllü bir rakamın tam kısmının
en yüksek bit alanına, kesirli kısmının ise
en düşük bit alanına ait olduğunu belirtmek gerekir.

3.25 <- gerçek sayı
256=2^8 <- sabit
832 <- 3.25 sabit virgüllü
8:8 <- sabit virgüllü sayı biçimi.
1 kelime (16 bit) kullanırsak, en anlamlı 8 bit
tam kısma ayrılır ve
diğer 8 bit ise kesirli kısma ayrılır.

Bir tam sayıyı sabit virgüllü biçime ve
tersine nasıl dönüştüreceğimizi görelim:

tam sayı = (sabit virgül sayı) / (sabit)
sabit virgül sayı = (tam sayı) * (sabit)

Son olarak, bu sayılarla 4 işlemi nasıl yapacağımızı anlayalım
:

(a:b) + (c:d) = imkansız!!
(a:b) + (a:b) = a:b
(a:b) * (c:d) = (a+c):(b+d)
(a:b) / (c:d) = (a-c):(b-d)

Farklı formattaki 2 sabit virgül sayısını toplamanın imkansız olduğunu hemen fark ederiz,
 önce 2 rakamı aynı hale getirmeliyiz
(yani 2 rakamın aynı formatta olması gerekir). Şu noktaya dikkat edin
herhangi bir tam sayı, “a:0” formatında sabit virgülle ayrılmış bir sayı olarak anlaşılabilir
; bu nedenle, sabit virgülle ayrılmış sayılar ve tam sayılar arasında
çarpma ve bölme işlemlerini doğrudan gerçekleştirmek mümkündür.


EK b: KUTUP KOORDİNATLARI
==========================================================

Bildiğimiz gibi, bir düzlem üzerinde genel bir noktayı temsil etmek için
kartezyen eksenleri kullanabiliriz. x ve y bileşenleri,
 noktamızın x ve y eksenlerine izdüşümlerinden başka bir şey değildir
.
Bunun yerine, başka bir referans sistemi kullanarak bir noktayı belirtmek istediğimizi düşünelim,
 bizim durumumuzda kutup koordinatları.

^ P noktası ile
y | .P(x,y) arasındaki mesafeyi r, OP
| / segmenti ile pozitif x ekseni arasındaki açıyı t olarak alalım.
| / Herhangi bir noktayı
| r/ bu 2 değişkeni (r ve t) kullanarak gösterebiliriz, bunlar
| / tam olarak kutup koordinatlarını temsil eder.
|/) t Her P(x,y) için bir P'(r,t) karşılık gelir.
+------------> bu dönüşümleri nasıl yapacağımızı görelim.
O x
R(x,0) P(x,y) 'nin x eksenine izdüşümü olsun
^ (yani ordinat noktası 0 ve eşdeğeri
y | .P(x,y) P'nin absis noktası). ORP üçgeni R'de dik üçgendir,
| /| bu nedenle Pisagor teoremine göre:
| / |
| r/ | r = OP = sqrt( x*x + y*y )
| / |
|/) t | Şunu da söyleyebiliriz:
+-----+------>
O R x PR = r*sin(t) => sin(t) = PR/r
OR = r*cos(t) => cos(t) = OR/r

Dikkatli olursak şunu söyleyebiliriz (P(x,y) noktasını dikkate alarak)
 PR=y ve OR=x. Bir açının tanjantı, o açının sinüsünün kosinüsü ile oranına eşittir, dolayısıyla:
tan(t) = sin(t)/cos(t) = (PR/r)/(OR/r) = PR/OR = x/y

x/y = tan(t) t = arctan(x/y) r = sqrt(x*x+y*y) x = r*cos(t) y = r*sin(t)
x/y = tan(t)

t = arctan(x/y)
r = sqrt(x*x+y*y)

x = r*cos(t)
y = r*sin(t)

Artık kartesyen koordinatları kutupsal koordinatlara ve
tersini nasıl dönüştüreceğimizi biliyoruz, bu da bir noktanın
dönüşünü nasıl gerçekleştireceğimizi anlamak için yararlı olacaktır.


EK c: NESNELERİN YÖNETİMİ
==========================================================================

Nesnemizi ekran üzerinde tel kafes,
gouraud gölgeleme, doku eşleme veya en çok hoşumuza giden başka bir render tekniği ile çizmek istiyoruz
istediğimiz teknikle çizmek istiyoruz; tek bir yüzü nasıl görüntüleyeceğimizi çok iyi biliyoruz,
 ama üç boyutlu katıyı oluşturan tüm yüzleri nasıl yönetebiliriz
?
Nesnenin bellekte yer alacağı bir “format” tanımlamamız gerekiyor,
 bu formata göre 3D motorumuzu oluşturan aynı rutinleri kullanarak herhangi bir 3D şekli görüntüleyebileceğiz.
 Pratik bir örnekle başlayalım
:

V5 _____________ V6 basit bir küpü nesne olarak tanımlamamız gerektiğini göz önünde bulunduralım.
/|     /| İlk olarak
/ |     / | küpün köşe ve yüz sayısını belirleyebiliriz.
/ |     / |
/ |     / | ardından küpün köşelerinin tüm
V1 /____|_______ /V2 | koordinatlarını (x,y,z) listeleyelim;
| | | | son olarak tüm yüzlerin özelliklerini
| V8|_______|_____|V7 belirtelim. En basit durumda
| / | / bir yüzü tanımlamak için köşelerini
| / | / belirtmek yeterlidir (gerekirse saat yönünde
| / | / gizli yüzün kaldırılmasını ve
| / | / normalin hesaplanmasını kolaylaştırmak için saat yönünde sıralanabilir).
|/____________|/ İşte bir küpü bellekte tanımlamak için
V4 V3 nasıl yapılabilir:

8 <- nesnenin köşe sayısı
6 <- nesnenin yüz sayısı
-50,-50,-50 <- köşe V1'in x,y,z koordinatları
+50,-50,-50 <- köşe V2'nin x,y,z koordinatları
+50,+50,-50 <- köşe V3'ün x,y,z koordinatları
-50,+50,-50 <- köşe V4'ün x,y,z koordinatları
-50,-50,+50 <- V5 köşesinin x,y,z koordinatları
+50,-50,+50 <- V6 köşesinin x,y,z koordinatları
+50,+50,+50 <- V7 köşesinin x,y,z koordinatları
-50,+50,+50 <- V8 köşesinin x,y,z koordinatları
1,2,3,4 <- yüz 1'i oluşturan köşelere işaretçiler
2,6,7,3 <- yüz 2'yi oluşturan köşelere işaretçiler
6,5,8,7 <- yüz 3'ü oluşturan köşelere işaretçiler
5,1,4,8 <- yüz 4'ü oluşturan köşelere işaretçiler
5,6,2,1 <- yüz 5'i oluşturan köşelere işaretçiler
4,3,7,8 <- yüz 6'yı oluşturan köşelere işaretçiler

Poligonların nasıl tanımlandığını inceleyelim, yüz 1'i ele alalım:

1,2,3,4 <- yüzün köşe listesindeki ilk 4
noktalardan oluştuğu anlamına gelir, yani:

-50,-50,-50 <- köşe V1'in x,y,z koordinatları
+50,-50,-50 <- köşe V2'nin x,y,z koordinatları
+50,+50,-50 <- köşe V3'ün x, y, z koordinatları
-50,+50,-50 <- köşe V4'ün x, y, z koordinatları

Her kenar, 2 tepe noktasının doğrusal birleşimiyle temsil edilir.
Az önce verilen örnekte, yüz 1'in kenarları, birinci ve ikinci noktalar (V1 ve V2), ikinci ve üçüncü noktalar (V2
ve V3), üçüncü ve dördüncü noktalar (V3 ve V4) ve dördüncü ve birinci noktalar (V4 ve
V1)
arasında sınırlanan segmentlerdir..
Bizim durumumuzda her yüz bir dörtgendir, ancak elbette
farklı sayıda kenar kullanan kendi 3D motorunuzu da oluşturabilirsiniz.
Önemli olan her poligonun dışbükey olmasıdır, aksi takdirde
tarama dönüştürme algoritması, dolgu ve tarama çizgisi ile ilgili paragrafta incelenen algoritmadan
çok daha karmaşık hale gelir.


SON NOTLAR
==========================================================================

Öncelikle, 680x0 üzerinde Assembly'nin sağlam temellerini edindiğim ve efsanevi Amiga'nın ECS/AGA özel çiplerini kullanmak için gerekli bilgileri öğrendiğim Randy/RamJam (Fabio Ciucci)
'ya teşekkür ederim.
Hedgehog/???
(Marco Ricci) 'ye de minnettarım. Bu belgeyi yazmamı sağlayan çok sayıda bilgi ve “kodlama” teknikleri konusunda yararlı tavsiyeler sağladı. (Marco
Ricci) 'ye de minnettarlığım az değildir (bu belgeyi yazmamı sağlayan
çok sayıda bilgi ve “kodlama” teknikleri konusunda yararlı tavsiyelerde bulundu).
Ayrıca, Psyko/Vajrayana (Pasquale Mauriello)
'ya da, çalışmak ve bilgimi doğrulamak için bana kağıt üzerinde materyal gönderdiği için teşekkür ederim
.
İtalyan sahne sanatçılarının, iyi ya da kötü olsun, bir üretim gerçekleştirmek için
çalıştıklarını biliyorum:
önemli olan, sonuçların kendi emeklerinin ürünü olmasıdır.

Bu metin dosyasının son sürümünü ücretsiz olarak e-posta ile almak veya
hatalar veya yanlışlıklar hakkında bilgi vermek isteyenler
e-posta yoluyla benimle iletişime geçebilirler:

dayco@rgn.it

veya posta yoluyla yazabilirsiniz:

Cristiano Tagliamonte
Via Filippo Masci, 86/G
66100 Chieti


______ ____ _ _ ___ _
/ || __|| __||\ /| / ||\ ||
//|||| ||_ | \/ | //||| \||
/__ |||__ ||__ ||\/|| /__ |||\ |
// |||___||___||| ||// |||| \|
========================aCEmAN/bSd
