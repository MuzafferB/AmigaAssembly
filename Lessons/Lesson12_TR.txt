
ASEMBLER KURSU - DERS 12

Yazar: Fabio Ciucci

Bu derste, kodun UYUMLULUĞUNU elde etmek için gerekli teknikleri öğreneceksiniz.
 Bu çok önemli bir konudur: Programladığınız oyun
veya demo'nun tüm Amiga modellerinde çalışmasının ne kadar önemli olduğunu bir düşünün!!!
Bu kesinlikle zor değildir, ancak birçok
eski oyun ve demo'nun kick 2.0, 68020, a1200'de çalışmadığı biliniyor ve hatta
sadece genişletilmemiş A500 1.3'te çalışan şeyler var,
fast ram veya artık çalışmayan yeni kickstart'ı takmak yeterli.
Tüm bu sorunlar birkaç nedenden kaynaklanıyor, aynı aptal nedenlerden,
aslında bir demo veya oyunun kodunun %99'u sadece a500 1.3'te çalışıyor
, o 2 veya 3 satırlık
“KIRLI” kod olmasaydı, genellikle önyükleme sırasında her şeyi kilitleyen, tüm Amiga'larda çalışırdı.
Şahsen ben her zaman tüm bu BUG'ları, yani
500 1.3'ten üstü makinelerde görünen programlama hatalarını anlamaya çalıştım ve
çoğu zaman, çalışmayan oyunları veya demoları, kodu söküp
tekrar eden hataları değiştirerek. Bu şekilde, yararlı olanı eğlenceli olanla birleştirdim:
bir yandan, A1200 veya diğer bilgisayarlara sahip arkadaşlarımın, 500 1.3'e sahipken çok sevdikleri oyunu veya
demoyu çalıştırmalarını sağladım, diğer yandan
“donmaların” nedenleri hakkında oldukça iyi bir bilgi birikimi edindim
 
ve bunların her zaman
her zamanki birkaç “programlama hatası” olduğunu gördüm. Bunları aşağıda listeleyeceğim.
Bu hatalar nedeniyle, Amiga donanımında doğrudan assembler ile yazılmış yazılımların çoğu
uyumsuz ve güvenli olmadığı için kötü bir şöhret kazandı
ve assembler'ın kendisi, özellikle
"
donanım doğrudan“ olan, ”metalbashing" olarak adlandırılan.
Oysa tüm bu sorunlar kolayca önlenebilir, sadece
bazı şeyleri YAPMAMAK yeterlidir ve oyun/demo tüm Amiga'larda çalışacaktır.
Aslında, bu kursun tüm listeleri, örneğin, hem Amiga
500 1.3 hem de Amiga 4000/040'ta çalışır ve tabii ki diğer tüm
ara bilgisayarlar ve her türlü konfigürasyonda da çalışır.
Tabii ki, RISC veya AAA yonga setine sahip varsayımsal Amiga modellerinin uyumluluğunu garanti edemem
RISC veya AAA yonga setine sahip Amiga modellerinin uyumluluğunu garanti edemem, ancak bu durumda HİÇBİR OYUN
ve protracker gibi programlar çalışmaz. Aslında, 680x0 serisinin ve ECS ile (en azından) aşağı doğru uyumluluğunun
korunmasını umuyorum, aksi takdirde “Amiga” adı verilen, ancak MSDOS ile uyumlu olmayan PC'lerle karşı karşıya kalırız.
Bunun yerine, RISC'ten hiçbir şekilde geri kalmayan 150 MHz'lik 68060 tabanlı bilgisayarlar ve
chip ram'in “yerel veriyolu”, yani bu tür belleğe erişimi hızlandıran bir
özellik yapardım, çünkü mevcut modellerde
bu çok yavaş (lanet olası son dakika C= mühendisleri).
Bu konuyu şimdi ele almaya karar verdim, çünkü
hata yapabilmek için en azından programlama bilmek gerekir, bu yüzden programlamanın temellerini açıklamadan bu dersi vermek mantıklı değildi.
Bu dersten sonra belki eski uyumsuz oyunlarınızı çalıştırabileceksiniz!
Bu derste “NASIL PROGRAMLAMAK GEREKİR”i, tüm doğru prosedürleri gördünüz, bu yüzden yıllar önce yapılan saçmalıkları görmezden gelin. İşte “paperissima” hatalarının bir listesi:
-
Ders boyunca “NASIL PROGRAMLAMAK GEREKİR”i tüm doğru prosedürlerle gördünüz,
 bu yüzden yıllar önce yapılan saçmalıkları görmezden gelin.
İşte tüm makinelerde çalışmayan
programlarda bulduğum “çok basit” hataların bir listesi: (A4000/040 üzerinde test edilmiştir)

****************************************************************************
BÖLÜM 1: $dffXXX KAYITLARIYLA İLGİLİ HATALAR, YANİ COPPERLIST VE BLITTER
****************************************************************************

1) “Düzeltilebilir” hatalar arasında en az ciddi olanı, eski üretimlerde bir hata sayılmaz
,
 çünkü AGA'nın varlığından haberdar olamazlardı:
Bu hata, copperlist'i işaretledikten sonra AGA'yı aşağıdaki 3 komutla sıfırlamayı “unutmak”tır
: (Daha önce değil!)

lea    $dff000,a5    ; A5'teki temel CUSTOM adresi ofsetler için
move.l    #copper,$80(a5)    ; COP1LC - Copperlist'i işaret et
move.w    d0,$88(a5)    ; COPJMP1 - Copperlist'i başlat

;    AGA'yı devre dışı bırakalım:

move.w    #0,$1fc(a5)    ; spriteleri genişlet ve 64 bit patlamayı DEVRE DIŞI LAŞTIR
MOVE.W    #$c00,$106(A5)    ; AGA paletini, sprite çözünürlüğünü
ve çift oyun alanı paletini sıfırla
MOVE.W    #$11,$10c(A5)    ; AGA sprite paletini sıfırla

Bu hata, bilgisayarın önyüklemesinden her iki
fare tuşuna basarak ve eski yonga setinin emülasyonunu seçerek giderilebilir.
Ancak bakır sorunları bununla bitmiyor, herhangi bir COPPER kaydını tanımlamayı unutursanız
hata
ortaya çıkıyor!
 Aslında, modülleri tanımlamayan birçok eski demo/oyun copperlist'i buldum, bu nedenle sistem copperlist'inin DEĞERLERİ
kalıyor ve bunların ne olabileceği bilinmiyor. Aslında en yaygın hata,
 modülleri ($108 ve $10a) koymamak ve bunların
sıfırlandığını varsaymaktır. BU, KICKSTART 1.3 İÇİN DOĞRUYDU!! ANCAK 2.0'DAN İTİDEN MODÜL
SIFIR DEĞİLDİR!!! Bu nedenle intro/demo/oyunlar “çizgiler” halinde görülür,
kickstart 1.3 yüklenmedikçe. Aynısı DiwStart/DiwStop
vb. için de geçerlidir. İşletim sisteminin belirsiz değerlerinin kalmaması için, sıfırlanmış olsalar bile, tüm kayıtları copperlist'e koymayı DAİMA unutmayın
!!!
dc.w    $108,0        ; Bpl1Mod

dc.w    $108,0        ; Bpl1Mod
dc.w    $10a,0        ; Bpl2Mod
dc.w    $8e,$2c81    ; DiwStrt
dc.w    $90,$2cc1    ; DiwStop
dc.w    $92,$38        ; DdfStart
dc.w    $94,$d0        ; DdfStop
dc.w    $102,0        ; BplCon1
dc.w    $104,0        ; BplCon2

Eski bakır listelerini incelerken başka saçma hatalar da buldum.
Bazıları kayıtları AYARLAMAK yerine, gizemli bir şekilde AYARLIYORLARDI
FAZLA!!! Aslında, BİLİNMEYEN VEYA
HENÜZ KULLANILMAMIŞ BİR KAYDE ASLA ERİŞİLMEMELİ, BİLİNEN KAYITLARDA ÖZEL VEYA
İŞLEVSİZ BİT'LER AYARLANMAMALI VE SIFIRLANMAMALIDIR, aksi takdirde
gelecekteki yonga setlerinde garip işlevlerin etkinleştirilmesi riski vardır. Şu ana kadar en büyük gelişme
ECS'den AGA'ya geçişte yaşandı ve “kör ayar” hataları
beklediğimden daha fazla. Örneğin, çok eski bir Ackerlight intro'sunun
copperlist'inde şu tuhaflığı buldum:

....
dc.w    $100,$5000    ; BPLCON0
dc.w    $0092,$30    ; DDFSTRT
;--->	dc.w    $106,$FE5    ; Neden o
; zaman var olmayan bir kayıt eklediler? Sahte AGA'da palet
dc.w    $102,$CC    ; BPLCON1
dc.w    $108,$A8    ; BPL1MOD
dc.w    $10A,$A8    ; BPL2MOD
....

Bu hata, AGA'lar çıkıncaya kadar fark edilmedi
ve bu hatanın KESİNLİKLE GİDERİLEMEZ olduğunu unutmayın.
Çalışmayan malzemeyi sökmeden önce, sorunu anlamak için mümkün olan tüm testleri yaparım
: fastmemory'yi çıkarırım, kick 1.3'ü yüklerim
önbelleği, MMU'yu devre dışı bırakıyorum, VBR'yi sıfırlıyorum vb. Bu hata
yine de ortaya çıkıyordu: renkler yanlıştı, geri kalan her şey çalışıyordu.
Aslında bu hataları düzeltmenin tek yolu, onları bulup
koddan çıkarmaktır. O $106,$fe5'i $92,$30 ile değiştirdim, yani
önceki satırı kopyaladım ve her şey mükemmel çalıştı.
Belki de kodlayıcı bu değişikliği fark etmemiştir, bir
yazım hatası olabilir, belki $108 yazmak istemişti, $106 değil, kim bilir, ama
sadece bilinen kayıtlar veya bitler üzerinde çalışmaya dikkat edin, yoksa
torunlarınızın Amiga 9000'lerinde ürününüzün çalışmadığını görmekten
ve bu tek bir aptal copperlist satırı yüzünden olacak.
Sprite yapılarına da dikkat edin, çünkü OCS'den
ECS'ye kadar dördüncü kontrol baytında fazladan bitler var: 
“kirli” görünen veya ekranın sonuna kadar uzayan birçok sprite,
SADECE ECS/AGA makinelerde bu durumdadır, eski a500/a2000 makinelerde değildir, çünkü
sprite yönetim rutini bu biti sıfırlamak yerine
ayarlı bırakıyordu. Tasarımcılar, bilinen kayıtların kullanılmayan bitlerini SIFIRLIĞI bırakmanızı
ve henüz bilinmeyen bitlere kesinlikle ERİŞMEMENİZİ
tavsiye eder. Bunu unutmamanızı şiddetle tavsiye ederim.

-    -    -    -    -    -    -    -

2) $dffXXX kayıtlarında CLR komutunu kullanmayın, çünkü bu komut
68000 ve 68020/30/40 işlemcilerde farklı davranır, aslında
68000'de bir okuma ve bir yazma, yani 2 erişim neden olurken,
68020/30/40'ta tek bir erişim neden olur. Farklı işlemcilerde farklı sonuçlar almamak için
STROBE tipi kayıtlara
başka bir şekilde erişmeyi unutmayın (COPJMP1 = $dff080, COPJMP2 = $dff088 vb.). Bir yol
MOVE.W d0,$dff080 olabilir. CLR'nin diğer $dffXXX kayıtlarında, örneğin $dff064 (BLTAMOD)
kullanıldığında da sorunlar yaşadım.

Örnek 1:
MOVE.W    #0,$DFF088    ; asla CLR.W $dff088 yapmayın!
veya
MOVE.W    d0,$dff088
...

Örnek 2:
MOVE.W    #0,$DFF064    ; asla CLR.W $dff064 yapmayın!
veya
MOVEQ    #0,d0
MOVE.W    d0,$dff064
...

Güvenlik için, kayıtlar veya doğrudan değerler (#0,$dffxxx) aracılığıyla erişmenizi ve asla bir $dffxxx kaydında CLR kullanmamanızı öneririm.
-    -    -    -    -    -    -    -    - 3) 1988-1989 yıllarında, bakır listelerine işaret etmek için

-    -    -    -    -    -    -    -    -

3) 1988-1989 yıllarında, copperlist'leri işaret etmek için oldukça aptalca bir yöntem kullanılıyordu,
 ancak bu yöntem, 2.0'dan sonraki işletim sistemi sürümleriyle uyumsuz olduğu ortaya çıktı
çünkü bazı sistem yapıları varsayılmıştı
ve bunlar Commodore tarafından belgelenmediği için
değiştirilmiş ve “kurnazlar” A500+ ve A600'lerde copperlist'leri işaretlemeyen kaynak kodlarıyla baş başa kalmışlardı.
 Ne yazık ki, programlama konusunda çok deneyimli olmayan bazı kişiler,
 eski listelerden buldukları parçaları “çalarak”
bulduklarını çalmaya devam ettiler. Bu kodlar, copperlist'e yönlendiren bu saçma kodu içeriyordu,
 bu nedenle 1990-91 tarihli bazı demoların bile
kickstart 1.3'e ihtiyaç duyması bu dikkatsizlikten kaynaklanıyor.
Birkaç “kurnaz” kodlama öncüsü tarafından icat edilen bu utanç verici kodu aşağıya aktarıyorum:

move.l 4.w,a6        ; execbase
move.l (a6),a6        ; ???
move.l (a6),a6        ; HAHAHA! GFXBASE??? Sadece kick1.3'te!
move.l    $26(a6),OLDCOP    ; HAHAHA! ESKİ COPLIST'İ KAYDET???
move.l    #MYCOP,$32(a6)    ; ÇİFT HAHAHAHA! COPLIST'İ KAYDET???
...

Bu kod parçası ne yazık ki eski listelerde
ve veritabanlarında ve intro'larda (örneğin ORACLE'ın intro'su) çok yaygındır.
Bu
4 satırlık KİRLİ kodda yer alan ÇİFT hatayı yapmamayı unutmayın: Öncelikle GFXBASE,
ders örneklerinde yapıldığı gibi graphics.library dosyasını açarak bulunur,
“move.l (a6),a6” komutunu iki kez girerek değil. Bu, eski kütüphanenin özel yapısı nedeniyle
kickstart 1.2 ve 1.3'te rastgele gerçekleşir.
İkinci hata, copperlist'i $dff080 kaydına değil, GFXBASE yapısına
adresini girerek işaretlemektir, bu
sonsuz felaketlere neden olur, copperlist'i her zaman şöyle işaretleyin:

MOVE.L    #Copperlist,$dff080    ; COP1LC
move.w    d0,$dff088        ; COPJMP1

-    -    -    -    -    -    -    -

4) Eski nesil kodlayıcıların bir başka alışkanlığı da, bir blit işlemi bitmeden
diğerine geçmemekti. Bu, 1990'dan önce yazılmış kodlarda çok kolay
görülebilir, ancak bazıları hala WaitBlit rutinlerini atlamaya devam ediyor.
Aslında, Amiga'larda sadece 68000 işlemci varken,
 bir blitter işlemi ile diğer blitter işlemi arasında, işlemcinin
blitter'ın zaten tamamladığı kadar çok işlem yapması gereken durumlar vardı.
Demo (ve ne yazık ki oyun) programcıları genellikle
Wait rutini koymasalar bile her şey çalıştığı için blitter'ı beklemenin gereksiz olduğunu düşünürlerdi.
Bunun bir örneği PANG oyunudur...
Ancak demo/oyunlarında 2 satır koddan tasarruf etmiş olsalar da,
çalışma hızını artırmamışlardır (birkaç
“btst #6,$dff002” komutu hızı yavaşlatmaz...), ama daha hızlı işlemcilerde
blitter işlemleri arasındaki sürenin
kısaldığını da hesaba katmadılar, çünkü 68020'nin 68000'den daha hızlı olduğu biliniyordu,
bu yüzden çökme tamdı.
Ne yazık ki blitter, ECS ve AGA'da aynı yavaşlıkta kaldı
(a4000 veya a1200'de hızlandırıldığında normalden bile daha yavaş!).
Bu tür programlama “hafifliklerinin” neden olduğu sorunları çözmek için
bazen önbelleği ve hızlı RAM'i kaldırmak yeterlidir, böylece 68020 bile
önbellek devre dışı bırakılmış RAM yongasında çalışıyorsa, bazen
zaten çalışmakta olan bir blipper'ın üzerine başka bir blipper'ın gelmesini önleyecek kadar yavaşlar.
Kötü olan şey, donanım senkronizasyonu nedeniyle,
A4000 veya A1200 gibi 68030 ile hızlandırılmış bilgisayarlarda blitter,
Eski A500'den DAHA YAVAŞTIR, bu nedenle, işlemciyi
68000 taban hızına yavaşlatmayı başarsak bile, blitter daha yavaş olduğu için çökme kaçınılmaz
ve kesinlikle istenmeyen bir durumdur.
Ayrıca, tüm rutinler
bir blitter işlemi bitmeden diğerine geçmemek için bekliyor olsa bile, blitter,
A4000'de daha yavaş olduğu için
oyunlarda veya demoların akıcı bir şekilde (saniyede 50 kare) ve A500'de
oyun veya demoyu daha hızlı çalıştığını sanan A4000 sahiplerini sinirlendirebilir
.
Bu nedenle, HER ZAMAN ve HER DURUMDA blitterin bitmesini bekleyin:

LEA    $dff000,a5
WaitBlit0:
BTST.B    #6,2(a5)
WaitBlit1:
BTST.B    #6,2(a5)    ; A1000'de hata olup olmadığını 2 kez kontrol edin
BNE.S    WaitBlit1

P.S: Bazen “btst #14,$dff002” yerine
“btst #6,$dff002” yerine “btst #14,$dff002” ifadesini görebilirsiniz, ancak
her zaman 6. bit test edildiği için etkisi aynıdır. Aslında 6+8, 14 eder. BTST
sadece bayt üzerinde çalışır ve her durumda altıncı biti test eder. Estetik
(ve mantık) nedenleriyle btst #6 kullanılması, btst #14 yerine tercih edilir!

Hızlandırılmış makinelerde blitter'ın ne kadar yavaşladığını anlamak için
örneğin, bir rutin, bir A1200 bazında
kare başına 14 bob bliçlerken, bir A4000'de sadece 12 ve
40 MHz'lik GVP 030 hızlandırıcı kartlı bir A1200'de sadece 9 bliçlerdi!!!!
Bu nedenle, mümkün olduğunda, blitter yerine işlemciyi kullanmak daha iyidir.
kullanmak daha iyidir.
Ayrıca, son milisaniyeye kadar blitter kullanmak yerine, her zaman birkaç raster satırını “boş” bırakmak iyidir.
Aslında, son durumda,
hızlandırılmış a4000 veya a1200'de blitter'ın yavaşlamasıyla
bir kareye sığmaz ve her şey çok takılır.

****************************************************************************
PARTE 2: ERRORI RIGUARDANTI CIAA/CIAB - TASTIERA, TIMERS, TRACKLOADERS
****************************************************************************

5) Caps lock tuşunun LED'ini yanıp söndüren rutinler
A1200'de çalışmaz çünkü standart klavyelerden farklı, ucuz bir klavyeye sahiptir.
Bu rutinler bazı demolarında “güzellik” amacıyla bulunur, aşağıda bir tanesini görebilirsiniz,
 deneyin ve A500/a2000/a3000/a4000'de yanıp sönmeyi fark edeceksiniz,
 ancak A1200'de güzel bir reset göreceksiniz:

CAPSLOCK:
LEA    $BFE000,A2
MOVEQ    #6,D1        ; $bfee01-input-output bit of $bfec01'in 6. biti
CLR.B    $801(A2)    ; TODLO sıfırlama - 50-60hz zamanlayıcının 7-0 bitleri
CLR.B	$C01(A2)    ; SDR'yi temizle (senkron seri shift
; klavyeye bağlı)
DOFLASH:
BSET    D1,$E01(A2)    ; Çıkış
BCLR    D1,$E01(A2)    ; Giriş
CMPI.B	#50,$801(A2)    ; 50 boş bekleme (CIA zamanlayıcı) 
BGE.S    DONE
BSET    D1,$E01(A2)    ; Çıkış
BCLR    D1,$E01(A2)    ; Giriş
MOVE.W    $DFF01E,D0    ; d0'da sorgula
ANDI.W	#%00000010,D0    ; I/O PORTS'u kontrol et
BEQ.S    DOFLASH
DONE:
RTS

Amiga 1200'ün ucuz bir klavye denetleyicisi vardır, bunu kontrol etmek için
şu testi yapın: “r” tuşuna basın, basılı tutun ve
başka bir tuşa basın, örneğin “u”. A1200'de hiçbir şey olmaz,
ancak başka bir bilgisayarda “u” ekranda görünür.
Bu nedenle, klavyeyi yöneten rutinlerle oynamayın!
Bu rutin nedeniyle A1200'de çalışmayan demolarından biri ODISSEY'dir.

Sürücü kafalarını “hareket ettiren” rutinler ile ilgili olarak
temel hata, senkronizasyon rutinlerinde hata yapmaktır,
 bunları basit “boş” döngüler veya NOP serileri ile yapmak,
 daha hızlı işlemcilerde, yeterince beklemek için çok hızlı çalışır.
 VBLANK veya CIA ile zamanlayın!

****************************************************************************
PARTE 3: ERRORI RIGUARDANTI I PROCESSORI 68010/20/30/40/60
****************************************************************************

6) Öncelikle, kullandığımız yardımcı programlarda da hataları aramak gerekir,
 sadece çalıştırılabilir dosyada değil. Aslında, sık sık
demo veya intro'ları (hemen “çöküyorlardı”) sadece açıp
modern bir cruncher ile yeniden sıkıştırarak çalıştırdım, örneğin Powerpacker veya
StoneCracker 4. Aslında,
mutlak adreslere sahip eski sıkıştırıcıların (crunchers) çoğu 68010+ üzerinde çalışmaz, bu nedenle demo
kendi başına çalışsa bile, eski bir ByteKiller
veya TetraPacker ile sıkıştırılmış olması, çalışmaya başlamadan önce, dekrunch sırasında guru hatasına neden olur.
Bu nedenle, öncelikle programınızı eski
crunchers ile sıkıştırmayın, Stone Cracker4, PowerPacker veya Titan Cruncher kullanın.
Ayrıca, mutlak adreslere kod yazmaktansa, yeniden konumlandırılabilir kod yazmak her zaman daha iyidir
!!!

-    -    -    -    -    -    -    -    -

7) Adres hataları:
Bazı eski üretimlerde ROM adreslerine erişimler bulunmaktadır,
 örneğin:

JSR    $fce220

Kickstart 1.2/1.3, eski Amiga'larda 
$fc0000 ile $ffffff arasındaki bellek konumlarında, toplam 256k.
Bu kickstart'larda her rutinin kendi adresi olduğu açıktır:
daha önce gördüğümüz gibi, Execbase adresinde bir “JMP tablosu” vardır,
yani, örneğin, execbase a6'da olduğunda,
$84 bayt önce, ROM'da Forbid'i çalıştırmak için atlayan JMP'yi bulacağız:

jsr    -$84(a6)    ; Forbid, çoklu görevi devre dışı bırak

Örneğin kickstart 3.0'da (Sürüm 39.106) bu, execbase'in
JMP tablosudur (bir kısmı ayrıştırılmış):

...
JMP    $00F815CC    ; ...
JMP    $00F815A2    ; -$96(a6)
JMP    $00F81586    ; -$90(a6)
JMP    $00F8286C    ; -$8a(a6) - permit rutini
---»    JMP    $00F82864    ; -$84(a6) - FORBID rutini
JMP    $00F817F8    ; -$7e(a6)
JMP    $00F817EA    ; ...
...

Kickstart V39.106 yüklü bir bilgisayarda, aşağıdaki komutla FORBID elde edilebilir:

JSR    $F82864        ; A1200/A4000'deki kickstart V39.106'da Forbid

Ancak, örneğin, kickstart V39.106 yazılım aracılığıyla yüklenmişse ve
ROM'da değilse, JMP tablosu kick'in yüklendiği RAM adreslerine işaret edecektir.
 Bu nedenle, kickstart'a ASLA bu şekilde erişmeyin,
 aksi takdirde ürününüz sadece sizin bilgisayarınızda çalışacaktır.
Bu örnekle, JMP tablolarını
ROM'daki adresi bizim adresimizle değiştirerek
değiştirebileceğimizi ve böylece değiştirilmiş rutinlerimizi çalıştırabileceğimizi anlayabilirsiniz. İşletim sistemini değiştiren programlar, örneğin
pencerelere bir gadget ekleyen veya
workbench'e seçenekler ekleyen yardımcı programlar, bu şekilde çalışır.
İşletim sisteminin bu “İLGİLİLİĞİ” nedeniyle
İşletim sisteminin bu “İLGİLİLİĞİ” nedeniyle ASLA ROM'a atlamamalısınız.
 Amiga işletim sisteminin tek sabit adresi $0004'tür,
 yani EXECBASE, ofsetlerin yapılacağı adresi içerir.
Bu nedenle, işletim sistemiyle uğraşmak istiyorsanız, her zaman
standart talimatları izleyin. Ve uğraşmak istemeseniz bile!
Bu tür hatalar o kadar ölümcüldür ki, Amiga500 Kick1.2 üzerinde yapılmış birçok eski demo,
 Amiga500 Kick1.3 veya üstü sürümlerde,
kickstart 1.2 yazılımı yüklenerek bile çalışmaz.

Biraz daha az ciddi olan diğer adres hataları,
fast ram'in $c00000'da olduğunu varsayar.
Amiga orijinal olarak 512k CHIP RAM'e sahipti, daha sonra
1MB'a çıkaran dahili genişletme yaygınlaştı ve 512k ek
hızlı RAM'in $c00000 ile $c80000 arasında olduğu biliniyor.
O zamanlar demolar ve oyunlar da
ve o dönemde programların büyük çoğunluğu mutlak adreslere sahip olduğundan, kodlayıcılar
programı fast ram'de, $c00000 ile $c80000 arasındaki konumlarda
derlemeyi ve grafikleri ve müziği $00000 ile $80000 arasındaki chip ram'e yüklemeyi düşündüler.
$c00000 ile $c80000 arasında ve grafik ve müziği chip ram'e,
$00000 ile $80000 arasında yüklemeyi düşündüler. Böylece program,
mutlak adresler $c00000'da açılmasının yanı sıra, o bölgeye ayrılmış komutlara sahipti
:

...
MOVE.L    #$c23b40,d0
jsr    $c32100
...

Bu demolar veya oyunlar, klasik kartla dahili olarak genişletilmiş A500'lerde çalışıyordu,
 ancak yine 1 MB belleğe sahip A500 plus piyasaya çıktığında
ama sadece CHIP ile donatılmış A500 plus piyasaya çıktığında, tüm bu programlar
kullanılamaz hale geldi. Bunun nedeni, 1MB chip ile belleğin
şu şekilde düzenlenmiş olmasıdır: ilk 512k her zaman $00000 ile
$80000 arasında bulunur, ancak ikinci 512k $80000 ile $100000 arasında yer alır!!!
Bu nedenle, “JSR $c32100” hiçbir yere götürmez, ancak
ekranda muhteşem bir patlama ile birlikte kesinlikle bir çökmeye yol açar.
Bunun ardından, sonraki oyunlar ve demolar, ilk 512k'dan sonraki belleği kullanmak için
farklı yöntemler kullandılar.
Bunlardan biri, ORG ve LOAD komutlarını ve otomatik önyükleme programlarını unutarak
, ORG ve LOAD komutlarını ve hatta otomatik önyükleme programlarını da terk etmekti,
 çünkü bunlar kendi yükleyicileriyle mutlaka
mutlak adreslere yerleştirilmelidir.
Bir yandan, DOS aracılığıyla yüklenebilen birçok sonraki demo/oyun
SECTIONS aracılığıyla %100 yeniden konumlandırılabilir hale geldi, sabit adreslere yüklenen parçalar olmadan
, diğerleri ise belleğin son baytına kadar kullanmak için otomatik başlatma ve sabit adreslerden vazgeçmek istemediler.
 Sonuncular bu
sorunu birkaç şekilde çözdüler: Birincisi, iki ana programı
birleştirerek, birini ORG ve LOAD ile $c00000 adresine sabitlemek,
bilgisayarın yarım megabayt CHIP ve yarım megabayt FAST'a sahip olduğu tespit edilirse, diğerini
$80000 adresine sabitlemek ve bilgisayarın
1MB veya daha fazla CHIP'e sahip olması durumunda yüklemek. Bu şekilde, önyükleme sırasında bir rutin hangi
durumda olduğumuzu kontrol eder ve ana programlardan birini doğru adrese
yükler, grafik ve ses gibi veriler ise daha sonra ana program tarafından yüklenir.
 Bu sistemin dezavantajı, ana programın iki sürümü için disk alanında yer kaplamasıdır
.
Daha “yetenekli” olanlar ise küçük bir işletim sistemi programladılar.
Bu sistem, önyükleme sırasında bilgisayarda hangi bellek segmentlerinin mevcut olduğunu kaydeder
ve kendi tahsis rutinleri aracılığıyla programın çeşitli bölümlerini
FAST RAM'in bulunduğu adrese yeniden tahsis eder.
Bu, AUTOBOOT programı yapmak için kesinlikle en iyi yoldur, ancak
oldukça zordur ve avantajları şunlardır: 
A4000'e iki ana programdan oluşan bir demo veya oyun yüklediğinizi düşünün:
Önyükleme sırasında program belleği tanır ve
$c00000 adresinde bellek olmadığını fark edince, kodu $80000 adresindeki CHIP RAM'e yükler.
Aynı demo/oyun ise mini
işletim sistemi ile yüklenmek üzere değiştirilir: Önyükleme sırasında, iki
bellek bloğu olduğunu algılar: $000000 ile $200000 arasındaki CHIP ve $7c00000 ile
$7ffffff arasındaki FAST. Sonuç olarak, tüm kod parçalarını FAST RAM'e yeniden yerleştirir ve
grafik ve sesi CHIP RAM'e yükler. Bilindiği gibi,
FAST RAM'deki kodun CHIP RAM'dekinden çok daha hızlıdır, özellikle
68040 gibi TURBO işlemcilerde, bu nedenle demo veya oyun, kod FAST'a yeniden yerleştirildiğinde çok daha
hızlı çalışacaktır.
Ancak, kendi işletim sistemlerini kullananların
68040'ın ortaya çıkmasıyla veya
hatta basit 68020'nin ortaya çıkmasıyla demolarının çöktüğünü gördükleri unutulmamalıdır, çünkü Motorola
tam uyumluluğu SADECE kullanıcı modunda garanti eder, denetleyici modunda değil
: aslında 68040'ın denetleyici modu için kendi komutları vardır
ve 68060 da sadece kullanıcı modunda %100 uyumludur...
Geleceğin işlemcileri veya bilgisayarları düşünün, belki 680x0'ı taklit edecekler... ASLA SÜPERVİZÖRE GİRMEYİN VE KENDİNİZE İŞLETİM SİSTEMLERİ YAPMAYIN.
Bir fikir vermek için, Sanity'nin güzel WOC 92 demosu,
işletim sistemi nedeniyle 68040'ta çalışmıyor...
... ve aynı şey
bir arkadaşımın İtalyanca demosu IT CAN'T BE DONE'da da oldu, ve bu
son durumda hatayı bulan bendim: süpervizör rutini!!!
Sonuç olarak, SECTIONS'ı çalıştırılabilir kod yapmak için kullanmanın daha kolay ve GÜVENLİ olduğunu düşünüyorum,
 çünkü bunu 
HardDisk'e yükleyebilme avantajı da var ve önümüzdeki yıllarda Amiga'nın
MSDOS ile rekabet etmek zorunda kalacağı kesin, bununla demek istediğim
BASE bilgisayarların HardDisk ve FAST RAM'e sahip olması gerektiği, aksi takdirde
disketten autoboot ile yüklenen 1MB'lık oyunları izleyenlerin sayısı azalacak
ve işlemcinin hızından bile yararlanamayacaklar çünkü
kodu FAST RAM'e yüklemeyecekler!!

Şimdiye kadar yeniden konumlandırılabilir kod yazmanın daha iyi olduğunu gösterdim, ama
dos'tan yüklenebilir bir yürütülebilir dosya için mutlak adresler kullanırsak ne olur?
A500+'nın 1 MB CHIP ile piyasaya sürülmesi,
“KARIŞIK” kodlu, yani
“SECTION” ile oluşturulmuş, ancak Section BSS veya AllocMem ile ayrılmamış,
grafikler için tamponlar kullanılarak
keyfi olarak belirlenmiş

lea    $30000,a0    ; Bitplane tampon adresi
bsr.s    PrintText    ; Metni $30000 adresine yazdır

Bu durumda yeniden konumlandırılamayan kod değil, grafik tamponudur.
 Sonuç olarak, bitplane'leri copperlist'te işaretleme rutini de yoktur,
 çünkü programcı doğrudan $30000 değerini koyar
(KORKUNÇ!!!)

...
dc.w	$e0,$0003    ; bpl0pth
dc.w    $e2,$0000    ; bpl0ptl
...

Eski bilgisayarlarda, 512k CHIP ve 512k
FAST olanlarda ne olduğunu görelim: intro'nun 20k'lık bir CODE bölümü ve 40k'lık bir CHIP
bölümü olduğunu varsayarsak (karakterlerin FONT'unu ve müziği içeren), ilk bölüm
FAST'a, ikincisi CHIP'e yüklenir, bu nedenle
$30000 konumuna ulaşılmaz, ancak diyelim ki $2a000 konumuna ulaşılır. Bu durumda her şey çalışır,
ancak bu intro DOS tarafından yüklenen ilk şey olmalıdır.
Sadece 1 MB veya 2 MB çipe sahip daha yeni makinelerde, FAST MEM olmadığı için
hem CODE bölümü hem de diğer bölüm CHIP'e yüklenir
böylece kodun (veya müziğin, grafiğin vb.) son Kb'leri
$30000 adresinin ötesinde bulunur. Rutinin kodun üzerine karakterleri yazdırdığında ne güzel bir CRASH olacağını
hayal edin!
A500+ ve a600'ün piyasaya çıkmasıyla, “hafif” kodlayıcıların çaresizliği,
 bu bilgisayarlarda listeleri düzeltememeleriydi,
çünkü ASMONE'nin kendisi CHIP RAM'e yükleniyordu ve
mutlak tampon olarak kullanılan $30000 veya $40000 konumlarını aşıyordu, bu nedenle JMP'de
listesi (ŞANSA) çalışabilirdi, ancak çıkışta ASMONE
rutinler tarafından DELİNMİŞ olarak bulunurdu ve ÇÖKME kaçınılmazdı.
Bu, intro üreticilerine de
güzel bir yeniden konumlandırılabilir tampon oluşturmaları gerektiğini öğretti:

SECTION    BufferOK,BSS_C

ds.b    10000

Adreslerle ilgili hatalar serisini tamamlamak için,
mantıksız eylemler olduğu için yapmanızın zor olduğu hataları şimdi aktarıyorum, ancak güvenlik açısından şunu bilmeniz iyi olur:
- Bazı kurnaz kodlayıcılar bazen adreslerin yüksek baytını

mesaj yazmak veya sadece yazmak için kullanmışlardır.
- 16 bitlik CPU'lar (68000 veya 68010 gibi) bir adresin yüksek baytını yok sayar, bu nedenle şunu yapmamalısınız:
68000 veya 68010 gibi 16 bitlik CPU'ların bir adresin üst baytını yok saydığını bilmeniz gerekir, bu nedenle:
JSR    $00005a00

JSR    $00120d00
JSR    $00c152b0
JSR    $C0005a00
JSR    $00013cd0

şunu yazmakla eşdeğerdir

JSR    $C0005a00
JSR    $DE120d00
JSR    $FEc152b0
JSR    $DE013cd0

İlk baytlarda açıkça “C0DE-FEDE” yazıyor, bu
yıllar önce Emilio Fede kodlayıcı tarafından bırakılmış bir mesaj olabilir, o
bu şekilde imzalanıyordu. Onaltılık sayılarla birçok kelime oluşturulabileceğini
unutmayın (A, B, C, D, E, F ve 0 “O” olarak), örneğin:
FEDE, AFA, ABAC0, FACCE, F0CA, CACCA, CADE, C0DE, ...
Bu kurnazlar, subrutin serilerindeki adreslerin yüksek baytlarında veya diğer
yerlerde, disasamble edenlerin hakaretleri bile okuyabileceği
yerlere, bütün mesajlar, şiirler, aşk mektupları bırakıyorlardı!
Bu oyun çok kısa sürdü, neyse ki, ama
onların intro/demo'ları 32 bit işlemcilerde çalışmıyor, çünkü bu işlemcilerde
maksimum adresleme artmıştır, bu nedenle JSR gerçekten
o garip konumları arar. Bu arada, eski A500'lerin FAST RAM'inin
$00c00000'da, A4000'inkinin ise $07c00000'da,
yani 68000'in adresleme aralığı dışında olduğunu fark etmişsinizdir.

Adres hatalarının sonuncusu ve bir önceki kadar sıra dışı olmayan
hatası, 512k CHIP bellekte görülür ve adres veriyolunda dört kez “tekrarlanır”,
 yani bu
$00000 ile $7ffff arasında olmasına rağmen 
$80000-$FFFFF, veya $100000-$17ffff, veya $180000-$1FFFFF adreslerinde de erişilebilir.
Pratikte, $80000 bayt (512k), veriyolunun $200000 (2MB) kapasitesinin 1/4'üdür
ve OCS (sadece 512k
CHIP adresleyebilen eski Amiga'lar, geri kalanı FAST), her CHIP bellek baytı dört
farklı adres üzerinden erişilebilir ve birbirinden 512kb uzaklıktadır.
Bu özellik, ECS ve AGA makinelerde, yani
1MB veya daha fazla belleği adresleyebilen makinelerde kaybolmuştur.
Bir örnek verelim: $0 konumuna $12345678 değerini yazarsak,
bu değeri $0+$80000, $0+$80000*2,
$0+$80000*3 ve $0+$80000*4 konumlarından da “geri alabiliriz”. Bir listeye bakalım:

move.l #$12345678,$0    ; bu değeri ilk 4 bayta koyalım

move.l    $80000,d0    ; d0 = $12345678
move.l    $100000,d1    ; d1 = $12345678
move.l    $180000,d2    ; d2 = $12345678

$80000,$100000 ve $180000'den okuduğumuzda, sanki $0'dan okumuş gibi oluruz!!!!
Ne yazık ki, bazı aptallar bu garip özelliği kendi rutinlerinde kullanmışlar
ve bu da a500+ ve a600'lerin çeşitli işlevlerinde hatalara neden oluyor.
 İşlemcinin her zaman
68000 olmasına rağmen, hata ROM'daki kickstart 1.3 ile de ortaya çıkmaktadır.

Artık, geçmişte yapılan adreslerle ilgili tüm hataları biliyorsunuz.
 Bunları yapmamaya ve yenilerini icat etmemeye
dikkat edin!!!!

-    -    -    -    -    -    -    -    -

8) 68010 ve üstü işlemcilerde SR ile ilgili sorunlar:
68010 ve üstü işlemcilerde 68000 koduna göre en sık görülen uyumsuzluk sorunlarından biri
“MOVE SR,dest” komutlarıdır
örneğin “MOVE SR,d0” veya “MOVE SR,$1234” veya “MOVE SR,LABEL”.
Aslında, 68000 tabanlı bu komutlar, diğer komutlar gibi
kullanıcı modunda (USER MODE) normal olarak kullanılabilir: emülatörler (PC Transformer, C64 Emulator vb.) gibi programlar
68010+ üzerinde çalışmaz
çünkü bu işlemi KULLANICI modunda gerçekleştirirler ve bu, 68010+'da
artık mümkün değildir ve “Privilege Violation” hatasına neden olur.
Ayrıca, birçok oyun ve demo, sistemi kontrol altına alan rutinlerin başlangıcında bu komutun
bulunması nedeniyle takılır.
Motorola, 68010 ve sonraki işlemcilere
henüz piyasada olmayan makineler için yeni işletim sistemlerinin çalışmasını simüle etme
olanağı eklemeye karar verdi. Bu,
MOVE SR,dest komutunun ayrıcalıklı, yani yalnızca
denetleyici modunda çalıştırılabilir hale getirilmesini gerektirdi. Aksi takdirde sonuç “Privilege Violation” hatası olur
SR'ye kullanıcı modunda erişmek için Motorola tasarımcıları
68010 işlemcilerden itibaren MOVE SR,dest yerine kullanılacak MOVE CCR,dest komutunu eklediler,
 ancak bu komut 68000'de mevcut değildi, bu nedenle
Amiga'nın 68000 için bazı programları
kullanıcı modunda MOVE SR,dest komutunu kullanarak yazılmıştır ve şimdi bunu, bir
oyun veya demo, A1200/A3000/A4000 veya hızlandırılmış A2000'de önyükleme sırasında
MEDITATION veya SOFTWARE FAILURE gibi uğursuz bir GURU mesajıyla takıldığında
Aslında “hata” Motorola'ya aittir, çünkü MOVE SR,dest komutunu kullanıcı modunda (USER) güvenle kullananlar,
 bunun yalnızca süpervizör modunda
(işlemcinin bir TRAP veya EXCEPTION komutundan sonra) çalışacak bir komut olacağını
beklemiyorlardı.
Her neyse, önemli olan bunu bilmektir ve artık bu soruna
karşılaşmayacağımızdan emin olabiliriz. Bunu,
MOVE SR,dest komutunu her zaman SÜPERVİZÖR modunda, yani bir TRAP'tan sonra veya bir
INTERRUPT'ta vb. çalıştırmayı hatırlayarak yapabilirsiniz. Bu şekilde komut tüm
işlemcilerde çalışacaktır. Başka bir çözüm, makinede hangi
işlemcinin olduğunu kontrol etmek ve uygun kodu çalıştırmak olabilir, yani
68000'de “MOVE SR,dest” veya 68020'de “MOVE CCR,dest” komutunu, her ikisini de
SUPERVISOR modunda çalıştırmak zorunda kalmamak için USER modunda çalıştırmak olabilir, ancak
en hızlı ve mantıklı çözümün her zaman
“MOVE SR,dest” komutunu SUPERVISOR modunda çalıştırmak olduğunu düşünüyorum. Özetle:

CPU        KULLANICI modu (USER)    SÜPERVİZÖR modu

68000        MOVE SR,dest        MOVE SR,dest
68010/20/30/40	MOVE CCR,dest        MOVE SR,dest

Eski “MOVE SR,dest” komutunu her zaman süpervizör modunda çalıştırmanın daha uygun olduğunu kabul edeceksiniz
,
 bu zaman ve rutinlerden tasarruf sağlar.
Bunun yerine, programladığınız oyun/program/demo sadece
68010+ işlemcilere yönelikse, örneğin demo sadece AGA ise, yeni
MOVE CCR,dest komutunu kullanıcı modunda kullanabilirsiniz, çünkü 68020+ üzerinde çalışıyorsunuz, ancak
bu komutun 68000 üzerinde mevcut olmadığını ve bu nedenle
68000 tabanlı assembler'lar tarafından, bu TRASH'M-One gibi 68000 tabanlı assemblerlar tarafından derlenmez; bu tür 
68010+ komutlarını derlemek için TFA ASMONE veya DEVPAC 3 kullanmanız gerekir.
Ayrıca, bu komutu ASLA KULLANMAMANIZI ve
ASLA SÜPERVİZÖR MODUNA GİRMEMENİZİ tavsiye ederim... Ne için? Risk almak için mi?
Bu tür bir hata meydana geldiğinde, işletim sisteminin SOFTWARE FAILURE numarası
#80000008'dir, bunu tanımak zor değildir.
Ancak, demo veya oyun programlamak için SR kaydında işlem yapmak
temel bir önemi yoktur, bu nedenle bu kayda ASLA erişmemenizi
bu kayda erişmemenizi şiddetle tavsiye ederim, çünkü bitleri işlemciden işlemciye farklıdır
ve uyumsuzluk sorunlarına neden olması çok kolaydır.

-    -    -    -    -    -    -    -    -

9) 68010 ile, gördüğümüz MOVE CCR,SR komutuna ek olarak
başka yenilikler de getirilmiştir ve bunlar bilinmezse uyumsuzluk hatalarına
neden olabilir. Bunlar VBR, yani VECTOR BASE REGISTER,
yani “vektör temel kaydı” anlamına gelir. Bu
kayıt, kesme dersinde görmüştük, aslında bir kesme veya tuzak (TRAP #xx komutu)
meydana geldiğinde, işlemci
USER modunda çalıştırdığı programın okumasını DURDURUR,
SUPERVISOR moduna geçer ve
belirli VEKTÖR'de bulduğu adrese ait rutini çalıştırır. Bu, kesme seviyelerinden biri
veya TRAP'lardan biri vb. olabilir.
Yeni işlemcilerde, 68000'de işlevi olmayan vektörlerin kullanılmasına ek olarak
(örneğin, $18 ve $1c'ye bakın),
bu vektörlerin BAZINI değiştirme olanağı da eklenmiştir.
68000'de VBLANC kesmesinin her zaman
$6c adresinde olduğundan emin olabiliriz, ancak 68010 veya üstü işlemcilerde bundan emin olamayız.
Bunun nedeni, bu OFFSET'lerin tabanının artık $000000 olmayabileceğidir.
Aslında, denetleyicide “MOVEC d0,VBR” komutunu çalıştırmak yeterlidir, her şey değişir.
Tabii ki, önyükleme sırasında VBR sıfırlanır, bu nedenle vektörler
hepsi 68000 ile aynı yerdedir. AmigaDos'un SetPatch'i
VBR'yi, normalde FAST RAM'e taşır ve vektörlerin adreslerini
yeni adrese kopyalar. Ya da “taşıma” işlemi başka yardımcı programlar tarafından yapılır.
Dolayısıyla, WorkBench bir
68010+ bilgisayarında yüklendiğinde, VBR'nin sıfır olmaması çok muhtemeldir, bu nedenle eski
demolar ve oyunlar (sadece eski olanlar değil!), Shell veya
WorkBench'ten yüklendiğinde, genellikle müzik çalmaz veya takılır, çünkü
kesme rutinlerini $6c'ye koyarlar, oysa
VBR+$6c'ye koymaları gerekir. Bu nedenle ASLA şöyle bir şey yapmamalısınız:

MOVE.L    #IntRoutine,$6c

Öncelikle, bunu şu şekilde “optimize” edebilirdiniz:

MOVE.L    #IntRoutine,$6c.w

Ancak daha da önemlisi, bu sadece önyükleme sırasında yüklendiğinde, SetPatch veya diğer yardımcı programları çalıştırmadan önce
işe yarar.
Bu sorunu gidermek için, 68000 veya 68010+ olup olmadığını kontrol eden ve
ikincisi durumunda VBR değerini okuyarak gerekli ofsetleri gerçekleştiren birkaç satır kod yeterlidir.
Programın sonunda, eski kesmeyi geri yüklemek için aynı şeyi yapmayı unutmayın.
Programın sonunda, eski kesmeyi geri yüklemek için aynı işlemi yapmayı unutmayın.
Bu önlem, kursun
gelişmiş listelerinde kullanılan startup2.s dosyasında bulunmaktadır.
MOVEC VBR,A1 komutunun 68010+ olduğu için tüm assembler'lar (bu ASMONE dahil) tarafından derlenmediğinden, bunu MOVEC VBR,A1 komutunun 68010+ olduğu için
tüm assembler'lar (bu ASMONE dahil) tarafından derlenmediğini
unutmayın, bu nedenle onu onaltılık eşdeğeriyle yazmak daha iyidir.
Aslında, RTS yerine “dc.w $4e75” yazmanıza engel olan hiçbir şey yoktur!

-    -    -    -    -    -    -    -    -

10)Şimdi, 68020 ve sonraki işlemcilerde INSTRUCTION CACHE'nin
getirilmesiyle ortaya çıkan programlama hatalarını görelim.
“Ortaya çıkan” derken, bu hataların korkunç bir sistem çökmesine
yol açtığını kastediyorum. 
Neyse ki bu hataların çoğu, yardımcı yazılımlarla CACHE'leri devre dışı bırakarak
çözülebilir.
CACHE'lerin ne olduğunu kısaca görelim: bunlar,
CHIP veya FAST ram'in aksine, ulaşmak için otoBUS'tan geçmek gereken işlemcinin DIŞINDA değil, İÇİNDE bulunan çok hızlı belleklerdir.
Daha önce veri ve adres KAYITLARINI görmüştük, bunlar
işlemcinin içindeki LONG bellekten başka bir şey değildir ve bunları okuyup
yazabiliriz. CACHE'ler de benzer bellek bankalarıdır, ancak
komutlarla okuyup yazamayız, bunlar
işlemci tarafından özel bir donanım aracılığıyla otomatik olarak okunur ve yazılır.
Cache'lerin amacı, LOOP'ları, yani
döngüsel olarak birçok kez gerçekleştirilen rutinleri hızlandırmaktır. Öncelikle, 68020 ve 68030'da
INSTRUCTION cache'in 256 bayt olduğunu, 68040'da ise 4096 bayt olduğunu belirtmeliyim.
68060'da 8192 olduğunu sanıyorum, gelecekte kim bilir...
Peki, şu döngüyü hayal edin:

...
MOVEQ    #100,d0
Döngü1:
move.w    LABEL1(PC),d2
add.w    d3,d2
....
diğer komutlar
....
DBRA    d0,loop1
...

İşlemci hızını artırsanız bile, bu döngü
her döngüde “loop1:” etiketi ile “DBRA d0,loop1” arasındaki komutların okunmasını gerektirir
ve RAM'den okuma, özellikle CHIP RAM ise, çok yavaştır.
Motorola tasarımcıları bu nedenle şu hileyi buldular: “Son
yürütülen 256 baytı otomatik olarak önbelleğe
koysak nasıl olur? Böylece, 256 bayttan daha küçük bir döngü ortaya çıktığında,
 döngünün tüm komutları önbellekte olur ve
işlemci bunları RAM'den değil, hızlı önbellekten
okuyabilir!”. Instruction CACHE kabaca böyle çalışır.
Önceki döngü RAM'den sadece ilk kez okunur,
DBRA'ya ulaşıldığında işlemci “fark eder” ki Döngü 1: CACHE'de her zaman bulunacak kadar
yakındır ve kalan 99 kez
komut okuma süresi, CHIP/FAST RAM'den değil CACHE'den
yürütülerek önemli ölçüde azalır.

Şimdi soracaksınız: peki o zaman ne gibi hatalar ortaya çıkabilir?????
En yaygın olanı, belirli rutinleri
68000 tabanının belirli sayıda
“boş” döngü yapmak için gereken süreye göre “zamanlamış” olanların başına gelir (şimdi atılacak bir listeyle karşı karşıya kalırlar).
“Kurnaz”ların, örneğin disk sürücüsünün kafalarının hareket etmesini beklemek,
bir müziği zamanlamak veya başka şeyler için nasıl “zaman kaybettiklerini” görelim:
MOVE.W    #2500,d0

Bekleme:
dbra    d0,Bekleme
...

Bu beceriksiz ve yaklaşık programlama örnekleri
ne yazık ki, track loaders ve müzik çalan rutinlerde
çok sık görülür. Kursta bulunan “music.s” rutini
başlangıçta bu “boş döngülerden” birkaç tane içeriyordu, ben de bunları
güvenilir “zaman kaybettiren” rutinlerle “zaman kaybettiren” güvenilir rutinlerle değiştirdim, şimdi bunları göreceğiz.
Noisetracker/protracker için replay rutinleriniz varsa, neredeyse
kesinlikle bu tür aptal döngüler bulacaksınız, bunlar
dinlerken bazı notaların kaybolmasına neden olur.
Bir not: Gerardo Proia'nın ders listelerinde de bu tür aptal döngüler var,
 umarım bunları örnek almamışsınızdır!
Bulduğunuz listelerde bu lanet döngüleri arayın
ve bulursanız, o iğrenç kaynakları atın veya
zamanlama için CIA veya VBLANK kullanan rutinlerle değiştirin.
Boş bir döngünün çalışma prensibi, işlemcinin
bu durumda 2500 kez DBRA komutunu okuması,
d0'dan #1'i çıkarması ve “Bekle:” komutuna geri atlamasıdır.
Önbellek etkin bir bilgisayarda 50000 kez bile okunabilir,
ancak CACHE'ye düştüğü için DBRA yine de bir saniyenin kesirinde
yürütülür, sonuç olarak sürücü parçaları okumaz ve müzik
notaları “keser”. Üstelik 68010 da, doğrusu, bunun gibi küçük DBRA döngülerini hızlandırmak için
3 kelimelik küçük bir CACHE'ye sahiptir,
bu nedenle bu döngüler sadece 68000'de 7Mhz'de “çalışır”.
MAI dersinde boş döngülerle zamanlama öğretilmediğinden,
 umarım kimse kendi başına bu tür *SAÇMALIKLAR* yapmaya başlamaz.
Genel olarak, 680x0 CPU'nun komutları yürütme hızını referans almamalı,
 çünkü bu işlemciden işlemciye ve hatta okunan
bellek türüne göre değişir.
 
Zamanlama açısından tek kesin olan şey, VBLANK'IN VİDEO YENİLEME SÜRÜCÜSÜDÜR, bu standart PAL
standartlarında her zaman saniyede 50 kez çalışır ve CIA'nın zamanlayıcılarıdır, bu
tüm Amiga'larda aynı olan bir çiptir, bu nedenle 1 milisaniye bir
A500'de de A4000'de de aynıdır. Blitter hızına da güvenmeyin, çünkü bu hız bilgisayarın işlemcisine göre değişir
.

Trackloader'ları, harici çevre birimleri için sinyalleri
veya paralel porta bağlı robot kolları zamanlamak için

Öncelikle VBLANK ile birkaç “raster satırı” beklemeyi görelim:

LEA    $DFF000,A5        ; a5'teki özel kayıt tabanı
PerdiTempo:
MOVE.w    #LINEE-1,D1    ; BEKLENECEK SATIR SAYISI (304=1 kare)
VBWAITY:
MOVE.B    6(A5),D0    ; $dff006, VHPOSR.
WBLAN1:
CMP.B    6(A5),D0    ; VHPOSR
BEQ.S    WBLAN1
WBLAN2:
DBRA    D1,VBWAITY

CIA zamanlayıcılarını başka rutinler için kullanmıyorsanız, bunları kullanabilirsiniz
ancak işletim sistemi tarafından kullanıldığından mümkün olduğunca az dokunmanız daha iyidir.
 Ders 11'de bu konuyla ilgili kaynaklar bulabilirsiniz.
CIA zamanlayıcılarını kullanırken, işletim sisteminin de bazı amaçlar için bunları kullandığını
unutmayın: (CIAB kullanmak daha iyidir!)

CIAA, zamanlayıcı A    Klavye ile arayüz oluşturmak için kullanılır

CIAA, zamanlayıcı B    Exec tarafından görev alışverişi vb. için kullanılır

CIAA, TOD        Timer.device tarafından kullanılan 50/60 Hz zamanlayıcı

* CIAB, zamanlayıcı A    Kullanılmaz, programlar için kullanılabilir

* CIAB, zamanlayıcı B    Kullanılmaz, programlar için kullanılabilir

CIAB, TOD        Elektronik fırçanın konumlarını takip etmek için graphics.library tarafından kullanılır.

İşletim sistemi için de gerekli olan zamanlayıcıları kullanmanız gerekiyorsa, bunu yalnızca
çoklu görev ve sistem kesintilerini devre dışı bıraktıysanız, yani
sistemin tam kontrolünü ele geçirdiyseniz yapın. Her halükarda, CIA'yı kullanmak vblank'tan daha tehlikelidir, çünkü üretimimizden çıktığımızda
bir zamanlayıcıyı bozarsak kim bilir ne olabilir.
-

-        -        -        -

Zamanlama döngüsü sorununa ek olarak,
başka bir programlama hatasından kaynaklanan bir sorun daha vardır, ancak bu sorun günümüzde
neyse ki neredeyse ortadan kalkmıştır. Bu, efsanevi ve gizemli
“OTOMATİK DEĞİŞTİREN” koddur: Bu tür kod, kendisini değiştirdiği için
otomatik değiştiren olarak adlandırılır. Aslında, verileri değiştirmenin yanı sıra,yürütme sırasında kendi talimatlarını da değiştiren
“yaratıklar” yapmak mümkündür.
Bu tür programlama ne yazık ki eski çağlardan beri kullanılmaktadır,
muhtemelen daha hızlı veya
daha güçlü kod yazmanın bir yolu gibi göründüğü için. Aslında, otomatik değiştirme koduyla yapılan
%100 normal kodla yeniden yazılabilir ve bazen 
hız kazanılabilir. Bu nedenle, deneme amaçlı olmadıkça bu tür kod yazmayı unutun
,
 çünkü bu kod
68020/30/40/60'ın aktif CACHE'leri ile çalışmaz. A1200'e sahip olanlar,
 sadece cache nedeniyle çalışmayan oyun ve demo sayısının
ne kadar fazla olduğunu Aslında, eski yazılımdaki
hataların çoğunun bu türden olduğunu düşünüyorum. Bir oyun
veya demo'nun otomatik değiştirme koduna sahip olup olmadığını anlamak için, önbelleği kaldırarak (eski kick'leri yüklemeden) çalışıp çalışmadığını denemek
ve ardından önbelleği etkinleştirerek tekrar denemek yeterlidir
. Bu noktada çalışmazsa, sorunun sadece
etkin önbelleklerden kaynaklandığı açıktır ve önbellekler sadece iki tür
hata neden olur: daha önce gördüğümüz DBRA gecikme döngülerinin iptal edilmesi
ve otomatik değiştirme kodundan kaynaklanan hatalar.
Otomatik değiştirme kodu içeren bir liste şöyle görünebilir:

...
divu.w    #3,d0
MYLABEL:
moveq    #0,d0
...

Bu, bellekte şu şekilde derlenir:

...
dc.l    $80FC0003    ; DIVU.W #$0003,D0
MYLABEL:
dc.w    $7000        ; MOVEQ     #$00,D0
...

Şu ana kadar bellekteki verileri değiştirdik, copperlist'lerde
özel $dffXXX kayıtlarına değerler koyduk, ancak hiçbir zaman bir komutun İÇİNDE
hareket etmedik!!! Bunun nedeni, bunun UYumsuz bir şey olmasıdır.
(Aslında, Lezione11.txt dosyasında DOS yükleme listesinin sonunda bir kesmenin sonunda bir JMP değiştirdik,
 ancak bu “yararlı” tek durumdur!).
Listenin ilerleyen kısımlarında şu komutun olduğunu düşünün:

...
move.w    #5,MYLABEL-2
...

Ne olur? MYLABEL etiketinden önceki kelime,
DIVU #3,d0'daki $0003'tür ve $0005 olur, dolayısıyla DIVU #3,d0, DIVU #5,d0 olur!!!
Aynı şekilde diğer tüm komutlar da değiştirilebilir. Başka bir
yol olarak şöyle yazılabilir:

...
divu.w    #3,d0
MYLABEL:    EQU    *-2
moveq    #0,d0
...

Şimdi DIVU numarasını değiştirmek için bir MOVE.W #xxxx,MYLABEL yeterlidir, çünkü
EQU *-2 ile MYLABEL, -2 etiketiyle eşleştirilir.
Yıldız işareti “bu nokta” olarak çevrilebilir, bu nedenle “*-2”
“bu nokta eksi 2 bayt” anlamına gelir. Şimdi, otomatik değiştirme kodlu bir
listede şu durumu ele alalım:

...
divu.w    #0,d0    ; istenen sayıya değiştirilecek
MYLABEL:
EQU    *-2
...

ICACHE etkin olduğunda ne olacağını hayal edin: önbelleğe
bellekteki haliyle, yani DIVU.W #0,d0 komutu girer, muhtemelen
değiştirilmeden önce, bu nedenle şu komut çalıştırıldığında:

move.w    #5,MYLABEL

komutu çalıştırıldığında, DIVU komutu RAM'de değiştirilir, ancak CACHE'de değiştirilmez! Aslında bu
komut olduğu gibi, yani DIVU.W #0,d0 olarak çalıştırılır ve bu da
SIFIRLA BÖLME nedeniyle sistemin çökmesine neden olur!

divu.w    #0,d0    ; “0” değeri, bu
MYLABEL:        ; komut çalıştırılmadan önce değiştirilecektir, ancak ICACHE etkin olduğundan
EQU    *-2    ; bu komut önbellekten olduğu gibi okunacaktır
; ve güzel bir ZERO BÖLÜMÜ hatası
; eğlencemizi sonlandıracaktır.
Aynı şekilde bir:

JMP    0    ; adres bir hareketle bu noktaya yerleştirilecektir,
MYLABEL:        ; ancak önbellek sayesinde güzel bir JUMP a 0!! (guru!!)
EQU    *-6    ; (EQU *-4, EQU *-8, adresin büyüklüğüne
veya aptalca “değişikliğe” bağlı olarak.


Bazı durumlarda, gerçek bir GURU yerine, rutinlerin
yanlış çalışması gibi sorunlar ortaya çıkar, örneğin aşağıdaki türden bir döngü:

...
MOVE.W    #100,d0
Döngü1:
...
divu.w    #2,d2
MYLABEL:
EQU    *-2
....
addq.w    #1,MYLABEL
DBRA    d0,loop1
...

Sistem çökmesi meydana gelmez, ancak divu.w her döngüde
DIVU.W #3,d2, DIVU.W #4,d2 vb. olarak değişmesi gerekirken,
her zaman DIVU.W #2,d2 olarak kalır (RAM'den değil CACHE'den okunur).
Örneğin, bu bir 3D katı nesneyi hareket ettiren bir rutin olsaydı,
katı nesnenin hareketsiz kalacağı veya hiç görüntülenmeyeceği kesin.

- NASIL YAPMALIYDIK:

Aynı şey, mutlak bir değer yerine bir LABEL veya bir
REGISTRO ile bölerek de yapılabilirdi (divu.w LABEL(PC),d2 yerine
divu.w #xxx,d2), ve daha sonra cache ile uyumluluğu koruyarak ve hız kaybı olmadan
etiket üzerinde ekleme yapılabilirdi.
Yani APTAL OLMAYIN: otomatik olarak kendini değiştiren kod yazmak övünecek bir şey değildir
çünkü ne zor ne de yararlıdır, aksine uyumsuzdur.
Otomatik olarak kendini değiştiren kod içeren eski listeleri kullanmayın.
Önbelleği devre dışı bırakmanın dışında, otomatik olarak kendini değiştiren kodu çalıştırmanın bir yolu daha vardır
: SIFIRLAYABİLİRSİNİZ, yani
ÖZELLEŞTİRMEYİN, yani özel bir komutla önbelleği TEMİZLEYİN, böylece
eski komut ÖNBELLEKTEN silinir ve işlemci
RAM'den değiştirilen komutu okumak zorunda kalır.
“Bakteriyel” veya yapay zeka programları veya
kim bilir ne tür programlar yapmak istiyorsanız, otomatik olarak değiştirilen, sadece
“BSR.w CACHECLR” eklemeniz yeterlidir.
Kickstart 2.0+'da ExecLib'de özel bir işlev vardır:

ClearMyCache:
movem.l    d0-d7/a0-a6,-(SP)
move.l    4.w,a6
MOVE.W    $14(A6),D0    ; lib sürümü
CMP.W    #37,D0        ; V37+ mı? (kick 2.0+)
blo.s    nocaches    ; Kick1.3 ise, sorun şu ki
; 68040 olup olmadığını bile bilemez, bu yüzden
; riskli... ve umarım
; kick1.3 üzerinde 68020+ olan bir aptal
; ve önbellekleri devre dışı bırakmış bir aptalın
jsr    -$27c(a6)    ; cache cleaR U (yükleme, değişiklikler vb. için)
nocaches:
movem.l    (sp)+,d0-d7/a0-a6
rts

Startup2.s'de bu alt rutin vardır ve çalıştırılabilir.
Not: kick 1.3'te JSR yapmadan çıkar, bu şekilde eski bilgisayarlarda
sorun olmaz.
Bir trackloader ile
veri yükledikten sonra veya kod içeren bellek alanlarında başka değişiklikler yaptıktan sonra da bu rutini çalıştırın.
Bazen, otomatik olarak kendini değiştiren kod içeren bir programın 68020/68030 üzerinde tesadüfen çalışabileceğine dikkat edin,
çünkü değiştirilen komut ile onu değiştiren komut arasında 256 bayt'tan fazla mesafe vardır
ve değiştirilen komut arasında 256 bayt'tan fazla mesafe olduğundan komut RAM'den okunur, ancak
A4000'de önbellek 4096 bayttır ve gelecekteki işlemcilerde ne kadar
artırılabileceği bilinmez! Bu nedenle, bazı a1200 demo kodlayıcılarının yaptığı gibi ASLA otomatik değiştirmeye düşmeyin, aksi takdirde
bazı a1200 demo kodlayıcılarının yaptığı gibi, bu şekilde
kendi yarattıkları programların a4000'de çalışmamasını sağlarlar.

68030 ve 68040 işlemcilerde, INSTRUCTION CACHE ile aynı
işi yapan DATA CACHE de vardır, ancak bu veri üzerinde (tablo gibi) çalışır ve
bu veriler FAST RAM'de bulunuyorsa. CHIP RAM'de DATA cache çalışmaz.
DATA CACHE hataları daha az görülür, çünkü
örneğin tabloların değiştirilmesi zordur. Yine de güvenli olması için
CACHECLR komutunu kullanabilirsiniz, ayrıca 68040'ta copyback vardır,
DATA CACHE'nin bir “güçlendirilmesi”dir ve o kadar kötüdür ki
C dilinde derlenmiş bazı programlar bile çalışmaz.
Bu nedenle, ara sıra “ClearMyCache” komutunu çalıştırın, zararı olmaz.

-    -    -    -    -    -    -    -    -

11) Karşılaştığım bir başka uyumsuzluk sorunu, A4000'deki
kesintilerdir. 
A1200'de
çok iyi çalışan birçok demo, hatta AGA'lar bile, A4000'de müziği iki kat hızda çalıyor,
takılıyor ve bazen sistemi kilitliyordu. Bunun bir unutkanlıktan kaynaklandığını fark ettim, ki tüm
unutkanlıklar A4000'de kod çalışırken göze çarpar.
Şu seviye 3 kesintiye bir göz atın (anlamak için $6c):

INTERRUPT:
MOVEM.L    D0-D7/A0-A6,-(SP)
BSR.W    ROUTINE1
BSR.W    ROUTINE2
BSR.W    ROUTINE3
BSR.W    ROUTINE4
MOVEM.L    (SP)+,D0-D7/A0-A6
NOINT:
move.w    #$20,$dff09c    ; INTREQ - vertb (bit 5 - $20 = %100000)
rte

Sorun nedir? VBR+$6c'ye doğru yazıldığına dikkat edin, bu yüzden
düzenli olarak çalışıyor.
Çözüm:    INTREQR'DE BIT TESTİ EKSİK!!!!
Şu şekilde değiştirilmelidir:

INTERRUPT:
btst.b    #5,$dff01f    ; INTREQR - vertb int? (bit5)
beq.s    NOINT		; gerçek bir kesme değil VERTB
MOVEM.L    D0-D7/A0-A6,-(SP)
BSR.W    ROUTINE1
BSR.W    ROUTINE2
BSR.W    ROUTINE3
BSR.W    ROUTINE4
MOVEM.L    (SP)+,D0-D7/A0-A6
NOINT:
move.w    #$20,$dff09c    ; INTREQ - vertb (bit 5 - $20 = %100000)
rte

Aslında, a500/a1200'de kesme, INTREQR'deki bit kontrolü olmadan da çoğu zaman düzgün çalışır,
 ancak A4000'de HER ZAMAN konulmalıdır,
 aksi takdirde kesme bir milyar kez fazla çalışır.
Bu nedenle, INTREQR'de kesme oluşturan bitleri test etmeyi ASLA unutmayın
! Daha önce gördüğümüz gibi, her
kesme seviyesi için test edilmesi gereken bir $dff01f (INTREQR) biti vardır.

Bir hatırlatma:

INT $64    LEVEL1    bit 0 (soft) ,1 (dskblk) ,2 (serial port tbe)

INT $68    LEVEL2    bit 3 (ports)

INT $6c    LEVEL3    bit 4 (copper) ,5 (verticalblank) ,6 (blitter)

INT $70    LEVEL4    bit 7 (aud0) ,8 (aud1) ,9 (aud2) ,10 (aud3)

INT $74    LEVEL5    bit 11 (serial port rbf) ,12 (disk senkronizasyonu)

INT $78    SEVİYE6    bit 13 (harici int)

Her zaman kesmenin başında btst komutunu vermeyi unutmayın ve
bit ayarlanmamışsa (beq) rutinleri çalıştırmadan çıkın.
Çıkışta her zaman $dff09c üzerinde işlem yapın ve kesme talebini kaldırın,
 pratikte kesmenin gerçekleştirildiğini “işaretleyin”.
Benim de geçmişte yaptığım hatayı yapmamaya dikkat edin
, örneğin “BTST #11,$dff01f” gibi. Bu durumda aslında
11-8 bitini, yani $dff01f'nin 3 bitini test edersiniz. Waitblit olayını hatırlayacaksınız
,
 bu nedenle btst “#6,$dff002” yazmak
“btst #14,$dff002” yazmakla aynıdır.
 Bazı assembler'lar, bit sayısı 7'den fazla olan adreslerde BTST komutlarını da derler, ancak
bu komutlar, bu bit sayısını 8 ile ölçeklendirdiği için gereksizdir.
Devpac 3 gibi diğer assembler'lar ise hata verir ve bu gereksiz BTST'leri derlemeye izin vermez.
(BYTE'ye dikkat edin! = 0'dan 7'ye kadar!)

-    -    -    -    -    -    -    -    -

- DERSDE AÇIKLANAN HATALARDAN BİRİNİ YAPANIN BAŞI BELADA!!!!!!!!!!!!
