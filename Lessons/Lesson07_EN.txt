
ASSEMBLER COURSE - LESSON 7

In this lesson, we will talk about sprites, joysticks, and
68000 instructions for bit operations such as AND, OR, EOR, NOT, LSR, ROL...

Remember to write ‘V df0:SOURCES3’ to load the .raw files
from the directory where the listings for this lesson are located.

Sprites are graphic objects of a specific size, with a maximum width of
16 pixels, which can move around the screen independently of the
bitplanes. For example, the arrow pointer that you move with the mouse to
select from menus or press ‘buttons’ is a sprite managed by the operating system,
 which can move wherever it wants without caring about the bitplanes that are
‘below’ it.
Sprites could be considered as ‘ghost’ images that float
‘above’ the bitplanes, but not everything that moves is a sprite!
In fact, there can only be a maximum of 8 sprites, as there are only 8
pointers in the copperlist for sprites:

COPPERLIST:
SpritePointers:
dc.w    $120,0,$122,0    ; Pointer for Sprite 0
dc.w    $124,0,$126,0    ; Pointer for Sprite 1
dc.w    $128,0,$12a,0    ; ‘’    ‘’	‘’     2
dc.w    $12c,0,$12e,0    ; ‘’    ‘’    ‘’     3
dc.w    $130,0,$132,0    ; ‘’    ‘’    ‘’     4
dc.w    $134,0,$136,0    ; “”    ‘’	‘’     5
dc.w    $138,0,$13a,0    ; ‘’    ‘’    “”     6
dc.w    $13c,0,$13e,0    ; ‘’	‘’    “”     7

The pointers to the sprites are called SPRxPT registers (the ‘x’ is replaced
by the sprite number: we therefore have SPR0PT, SPR1PT, .. SPR7PT and
when we talk about SPRxPT we refer in general to all 8 pointers)
For now, we have put them in the copperlist with a value of zero just to prevent these
‘ghost’ objects from jumping around on our figures without control.
The sprites are isolated from the rest of the screen, as if they were in a "transparent envelope
applied over the monitor. In fact, the resolution of the sprites
is always lowres, 320x256, even if the underlying bitplanes are in hires
or interlaced.
A way to check that sprites are not part of the bitplanes is that to move them
you don't need to delete them and redraw them later each time, as we would
have had to do to move a piece of graphics in a bitplane.
To move a sprite, just change its coordinates using a few
quick instructions on special bytes dedicated to this task, which are located
at the beginning of the sprite's data structure.
When sprites are not enough to make spaceships and little men in a game,
the blitter is used to copy blocks of graphics (bobs), which we will see later.
As already mentioned, the size of a sprite is 16 pixels wide,
while the height can be chosen as desired, even the entire screen, i.e.
256 lines.
 To make an end-of-level monster, you could use all 8 sprites side by side, reaching a total width of 16*8=128 pixels.
The problem is that such a monster would be rather colourless by today's standards,
since a sprite can have a maximum of 3 colours, given that the “fourth” is the
“transparent” part, i.e. the part where the background shows through, i.e. the
bitplanes.
The characteristic of sprites is that they are simple to make and animate.
In fact, sprites can be drawn with a drawing programme, as long as
it is no wider than 16 pixels and has 3 colours plus the background, i.e. 4,
and can be converted to SPRITE by the IFFCONVERTER KEFCON.
Or you can draw directly in binary, as we saw for the
8x8 font:

- plane 1 -     - plane 2 -     ; the overlap of
; these 2 bit ‘planes’
dc.w    %0111110000000000,%0111110000000000 ; determines the colour.
dc.w    %1000001000000000,%1111111000000000 ; This is the arrow
dc.w    %1111010000000000,%1000110000000000 ; default pointer
dc.w    %1111101000000000,%1000011000000000 ; kickstart 1.3, the
dc.w    %1111110100000000,%1001001100000000 ; recognise??
dc.w	%1110111010000000,%1010100110000000
dc.w	%0100011101000000,%0100010011000000
dc.w	%0000001110100000,%0000001001100000
dc.w	%0000000111100000,%0000000100100000
dc.w	%0000000011000000,%0000000011000000
dc.w	%0000000000000000,%0000000000000000

dc.w    0,0    ; Two zero words indicate the end of the sprite.

In this case, the width is 16 pixels and not 8 as in the 8x8 font, so
we draw it in one word (dc.w) and not in one byte.
It also has 3 colours plus transparent, i.e. 4 possibilities like a 2-bitplane figure
with 2 bitplanes, so we need a couple of ‘planes’ just like for bitplanes,
and their overlap will determine the colour, which can be:

Plane 1    - Plane 2

binary:     0    -    0    = COLOUR 0 (TRANSPARENT)
binary:     1    -    0	= COLOUR 1
binary:     0    -    1    = COLOUR 2
binary:     1    -    1    = COLOUR 3

In fact, as we have already seen, with 2 bit planes, 4
different combinations can be formed: %00,%01,%10,%11

To decide the position of the sprite, simply enter the X and Y coordinates
in the first bytes of the sprite itself. In fact, before the drawing data, the
sprite is composed of 4 bytes, i.e. 2 words, called CONTROL WORDS, and
these bytes contain the coordinates of the sprite on the screen.
To be more precise, the first byte, called VSTART, contains the
vertical start position of the sprite; the second byte contains the
horizontal position (HSTART). The third contains the end position of the sprite
in the vertical direction: to determine this, simply add the height of the sprite
to the start position, and the result will be the vertical position where
the sprite ends.
The fourth byte contains bits for special functions that we will see later.
VSTART and HSTART (Vertical Start and Horizontal Start) are therefore the coordinates
of the top left corner where the sprite begins:


#....
.....
.....
.....
.....


VSTOP is the vertical position where the sprite ends:


.....
.....
.....
.....
#####    -> vertical line indicated by VSTOP.


For example, a sprite displayed at position XX=$90 and YY=$50, 20
pixels long, would start like this:


;IYIX FY    - IY=Start Y, IX=Start X, FY=End Y
SPRITE:
dc.w    $5090,$6400    ;Y=$50, X=$90, height= $50+20, i.e. $64
; from here the data for the 2 planes of the sprite begin
dc.w	%0000000000000000,%0000110000110000
dc.w    %0000000000000000,%0000011001100000
...
dc.w    0,0    ; end of the sprite


In fact, the first byte, VSTART, is at $50, the second, HSTART, is at $90, while
the third, the vertical position of the end of the sprite, is at $64, i.e. at $50+20, the
start position + the length of the sprite. For now, we will leave the fourth byte
at zero; we will see what it is for later. I can say in advance that the HSTART byte,
i.e. the one that deals with the horizontal position, moves the sprite
in ‘steps’ of 2 pixels at a time, so moving a sprite from position
$50 to position $51, for example, it would move 2 pixels to the right, not
one: we will see that by using a bit of the fourth byte, you can move the sprite
one pixel at a time horizontally.
As for the vertical position, however, scrolling already occurs
with VSTART/VSTOP in increments of one pixel, but the limitation is the video line $FF,
beyond which you can go using another of the bits of the fourth byte.
For simplicity's sake, in the first examples we will only move the sprites
by acting on the HSTART, VSTART and VSTOP bytes, i.e. with the limitations of a
horizontal scrolling in ‘steps’ of two pixels at a time.
Only later will we see how to make smoother scrolling.
Remember, therefore, that with

ADDQ.B #1,HSTART,

 for example, we move the sprite by 2 pixels and not by one.


To act on the 3 bytes VSTART/HSTART/VSTOP, you could do this:

MOVE.B    #$50,SPRITE    ; VSTART = $50
MOVE.B    #$90,SPRITE+1    ; HSTART = $90
MOVE.B    #$64,SPRITE+2	; VSTOP     = $64 ($50+20)

Or you can define a label for each byte to make it clearer:


SPRITE:
VSTART:            ; VERTICAL start position
dc.b $50
HSTART:            ; HORIZONTAL start position
dc.b $90
VSTOP:
dc.b    $64        ; VERTICAL end position
dc.b    $00        ; byte for special functions reset

; from here the data for the 2 sprite planes begins

dc.w    %0000000000000000,%0000110000110000
dc.w    %0000000000000000,%0000011001100000
...
dc.w    0,0    ; end of sprite


In this case, we would act on the labels VSTART, HSTART and VSTOP:

ADDQ.B	#1,HSTART    ; move the sprite 2 pixels to the right
; (2 pixels and not 1 for the reasons described)

SUBQ.B    #1,HSTART    ; move the sprite 2 pixels to the left

To move the sprite down or up, however, we must remember to
modify both VSTART and VSTOP, because it is obvious that if we move the sprite down or
up, both the first pixel on the left and the last pixel will move:

ADDQ.B    #1,VSTART    ; \ moves the sprite down by 1 pixel
ADDQ.B    #1,VSTOP    ; /

SUBQ.B    #1,VSTART    ; \ moves the sprite up by 1 pixel
SUBQ.B    #1,VSTOP    ; /


To summarise, this is the structure of the sprite:


first control word,     second control word
first    line (.w) of plane 1, first     line (.w) of plane 2
second line (.w) of plane 1, second line (.w) of plane 2
third line (.w) of plane 1, third line (.w) of plane 2
fourth line (.w) of plane 1, fourth line (.w) of plane 2
fifth line (.w) of plane 1, fifth line (.w) of plane 2
...
DC.W	0,0 ; the last line must contain two zeros


The sprite data is divided into plane 1 and plane 2 only to indicate that
their overlap determines the 3 colours plus the transparent one in a manner
similar to the screen bitplanes, but they should not be confused with the latter!


SPRITE COLOURS

To define the colours of the sprites, you must use the same colour registers
used by the bitplanes, as the Amiga only has 32 colour registers.
The designers decided to make the sprites take their colours from
16 to 31, so if the figures are not 32-colour, i.e. 5 bitplanes, the
sprites can have different colours from the figures. Otherwise, the sprites
will have 16 colours in common with the 32-colour figure underneath.
For now, let's see how to define the colours of the first sprite:

(Sprites are numbered from 0 to 7)

COLOUR 0 of sprite 0 = TRANSPARENCY, not to be defined
COLOUR 1 of sprite 0 = COLOR17 ($dff1a2)
COLOUR 2 of sprite 0 = COLOR18 ($dff1a4)
COLOUR 3 of sprite 0 = COLOR19 ($dff1a6)

Colour 0, i.e. the fourth, is transparency and does not need to be defined.

Before proceeding, let's look at the first example of displaying a sprite
in Lesson 7a. In this example, the first sprite is pointed to, leaving
the other 7 reset. To point to a sprite, you must do as for bitplanes,
since the sprite has pointers that work in the same way:

MOVE.L    #MIOSPRITE,d0		; sprite address in d0
LEA    SpritePointers,a1    ; Pointers in copperlist
move.w    d0,6(a1)
swap    d0
move.w    d0,2(a1)

Remember that to display sprites, at least one
bitplane must be “turned on”; when bitplanes are disabled, sprites are also disabled.
Similarly, a sprite is ‘cut off’ if it goes beyond the video window,
defined with DIWSTART and DIWSTOP, and can only be displayed within it.
Note that to position the sprite on the 320x256 screen, for example
at the central coordinates 160,128, you must take into account that the first coordinate at
top left, where the video window begins, is not 0,0, but $40,$2c, so
you must add $40 to the X coordinate and $2c to the Y coordinate.
In fact, $40+160, $2c+128 correspond to the coordinate 160,128 of a
320x256 non-overscan screen.
Since we do not yet have control of the horizontal position at the 1
pixel level, but every 2 pixels, we must add not 160, but 160/2, to locate the
centre of the screen:


HSTART:
dc.b $40+(160/2)    ; positioned at the centre of the screen
...


Here is a diagram of the screen, where the visible part, i.e. the video window,
 is white, while the entire screen outside the edges, starting with
coordinates 0,0, is made up of ####. Note that the video window starts
at coordinates $40 XX and $2c YY.

(0,0) __
\
\
+---------------------------+
|###########################|
/\    |###########################|
||    |###+-------------------+###|
||    |###| $40,$2c        |###| __ Screen borders
||    |###|     ______        |###| / visible (video window)
||    |###|    /Sprite\    |###|/
||    |###|    |++XX++|    |###/
||    |###|    \/\/\/\/    |##/|
|###|            |#/#|
Y AXIS    |###|             |/##|
|###|            |###|
||    |###|            |###|
||    |###|            |###|
||    |###|            |###|
||    |###|            |###|
||    |###+-------------------+###|
\/    |###########################|
|################|
+--------------------------+
<----- X AXIS ----->

The HORIZONTAL position of the sprite can range from 0 to 447, but it is clear
that to be visible on a 320-pixel wide screen, it must range from 64 to 383.
The VERTICAL position of the sprite, on the other hand, can range from 0 to 262, but to 
be visible on a PAL screen (256 lines) it must go from 44 ($2c) to the
end of the screen, 44+256= 300 ($12c). For now we have only reached the
position $FF, we will see later how to go to $12c.

In Lesson 7b.s, the sprite is moved across the screen with ADD and SUB
on the two control words.

In Lesson 7c.s, the sprite is moved horizontally across the screen with
tables of predefined values instead of ADD and SUB.
In Lesson 7d.s, it is made to jump vertically.
In Lesson 7e.s, the two coordinates XX and YY are defined by two tables to
create circular movements, ellipses, etc. This example also
explains how to create your own tables!

Before continuing, load and run these examples in other text buffers,
 reading the final comments.

So far, we have only displayed one sprite. Let's see what we need to know if
we want to display all 8 sprites. First of all, each sprite has an independent position
relative to the others and has its own VSTART, HSTART and VSTOP in the
first 2 words. As for colours (and other properties
of sprites that we will see later, such as collisions), the
sprites are not totally independent but are paired two by two. There are
therefore 4 pairs of two sprites: Sprite0+Sprite1, Sprite2+Sprite3,
Sprite4+Sprite5, and finally Sprite6+Sprite7. Throughout the rest of the lesson,
when we talk about a ‘pair of sprites,’ we do not mean any two sprites, but
one of these 4 pairs.
For colours, keep in mind that sprites in a pair
share colours, i.e. each pair of sprites has its own
palette that is different from that of the other pairs.
We know that the 3 colours of sprite 0 can be defined with the COLOR17,
COLOR18 and COLOR19 registers. These 3 colours also apply to the ‘brother’ sprite,
i.e. sprite 1.
Each pair has a different colour palette because registers
16 to 31 are available, i.e. 16 registers.
Considering that each sprite has 4 colours (including 1 transparent), we would need
8*4=32 registers, when only 16 remain.
Therefore, with 8 sprites with 4 colours each, here are the registers from which the pairs
of sprites take their colours:


Sprite    Binary value    Colour register:
------    --------------    ------------------
Pair 1:    0 or 1        00    Not used because transparent
01    Colour17 - $dff1a2
10    Colour18 - $dff1a4
11    Colour19 - $dff1a6

Pair 2:    2 or 3        00    Not used because transparent
01    Colour21 - $dff1aa
10    Colour22 - $dff1ac
11    Colour23 - $dff1ae

Pair 3:    4 or 5        00    Not used because transparent
01    Color25 - $dff1b2
10	Color26 - $dff1b4
11    Color27 - $dff1b6

Pair 4:    6 or 7        00    Not used because transparent
01    Color29 - $dff1ba
10    Color30 - $dff1bc
11    Color31 - $dff1be

Let's take a practical example: in the copperlist, to define the colour of the 8
sprites, you need to do this:


dc.w    $1A2,$F00    ; colour17, - COLOUR1 of sprites0/1 -RED
dc.w    $1A4,$0F0    ; colour18, - COLOUR2 of sprites0/1
 -GREEN
dc.w    $1A6,$FF0    ; color19, - COLOUR3 of sprites0/1 -YELLOW

dc.w    $1AA,$FFF    ; color21, - COLOUR1 of sprites2/3 -WHITE
dc.w    $1AC,$0BD    ; color22, 
- COLOUR2 of sprites 2/3 -WATER
dc.w    $1AE,$D50    ; colour23, - COLOUR3 of sprites 2/3 -ORANGE

dc.w    $1B2,$00F    ; colour25, - COLOUR1 of sprites 4/5 -BLUE
dc.w    $1B4,$F0F	; colour26, - COLOUR2 of sprites 4/5 -PURPLE
dc.w    $1B6,$BBB    ; colour27, - COLOUR3 of sprites 4/5 -GREY

dc.w    $1BA,$8E0    ; colour29, - COLOUR1 of sprites 6/7 -GREEN CH.
dc.w    $1BC,$a70    ; colour30, - COLOUR2 of sprites 6/7 -BROWN
dc.w    $1BE,$d00    ; color31, - COLOUR3 of sprites 6/7 -RED SC.

NOTE: If you set a 2, 4, 8 or 16-colour figure as the background, there are no
problems with the palette, but if you decide to activate a 32-colour screen,
i.e. 5 bitplanes, the figure will share the last colours with the sprites,
so you must ensure that the colours are correct for both the figure and
the sprite, i.e. that the colour is “multi-purpose”.



VIDEO PRIORITY BETWEEN SPRITES.

When there are two or more sprites on the screen, some sprites may
overlap. In this case, the sprite with the lowest priority is covered.
 The priority between sprites is always the same, the sprite with the lowest number
always has priority over those with higher numbers, which remain
‘behind’. Consequently, sprite 0 can cover all other sprites, while
sprite 7 can be covered by all others. Here is a diagram:

_______
|     |
___|___7 |
|     |___|
__|___6 |
|     |__|
__|___5 |
| |__|
___|___4 |
|     |___|
___|___3 |
| |___|
___|___2 |
|     |___|
___|___1 |
|    |___|
| 0 |
|_______|


Let's check by loading and running Lesson7f.s in another text buffer, which
displays 8 sprites, and after pressing the left mouse button, it
overlaps them to highlight the priorities. Right-click to exit.


SPRITE ‘ATTACHED’

There is also a mode for pairing sprites 2 by 2, one
on top of the other, which reduces the number of available sprites by half, i.e.
to four, but with 16 colours each instead of 4 (15 colours plus transparent).
They can only be combined in this way:

SPRITE0+SPRITE1 - Sprite ATTACHED Number 1
SPRITE2+SPRITE3 - Sprite ATTACHED Number 2
SPRITE4+SPRITE5 - Sprite ATTACHED Number 3
SPRITE6+SPRITE7 - Sprite ATTACHED Number 4

In practice, sprites that already pair up in normal mode are attached
because they have the same palette. The 4 ‘attached’ sprites share the same
16-colour palette, since only colour registers from
Color16 to Color31 are available.
ATTACCHED sprites work as follows: normally, a sprite has a
maximum of 4 overlap possibilities for its small ‘bitplanes’,
i.e. %00 for transparent and %01, %10, %11 for the other 3 colours.
The ATTACHED mode overlaps the bit planes of the two sprites to
form 16 possibilities. In fact, by placing the two planes of the first sprite on top of the two planes
of the second sprite, you can obtain %1111 possibilities instead of %11, i.e. 16
instead of 4.
The table below, in the ‘binary value’ column, lists the various
overlay possibilities and the resulting colour.


Colour    Value     Sprite number
Binary     Colour register
-------    ------    --------------
0    0000    Colour16 - NOT USED, it is TRANSPARENT
1    0001    Colour17 - $dff1a2
2    0010    Colour18 - $dff1a4
3    0011    Colour19 - $dff1a6
4    0100    Colour20 - $dff1a8
5    0101    Colour21 - $dff1aa
6    0110    Colour22 - $dff1ac
7	0111    Colour23 - $dff1ae
8    1000    Colour24 - $dff1b0
9    1001    Colour25 - $dff1b2
10    1010    Colour26 - $dff1b4
11    1011    Colour27 - $dff1b6
12    1100    Colour28 - $dff1b8
13    1101    Colour29 - $dff1ba
14    1110    Colour30 - $dff1bc
15    1111    Colour31 - $dff1be

Therefore, in COPPERLIST they must be defined as follows:

dc.w    $1A2,$F00    ; colour17, COLOUR 1 for attached sprites
dc.w    $1A4,$0F0    ; colour18, COLOUR 2 for attached sprites
dc.w	$1A6,$FF0    ; colour19, COLOUR 3 for attached sprites
dc.w    $1A8,$FF0    ; colour20, COLOUR 4 for attached sprites
dc.w    $1AA,$FFF	; colour 21, COLOUR 5 for attached sprites
dc.w    $1AC,$0BD    ; colour 22, COLOUR 6 for attached sprites
dc.w    $1AE,$D50    ; colour 23, COLOUR 7 for attached sprites
dc.w    $1B0,$D50	; colour24, COLOUR 7 for attached sprites
dc.w    $1B2,$00F    ; colour25, COLOUR 9 for attached sprites
dc.w    $1B4,$F0F    ; colour26, COLOUR 10 for attached sprites
dc.w    $1B6,$BBB	; color27, COLOUR 11 for attached sprites
dc.w    $1B8,$BBB	; colour28, COLOUR 12 for attached sprites
dc.w    $1BA,$8E0    ; colour29, COLOUR 13 for attached sprites
dc.w    $1BC,$a70    ; colour30, COLOUR 14 for attached sprites
dc.w	$1BE,$d00    ; colour31, COLOUR 15 for attached sprites

To ‘attach’ two sprites, simply set bit 7 of the second word of the
odd sprite control word of the pair (i.e. the flamed fourth
byte of the special functions) to 1.
For example, to attach sprites 0 and 1, just set that bit to
sprite 1, to attach sprites 4 and 5, just set it to 5.
Obviously, the attached sprites must have the same coordinates, i.e.
be one above the other, to allow the correct overlapping of the 4
planes.
Let's take an example: to attach sprites 0 and 1, you need to set bit
7 of the fourth byte of sprite 1 to 1:


SPRITE0:
VSTART0:        ; VERTICAL start position
dc.b $50
HSTART0:        ; HORIZONTAL start position
dc.b $90
VSTOP0:
dc.b    $64    ; VERTICAL end position
dc.b    $00    ; no need to set bit 7 for even sprites.
; from here the data for the 2 planes of the sprite begin
dc.w    %0000000000000000,%0000110000110000
dc.w    %0000000000000000,%0000011001100000
...
dc.w    0,0    ; end sprite0


SPRITE1:
VSTART1:        ; VERTICAL start position
dc.b $50
HSTART:            ; HORIZONTAL start position
dc.b $90
VSTOP:
dc.b    $64        ; VERTICAL end position

;76543210
dc.b    %10000000    ; BIT 7 SET! ATTACHED MODE for sprite 0/1

; from here the data for the 2 planes of the sprite begin
dc.w    %0000000000000000,%0000110000110000
dc.w    %0000000000000000,%0000011001100000
...
dc.w    0,0    ; end sprite1


So, to ensure that all sprites are in ‘ATTACHED’ mode, simply set
bit 7 of the fourth byte of sprites 1, 3, 5 and 7 (i.e. the odd ones) to 1.

To create a 16-colour sprite, you need to draw it with a drawing programme
and convert it to SPRITE format with the KEFCON iffconverter, as it is
difficult to “calculate” by eye the colours resulting from 4 bit planes, divided
into two sprites!

Load and run the listing Lesson7g.s, which displays a
16-colour sprite in ATTACCHED mode, where it is also described how to convert
a sprite with KEFCON, both to 4 colours and to 16.

It is possible to display 16-colour sprites and 4-colour sprites at the same time,
 for example sprites 0 and 1 ‘attached’ and the others not, or any
other combination.

The example listing Lesson7h.s shows the 4 sprites attached in 16
colours, each with a movement independent of the others.

At this point, you may be wondering why
the problem of jerky horizontal scrolling in 2-pixel steps
instead of one has not yet been eliminated. Well, the time has come to solve the problem, but to
do so, you need to learn a new 68000 instruction, which
operates on individual bits of a number: --- LSR ---
This instruction means ‘LOGIC SHIFT RIGHT’, i.e. ‘LOGICAL SHIFT
OF BITS TO THE RIGHT’. In other words, if a binary number in d0 is %00111, after
a nice LSR #1,d0 the result is %00011, after an LSR #2,d0 it is %00001.
Similarly, a %00110010 after an LSR #1,d0 becomes %00011001, while
after an LSR #5,d0 it becomes %00000001. Therefore, the number, considered in its
binary form, is shifted to the right as if the bits were on a tablecloth
that we pull: pulling #1 shifts the tablecloth with all the BitPiatti on top
and the first BitPiatto falls to the ground... Pulling too much can move everything
, causing everything to fall on the floor and clearing the table.
But what does this assembler instruction have to do with the HSTART byte?
The problem lies in these terms: as you know, the possible horizontal positions
are far more than $FF (255), simply because the screen is
320 pixels wide. To indicate a number greater than 255 (8 bits, from zero to
seven), at least one more bit must be added, the ninth, called bit 8, so
instead of a maximum of %11111111 ($ff), you can have a maximum of
%111111111, i.e. 511, which is fine for HSTART. But where to put this
bit? Those jokers, the designers, thought it would be a good idea to put it in the
infamous fourth control byte, the one we have already seen for
attaching sprites (bit 7 of that byte is used to attach
sprites to make them 16 colours).
Having 6 other bits free for various uses, they decided to use bit 0 as the
LOW bit of the 9-bit horizontal coordinate, breaking the
9-bit number in this way:

;876543210    ; 9-bit number, representing the HSTART coordinate
%11111111
\_____/
|
8 high bits |
placed in the HSTART byte
|
|
|
|
|
|
|
bit 0 of the
9-bit number
placed in bit 0
of the fourth
 
control byte

If you remove the low bit from a 9-bit number, you will always get even numbers,
since bit 0 is always zero. It is when bit 0 is 1 that the number
is odd. Try it with ‘?100’ and ‘?101’. you will see that even numbers
always have bit 0 set to zero, while odd numbers always have bit 0
set. Until now, we could only move in increments of 2 pixels at a time and
had to put half the actual value in HSTART for this reason.
In order to also reach odd numbers and enter the true coordinate in
input, simply divide the real coordinate into a low bit and a high byte, then
put the low bit in its place and the high byte in its place. To do this
,
 imagine you have the odd coordinate 35: (%00100011)
First, we need to check whether bit 0 of the fourth
control byte needs to be set. To do this, simply test whether the number
in question has bit 0 set with a BTST, after which we will act
accordingly: suppose we have the coordinate in D0:

btst    #0,D0        ; low bit of the X coordinate reset?
beq.s    BitBassoZERO
bset    #0,MIOSPRITE+3	; Set the low bit of HSTART
bra.s    PlaceCoords

BitBassoZERO:
bclr    #0,MIOSPRITE+3    ; Reset the low bit of HSTART
PlaceCoords:
....

Now we have set or reset the low bit of HSTART, all that remains is to put
the rest of the number, the 8 highest bits, in the HSTART byte as usual.
But there is a problem: the number has 9 bits, and we only need the 8 highest bits!
At this point, the LSR instruction appears on the scene!!! In fact, it performs the
task of ‘shifting’ the bits of the number one position to the right,
making the low bit disappear and placing the 8 bits we need in the right place.
 Let's look at the rest of the routine under the PlaceCoords label:

lsr.w    #1,D0        ; SHIFT, i.e. move 1 bit to the right
; the value of HSTART, to ‘transform’ it into
; the value to be placed in the HSTART byte, i.e. without
; the low bit.
move.b    D0,HSTART	; We place the value XX in the HSTART byte
rts

In this case we had the coordinate %00100011 (35), let's see how it becomes after
the LSR.W #1,d0: %00010001!!!! That is, the correct byte to put in HSTART.

In Lesson7i.s, this routine is used to make a
sprite FINALLY run smoothly as only the Amiga can do.

At this point, we can also eliminate the last limitation, i.e. the vertical one
: in fact, vertically we can move the sprite in increments of
one pixel, but only up to the $FF line. The Amiga designers opted for
a different solution from that of HSTART for VSTART/VSTOP: in fact,
VSTART and VSTOP also require a 9-bit number instead of 8, but instead of
separating the lowest bit (zero) from the other 8 higher bits, they separated
the highest bit (the ninth) from the eight lower bits, so that in VSTART and
VSTOP the number is valid up to $FF, i.e. 255, after which it is necessary to
set the ninth bit that has been placed in the infamous fourth control byte.
 In fact, after $ff comes $100, $101, etc., so the low byte
starts again from zero, but with the ninth bit set. Let's see how to create a routine
similar to the one seen for the horizontal position, i.e. starting from the
real coordinate (a word is required) and “dividing” it into high bit and low byte.
 Remember that in this case we also have to update VSTOP as well as
VSTART every time!!! Keep in mind that the high bit of VSTOP is bit 1
of the fourth control byte, while that of VSTART is bit 2:

MOVE.w    (A0),d0        ; copy the word from the table to d0
ADD.W	#$2c,d0        ; add the offset of the start of the screen
MOVE.b    d0,VSTART    ; copy the byte to VSTART
btst.l    #8,d0        ; number greater than $FF?
beq.s    NonVSTARTSET
bset.b	#2,MIOSPRITE+3    ; Set bit 8 of VSTART (number > $FF)
bra.s    ToVSTOP
NonVSTARTSET:
bclr.b    #2,MIOSPRITE+3    ; Clear bit 8 of VSTART (number < $FF)
ToVSTOP:
ADD.w    #13,D0        ; Add the sprite length to
; determine the final position (VSTOP)
move.b    d0,VSTOP    ; Move the correct value to VSTOP
btst.l    #8,d0
beq.s    NonVSTOPSET
bset.b	#1,MIOSPRITE+3    ; Set bit 8 of VSTOP (number > $FF)
bra.w    VstopFIN
NonVSTOPSET:
bclr.b    #1,MIOSPRITE+3    ; Clear bit 8 of VSTOP (number < $FF)
VstopFIN:
rts

This routine works in a similar way to the previous one for setting
the ‘detached’ bit, but differs in that it must act on both
VSTART and VSTOP, and in the absence of LSR, which is useless here.

You can try it out by loading Lesson7l.s

Now that we have complete control over the sprites, let's optimise the
routines with which we control them: first of all, the first thing to do is
to create a universal sprite control routine, so that
avoid having to rewrite the part of the ‘detached’ bit arrangement for each of the 8 sprites.
 We need a parametric routine, which requires
the address of the sprite concerned and the X and Y coordinates it must
assume as input. In this way, it will be sufficient to execute a ‘BSR Routine’ for each sprite
instead of rewriting everything. We can then reuse this routine whenever
 we want to program the sprites, with only minor modifications. An
example of such a routine can be found in lesson7m.s.
The universal routine is called UniMuoviSprite, and in order to work, it needs
to be given not only the address of the sprite to be moved and the
new coordinates it must take, but also the height of the sprite, which is needed
by the routine to calculate the value of the VSTOP byte.
These values are communicated or rather ‘passed’ to the routine by placing them in
certain registers before executing the routine.
More precisely, the address of the sprite must be placed in register a1,
its height in register d2, the Y coordinate in register d0 and the
X coordinate in register d1.
The sprite coordinates ‘passed’ to the routine are the values on the screen
320x256. In fact, the routine takes care of ‘centring’ the sprite on the screen
by adding $40 to the X coordinate and $2c to the Y coordinate.
It also takes care of setting the low bit of HSTART and the high bits of VSTART
and VSTOP.

In short:

;
;    Input parameters of UniMuoviSprite:
;
;    a1 = Address of the sprite
;    d0 = Vertical position Y of the sprite on the screen (0-255)
;    d1 = Horizontal position X of the sprite on the screen (0-320)
;    d2 = height of the sprite
;

Now that we have this routine that solves once and for all the
problems related to the positioning of sprites, we can have fun using it
for some applications that will allow us to gain some experience with 
sprites. Before continuing, however, load and run Lesson7m.s, and
don't dare continue reading lesson7.txt or load listings before
you have understood it COMPLETELY. Since it will be used in all other examples
on sprites, it would be unproductive to continue without understanding a routine
that you will encounter repeatedly.


In lesson7n.s, we see a sprite that moves across the screen following
straight lines. The positions of the sprite are not contained
in a table, but are calculated each time by moving the
sprite at a constant speed. Load it and run it, and we will also see how to
bounce a sprite against the edges of the screen.


In lesson 7o.s, we will see two sprites that are both moved by the
universal routine. This is an excellent example of how, thanks to the use of
parameters, our universal routine is able to move sprites of different shapes and sizes without any
modification.
If we did not use parameters, we would have to write a routine for each sprite,
wasting time and memory on the computer (with 8 sprites we would have to
write 8 routines).


In lesson 7p.s, still using the universal routine, we will see how to
create objects wider than 16 pixels using
side-by-side sprites.
 Be very careful not to confuse ‘ATTACHED’ sprites with ‘SIDE-BY-SIDE’ sprites: the former are two sprites from the same pair used in
“attached” mode, they have the same coordinates (they are perfectly
superimposed) and the odd sprite has the ‘attach’ bit set to 1;
‘side-by-side’ sprites, on the other hand, are a set of two or more sprites that
are positioned on the screen next to each other without leaving
even a column of pixels between them, so that they appear as a
single object wider than 16 pixels, since they are moved simultaneously.
There is no bit to set for side-by-side sprites; this is not a
special ‘mode’ for sprites, but only a particular arrangement on the
screen of normal sprites. Here is a diagram showing a spaceship
made from a single sprite and another made from two sprites:


(128,65)		 (128,65)     (144,65)
|_ _ _ __ _ _ _    |_ _ _ _ _ _ __|__ _ _ _ _ _ _
| / \    |    |     / | \     |
__/____\__             /     \
| |     |    |    |     / | \     |
|     |         ____/___________\____
| |__________| |    | |     |     | |
\     /         |             |
|_ _ _\__/_ _ _|    | |     |     | |
|             |
| |__________|__________| |
\     /
|     \ | /     |
\     /
|_ _ _ _ _ _\__|__/_ _ _ _ _ _|

Sprite 0     Sprite 1


With this technique, you can create end-of-level monsters up to
128 pixels wide (16*8) if made with 3-colour sprites, or up to 64
pixels (16*4) if made with 15-colour sprites. If the monster in
question is taller than it is wide, for example human-shaped, you could
take advantage of the entire length of the screen, since there are no limits to
the height of a sprite, and you could change the palette vertically with
copper to colour it, for example, the shoes with a different colour from the jeans.


MOUSE AND JOYSTICK

Now that we have seen how to move sprites on the Amiga, why not
learn how to move them ourselves? With the help of a joystick or mouse, of course!

Before we look at how to use these devices, we need to learn some
new assembler instructions, which deal with manipulating the bits of a
register and are called NOT, AND, OR, and EOR.
These instructions work on individual bits of a register (or memory location),
 both for the source register and the destination register.
For example, these instructions consider a byte not as a number made up of
8 bits (binary digits) but as a set of 8 independent bits
. In practice, this means that the effect that the instruction has on a
single bit of the register is independent of what happens to the other bits
in the register.

First, let's look at NOT. It works on a single operand, and its effect
is to reverse the bits of the operand, i.e. to swap 1 with 0 and 0
with 1. For example, if we have the number %01001100 in register d0, if we do
NOT.B d0
the result will be %10110011.

The other 3 instructions, on the other hand, work with 2 operands, one source and one 
destination, perform an operation between the contents of the operands and put the
result in the destination operand. The operations (which are obviously
different for each instruction) are bit-by-bit, i.e. they occur between each bit
of the source operand and the corresponding bit of the destination operand,
in which the result is then placed. So doing D0 AND D1
basically means doing:
(bit 0 of D0) AND (bit 0 of D1)
(bit 1 of D0) AND (bit 1 of D1)
(bit 2 of D0) AND (bit 2 of D1) and so on for all bits of D0 and D1

Let's see how AND works between 2 bits. Since a bit is worth 0 or 1,
there are 4 possible cases:

0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1

AND results in 1 only when both the bit of the first operand
and that of the second operand are 1. In fact, AND means
‘and’, so it results in 1 if the first AND the second bit are 1.
It could be translated as:
‘ARE BOTH THE FIRST AND SECOND BITS 1? IF YES, I RESPOND WITH 1, IF NO
I RESPOND WITH A ZERO’.
An AND can be useful for resetting certain bits of a number:

AND.W #%1111111111111011,LABEL

This will reset bit 2 of the number in LABEL, because it is the only one that is reset
in the operand, and the only one that will be changed in the destination, because
all the others are 1, so they do not change the destination.
If the destination bit is 0, doing a 1 AND 0 results in 0,
similarly, if it is 1, doing a 1 AND 1 results in 1. As for
the bit that is 0, on the other hand, condemns the destination to be 0,
because to give a destination of 1, both operands must be 1,
in this case, since the first is 0, whether the second is 0 or 1, the result
will be 0. Some examples:

1111001111 AND 0011001100 = 0011001100 - No change
1101011011 AND 0001110001 = 0001010001 - 1 bit reset
1111101101 AND 0011111111 = 0011101101 - 2 bits reset

This reset operation is called MASKING:

AND #%11110000,LABEL    (%11110000 is the mask, in fact it is as if you
put a mask of ZEROS over the number
in LABEL, in this case it is as if we ‘covered’
the first 4 bits as you would cover a mole on a girl's face
when applying foundation. The mole is a 1 that
was in the position of the mask where
there were 0s, and the mole is “covered”
by the make-up, i.e. it is reset).

The OR, on the other hand, behaves in this way:

0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1

In this case, only one of the two bits needs to be 1 to give the result 1.
Therefore, the result is always 1 except when both bits are zero.
Here too, knowing that OR means “or” helps us remember that
the result is 1 if the first OR second bit is 1.
This could be translated as “EITHER ONE OR THE OTHER BIT MUST BE 1 TO GIVE 1”.
This command is useful, unlike AND, for SETTING bits, i.e. setting them
to 1: some examples:

0000000001 OR 1101011101 = 1101010001 - No change
1000000000 OR 0010011000 = 1010011000 - 1 bit set
0001111000 OR 1111100000 = 1111111000 - 2 bits set

In this case, it is as if the girl from before, instead of putting on
rosy foundation (the 0s) to cover up her black moles (i.e. the 1s), she put
black on to make fake moles, like the one Marilyn Monroe had above
her lip. Or as if she were a black girl (i.e. all 1) who
put on pink make-up to look white (like Michael Jackson), i.e.
to be all zero, who removes the foundation where the OR number
is one, revealing the black.

Instead, the EOR command, or exclusive OR, sets the bit only when it is 1
or the first or second bit, not when both are 1, as the
OR command does:

0 EOR 0 = 0
0 EOR 1 = 1
1 EOR 0 = 1
1 EOR 1 = 0     ; This is the difference with OR! In fact, 1 OR 1 = 1.

Some examples:
0000000001 EOR 1101011101 = 1101010000 - 1 bit reset
1000000000 EOR 0010011000 = 1010011000 - 1 bit set

This last instruction will be useful for reading the joystick.

As you know, the Amiga has two ports used to connect joysticks or mice. 
Either a joystick or a mouse can be connected to each of these ports
.
 For each port, there is a hardware register that can be read to
find out if and how the joystick and mouse are being moved. Port 0 (where
the mouse is usually connected) is read through the JOY0DAT register
($dff00a) register, while port 1 is read through JOY1DAT ($dff00c).
First, let's see how to read the joystick. We will refer to the
JOY1DAT register, which is the one usually used, but JOY0DAT works exactly the
same way when we connect a joystick.
We can think of a joystick as a set of 4 switches (one for
each direction), each of which can assume 2 states: closed (1) or
open (0) depending on whether the joystick lever is pressed or not in the
direction associated with the switch. To know in which directions the joystick is moved,
 we need to know the states of the switches.
For two of these switches, this is very simple, as their state is
reported in a bit of the JOY1DAT register:
- bit 1 of JOY1DAT is the state of the “right” switch
- bit 9 of JOY1DAT is the state of the “left” switch ‘left’ switch.
If a bit is 1, the associated switch is closed, otherwise it is open.
As for the other two directions, the status is not mapped directly
to a bit, but must be obtained by calculating an operation,
namely the EOR we explained earlier, performed between two bits of the
JOY1DAT register:
- the status of the ‘up’ switch is the result of an EOR between
bit 8 and bit 9
- the status of the ‘down’ switch is the result of an EOR between
bit 0 and bit 1.
Again, if a bit is 1, the associated switch is closed,
otherwise it is open.
Knowing the states of the 4 switches, we can now use the joystick to
move a sprite on the screen.

Load lesson7q.s into another text buffer and run it

Now let's move on to the mouse. When we connect a mouse to one of the ports, the
corresponding register behaves differently than in the case of the
joystick. In fact, taking the JOY0DAT register (but it is the same for 1),
we find that the high byte is used to detect movements in the vertical direction
and the low byte those in the horizontal direction. Each byte
represents a number (from 0 to 255) that varies according to the movements of the mouse.
- the high byte decreases each time the mouse is moved upwards
and increases each time the mouse is moved downwards.
- The low byte decreases each time the mouse is moved to the
left and increases each time the mouse is moved to the right.
Let's see how to use this information to move a sprite with the mouse.
The first method that comes to mind is to use the 2 bytes of JOY0DAT as
coordinates for the sprite, since the sprite's coordinates also
decrease if it moves up or left and increase if it moves down or
right.
This method has the disadvantage that in one byte we can reach the
value 255, so the values we can read from the JOY0DAT byte dedicated
to the horizontal direction can reach a maximum of 255, while the
horizontal coordinates of a sprite can exceed 320.

Load Lesson7r1.s and check this method.

A slightly more complex method that solves the problem of the
horizontal limitation to 255 pixels instead of 320 is presented in
Lesson7r2.s. For an explanation of the method, read the comment at the end
of the listing.

Knowing how to move an arrow on the screen, you can easily simulate
the intuition system, i.e. you can make a control panel with
buttons drawn on it that can be activated by moving the arrow (the sprite) over them and
pressing the button, whether it be on the joystick or the mouse. Just check
when the button is pressed where the arrow is located,
and if it is above a button, activate that button's option.
This is pretty easy to do, try it yourself. However, in
more advanced lessons of the course, there will be a listing of this type.



REUSING SPRITES

Reusing sprites is a technique that allows us to display
more than 8 sprites at the same time. In practice, the same sprite is used
to draw different objects located at different heights.
For example, if we use a sprite to display an alien at the
top of the screen, we can then use the same sprite again to
draw the player's spaceship at the bottom of the screen.
The only limitation when reusing sprites is that 2
objects drawn from the same sprite must be positioned at different heights.
 It is not possible to display 2
lines that make up 2 objects drawn with the same sprite on the same line of the screen. Furthermore,
the last line of the figure drawn during one use and the first line
of the figure drawn with the subsequent use of the same sprite MUST
be separated by at least one line in which the sprite is not used.
The following figure illustrates the situation better:

portion of screen
________________________
|             |     Each image in this portion
|         _     |     of the screen is drawn by the
|        _|_|_     |     same sprite.
|        \___/ _ _|_ _     Each image can be
| _ _ _ _ _ _ _ _ _ _|_ _ <-- positioned freely
| _/_\_         |	 horizontally.
| |_____|         |     However, at least one screen line
| \_/_ _ _ _ _ _ _ _ _|_ _     must separate the last line
|     _ _ _ _ _ _ _|_ _ <-- of one use of the sprite from the
|     /\         |     first line of the next use
|     \/         |    .
|			 |
|             |
|________________________|


There are no restrictions on horizontal positions
or on figures drawn using different sprites.
A sprite can be reused any number of times, each time
at a different height.
This technique can be applied to any sprite, and independently between
sprites: for example, you can use sprites
0, 3 and 4 can be used once, sprite 1 can be used three times, sprite 2 can be used four times and
sprites 5, 6 and 7 can not be used at all.

Applying this technique is very simple, as it only requires a
modification of the sprite's data structure.

Normally, at the end of the sprite structure, after all the data
describing the shape, there are two words with a value of 0, which indicate the end
of the structure. To reuse a sprite, instead of these two words,
we put another sprite structure, which describes another figure to be drawn
on the screen below the first one. If you want to reuse the sprite a
third time, put a third sprite structure immediately after the
second, and do the same for all the reuses you want. After the
data structure of the last use, put the two words with a value of 0 that
indicate the end of the last use.


SPRITE STRUCTURE
___________________________ - -
| | VSTART_1, HSTART_1 | |
|___________________________|
| | VSTOP_1 and bits     | |
|___________________________|
|                      |
___________________________
| | plane 1, row 1 | |
|___________________________|
| | plane 2, row 1 | |
|___________________________|         Data of the first
|                      |- - - use of the
------                sprite
|        ------             |
------
| ___________________________ |
| plane 1, last row |
| |___________________________| |
| plane 2, last row |
| |___________________________| |
-
___________________________ -
| | VSTART_2, HSTART_2 | |    Data of the second
|___________________________|        use of the sprite
| | VSTOP_2 and bit     | |- - - The start position
|___________________________|        must be
|                     |    at least one row lower
___________________________        than the last row
| |             |     |    of the previous use.
|___________________________|
| |             |     |
|___________________________|
|                     |
------
|        ------			 |
------
| ___________________________     |
|             |
| |___________________________|     |
|             |
\|/ |___________________________|     |
- -
_ _
_____             |
_____             |- - -    Subsequent uses
_____         _ _|

___________________________ _ _
|     0         |     |    Two zeroed words
|___________________________|     |_ _ _ indicating the end
|     0         |     |    of the last use
|___________________________|_ _|


Note that the various vertical uses must be placed in the structure
in order from the highest to the lowest.
Therefore, the VSTART byte of each use must be GREATER than the VSTOP byte
of the previous use of the sprite.

Let's look at a practical example of a structure in which a sprite is reused
twice:

MIOSPRITE:
VSTART_1:
dc.b $50                ; position of first use
HSTART_1:
dc.b $40+12
VSTOP_1:
dc.b $58
dc.b $00
dc.w    %0000001111000000,%0111110000111110	; ‘shape’ data of the first
dc.w    %0000111111110000,%1111001110001111    ; use
dc.w    %0011111111111100,%1100010001000011
dc.w	%0111111111111110,%1000010001000001
dc.w	%0111111111111110,%1000010001000001
dc.w	%0011111111111100,%1100010001000011
dc.w	%0000111111110000,%1111001110001111
dc.w	%0000001111000000,%0111110000111110
VSTART_2:         ; usage position 2
dc.b $70            ; NOTE THAT VSTART_2 > VSTOP_1
HSTART_2:
dc.b $40+20
VSTOP_2:
dc.b $78
dc.b $00
dc.w	%0000001111000000,%0111110000111110	; dati ‘forma’ del
dc.w	%0000111111110000,%1111001110001111	; secondo utilizzo
dc.w	%0011111111111100,%1100010001000011
dc.w	%0111111111111110,%1000001110000001
dc.w	%0111111111111110,%1000010001000001
dc.w	%0011111111111100,%1100010001000011
dc.w	%0000111111110000,%1111001110001111
dc.w	%0000001111000000,%0111110000111110
dc.w	0,0					; end of use


The reuse technique, if
used well, can multiply the number of objects in motion in a
shoot'em'up. For example, in a horizontal scrolling game, where enemies
move horizontally:


/--___
\--

/--___
\--

/--___
()-                \--
/\___o - - - - - -
||||--o - - - - - -            /--___
||||                    \--
//\\
// \\
------------------------------------------------------------

The enemy formation, being made up of objects that move
mostly horizontally, without ever going over each other, can be
made from a single reused sprite. This way, we would have 7 more sprites
for player 1 and for any bombs.


An example of how to use this technique can be found in lesson7s.s, where
we will display “16” sprites simultaneously. Load it and study it.


Our course would not be complete without one of the most “classic” effects
of a few years ago: the “starfield”, i.e. stars moving
horizontally.
The stars are actually created using a reused sprite.
We present three versions in lesson7t1.s, lesson7t2.s and lesson7t3.s.
The reuse of sprites can also be applied to ‘attached’ sprites,
in the same way as normal sprites. In lesson7t4.s, we see an example in
which we create an effect similar to the ‘starfield’ but with coloured balls
instead of stars.

-        -        -        -

DUAL PLAYFIELD MODE

Before explaining other features of sprites, we will digress
to discuss Dual Playfield mode in more detail.
As we already mentioned in lesson 4, Dual Playfield is a special graphics mode
that allows you to display two overlapping screens,
called PLAYFIELD 1 and 2. What does it mean that the two screens are overlapping?
In practice, each playfield has a ‘transparent’ colour through which you
can see what is underneath, in exactly the same way as colour 0
of each sprite. In practice, transparent is not a real colour but
a sort of ‘hole’ inside the playfield. The other colours of each
playfield behave normally. One of the two PLAYFIELDS (of your choice)
appears above the other, and its NON-transparent colours cover
the other playfield; the transparent one, on the other hand, behaves like a hole and allows
the playfield underneath to be seen.
The maximum number of bit planes that each of the two playfields can have
is three bit planes in LOW-RES and two bit planes in HI-RES. In practice, the six
bit planes of the Amiga are divided into two groups of 3, and each group
constitutes a playfield. Playfield 1 consists of the odd bit planes,
i.e. bit planes 1, 3 and 5. Playfield 2 consists of the even bit planes,
i.e. 2, 4 and 6.
Of course, it is not always necessary to use all the available bit planes.
However, we cannot independently assign the bit planes we want to the 2 playfields.
In fact, the number of bit planes to be used is indicated in exactly the same way as for “normal” graphics modes.
In bits 14-12 of the BPLCON0 register ($dff100), called BPU2, BPU1 and BPU0, the total number of bit planes to be activated in the 2 playfields is indicated.
BPLCON0 ($dff100), called bits BPU2, BPU1 and BPU0, the total number of bit planes to be activated in the two playfields is indicated. Based on the total number
we indicate in the BPU bits, the hardware assigns the bit planes
according to the following table:

Number of bit planes used |
	Bit planes at     |    Bit planes at
(BPU bit of BPLCON0)     |    Playfield 1     |    Playfield 2
----------------------------|---------------------|-------------------
|             |
0         | none     |    none
|             |
1         | plane 1     |    none
|             |
2         | plane 1     |    plane 2
|			 |
3         | plane 1,3     |    plane 2
|             |
4         | plane 1,3     |    plane 2,4
|             |
5         | plane 1,3,5     |    plane 2,4
|             |
6         | plane 1,3,5     |    plane 2,4,6


As you can see in practice, playfield 1 always has more planes than
playfield 2, and furthermore, playfield 2 has at most one plane less than
playfield 1; it is not possible to assign 3 planes to playfield 1 and only one
plane to playfield 2.

Similar to standard graphics modes, the overlapping of the bit planes
determines the colour used to represent each pixel on the screen.
However, the correspondence between bit plane combinations and colour registers is
somewhat different, as illustrated in the following two tables:

PLAYFIELD 1
Value    | Value | Value    | Colour
plane 5    |	plane 3    |    plane 1    | selected
----------------------------------------------------
|        |        |
0    |    0    |    0    | transparent
|        |        |
0    |    0    |    1    | COLOUR01
|        |        |
0    |    1    |	0    | COLOR02
|        |        |
0    |    1    |    1    | COLOR03
|        |        |
1    |    0    |    0    | COLOR04
|        |        |
1    |    0    |    1    | COLOR05
|        |        |
1    |	1    |    0    | COLOR06
|        |        |
1    |    1    |    1    | COLOR07


PLAYFIELD 2
Value    | Value    | Value    | Colour
plane 6    |    plane 4    |    plane 2    | selected
----------------------------------------------------
|        |        |
0    |    0    |    0    | transparent
|        |        |
0    |    0    |    1    | COLOR09
|        |        |
0    |    1    |    0    | COLOR10
|        |        |
0    |    1    |    1    | COLOR11
|        |        |
1    |    0    |    0    | COLOR12
|        |        |
1    |    0    |	1    | COLOR13
|        |        |
1    |    1    |    0    | COLOR14
|        |        |
1    |    1    |    1    | COLOR15


At this point, you know how Dual Playfield mode works. There is only one
thing you don't know...how to activate dual playfield!
It's very simple, just set bit 10 of the BPLCON0 register to 1.
As we have already mentioned, you can choose which of the two playfields appears 
above the other. The playfield that appears above is said to have higher priority.
 There is a bit that determines the priority, bit 6 of the
BPLCON2 ($dff104): if it is 0, playfield 1 appears above 2, if it is
1, playfield 2 appears above 1.

You can see an example of Dual Playfield in lesson 7u.s


PRIORITY BETWEEN SPRITES AND PLAYFIELDS

We have already seen the relative priorities of the various sprites. That is, if two sprites
overlap, the one with the lower number will appear above
the other. We have also just seen how to establish the priority between the two
playfields in Dual Playfield mode. 
Now we just need to see the priorities
between sprites and playfields. First of all, note that sprites always appear
above colour zero. For other colours, the priority is controlled
by the BPLCON2 register. It is possible to set the priority independently for
even and odd bit planes. This is very useful in Dual
Playfield mode, because it allows us to give each playfield a different priority 
with respect to the sprites. In standard mode, however, it is advisable to give the same 
priority with respect to the sprites to even and odd planes. The BPLCON2 register
has some bits in which to write the desired priority level for
even and odd planes. Bits 0 to 2 contain the priority level
of the odd bit planes (which correspond to PLAYFIELD 1 in Dual
Playfield mode) while bits 3 to 5 contain the priority level
of the even bit planes (PLAYFIELD 2 in Dual Playfield mode).
Let's see how the priority level is coded, referring to a
generic playfield, since the coding is identical in both cases.
As for the priorities with the playfields, the sprites are considered in 
pairs (0-1, 2-3, 4-5 and 6-7). As we know, the priority between sprites
(and therefore between pairs) is fixed:

MAXIMUM PRIORITY PAIR 1 (SPRITES 0 AND 1)
PAIR 2 (SPRITES 2 AND 3)
PAIR 3 (SPRITES 4 AND 5)
MINIMUM PRIORITY PAIR 4 (SPRITES 6 AND 7)

The priority level allows us to insert our
playfield into this stack: we can place it above all pairs, below
all pairs, or between two pairs. It is therefore not possible to make
the playfield appear below pair 4 and above pair 2, because
pair 2 is higher than pair 4 in the stack. However,
the opposite is possible. Let's now look at a table showing all the possible
priorities, depending on the level we set in the BPLCON2 bits

CODE | 000 | 001 | 010 | 011 | 100 |
----------------------------------------------------------------------------
PRI. MAX | PLAYFIELD | PAIR 1 | PAIR 1 | PAIR 1 | PAIR 1 |
| PAIR 1 | PLAYFIELD | PAIR 2 | PAIR 2 | PAIR 2 |
| PAIR 2 | PAIR 2 | PLAYFIELD | PAIR 3 | PAIR 3 |
| PAIR 3 | PAIR 3 | PAIR 3 | PLAYFIELD | PAIR 4 |
PRI. MIN | PAIR 4 | PAIR 4 | PAIR 4 | PAIR 4 | PLAYFIELD |

For example, as shown in the table, if we want sprites 0,1,2,3
(i.e. pairs 1 and 2) appear above the playfield and the other sprites
below, we must choose the code %010. This code
must be written in the BPLCON2 register, in bits 0 to 2 if referring to
playfield 1 in dual-playfield,
 in bits 3 to 5 if referring to playfield 2 in dual-playfield mode, while if we are using a normal screen, we 
will have to write it twice, both in bits 0 to 2 and in bits 3 to 5.

In lesson7v1.s you will find an example of how to set the priorities of sprites
with a ‘normal’ screen.

In lesson7v2.s, on the other hand, a Dual Playfield screen is used.



COLLISIONS

The Amiga hardware provides the programmer with a system for
detecting collisions between sprites, between sprites and
playfields, and between the two playfields.
All these types of collisions are managed by only two registers:
CLXDAT ($dff00e), which is a read-only register in which collisions are reported, and CLXCON ($dff098), which is a control register
that can be used to modify the way collisions are detected.
Let's start by illustrating the structure of these registers.
The bits of the CLXDAT register behave like collision detectors. Each bit is dedicated to a particular type of collision. When a collision of a given type occurs, the bit dedicated to it in CLXDAT is set to 1.
The bits in the CLXDAT register act as collision detectors.
Each bit is dedicated to a particular type of collision. When
a collision of a certain type occurs, the bit dedicated to it in
CLXDAT takes the value 1. When the collision no longer occurs, the bit
returns to the value 0. The following table shows the meaning of the
bits in CLXDAT:

USE OF CLXDAT BITS

bit 15 not used
bit 14 collision between pair 3 and pair 4
bit 13 collision between pair 2 and pair 4
bit 12 collision between pair 2 and pair 3
bit 11 collision between pair 1 and pair 4
bit 10 collision between pair 1 and pair 3
bit 9 collision between pair 1 and pair 2
bit 8 collision between playfield 2 and pair 4
bit 7 collision between playfield 2 and pair 3
bit 6 collision between playfield 2 and pair 2
bit 5 collision between playfield 2 and pair 1
bit 4 collision between playfield 1 and pair 4
bit 3 collision between playfield 1 and pair 3
bit 2 collision between playfield 1 and pair 2
bit 1 collision between playfield 1 and pair 1
bit 0 collision between playfield 1 and playfield 2

The CLXCON register has the following structure

USE OF CLXCON BITS
bit 15 enables sprite 7
bit 14 enables sprite 5
bit 13 enables sprite 3
bit 12 enables sprite 1
bit 11 enables bit plane 6
bit 10 enables bit plane 5
bit 9 enables bit plane 4
bit 8 enables bit plane 3
bit 7 enables bit plane 2
bit 6 enables bit plane 1
bit 5 collision value bit plane 6
bit 4 collision value bit plane 5
bit 3 collision value bit plane 4
bit 2 collision value bit plane 3
bit 1 collision value bit plane 2
bit 0 collision value bit plane 1

(note: where it says ‘enable’, this means ENABLE FOR DETECTION
COLLISIONS: if, for example, bit 15 of CLXCON is 0, this does NOT mean that
sprite 7 cannot appear on the screen, but only that collisions
involving sprite 7 are not detected)

We will explain the meaning of these bits a little at a time.
Let's start by talking about collisions between sprites.
Let's say right away that, even when it comes to collisions, sprites
are considered at the pair level.
In fact, it is only possible to detect collisions between sprites belonging to
different pairs, and not between sprites belonging to the same pair.
For example, it is not possible to detect a collision between sprite 0 and sprite 1.
However, collisions between sprites belonging to different pairs are detected.
For example, if a collision occurs between sprite 0 and sprite 2, bit 9 of
CLXDAT (collision between pair 1 and pair 2) takes the value 1. If
a collision occurs between sprite 1 and sprite 2, since sprite 1
also belongs (like 0) to pair 1, bit 9 will always take the
value 1. However, this will not always happen.
In fact, collisions involving even-numbered sprites (i.e. sprites 0, 2, 4 and 6) are always detected, but collisions involving odd-numbered sprites are only detected if we want them to be. To enable
an odd-numbered sprite for collision detection, we must set the corresponding enable bit in the CLXCON register to 1.
You can see which bits these are in the table above. Odd-numbered sprites can be enabled independently of each other.
 You can see which bits these are in the table above. Odd spritescan be enabled independently of each other. 
Enabling one
or more odd sprites for collision detection has advantages and
disadvantages. Let's consider only pairs 1 and 2, and suppose
that neither sprite 1 nor sprite 3 is enabled. In this case,
if a collision occurs between sprites 0 and 2, bit 9 (of CLXDAT)
takes the value 1. If, on the other hand, the collision occurs between sprites 1 and 2,
or between 0 and 3, or between 1 and 3, nothing happens, and we cannot
know that the collision has occurred.
Let's suppose instead that we have enabled one of the odd sprites, for example
sprite 1. In this case, collisions between sprites 0 and 2 and between sprites 1 and 2
set bit 9 of CLXDAT to 1, while collisions between sprites 0 and 3 and between
sprites 2 and 3 have no effect. In this situation, there is a
disadvantage compared to the previous case, where sprite 1 was not enabled.
In fact, in the previous case, if bit 9 took the value 1, we were sure
that the collision had occurred between sprite 0 and sprite 2. In the present case,
 however, there are two possibilities: either there is a collision between sprite 0 and 2 or between
sprite 1 and 2. There is no way to solve the puzzle by reading the
CLXDAT register.
If sprite 1 is disabled but sprite 3 is enabled, we have a
similar situation, in that collisions are detected between sprite 0 and 2
and between sprite 0 and 3, but we cannot distinguish which of the two occurred
.
Finally, if both sprite 1 and 3 are enabled,
collisions are detected between sprite 0 and 2, between sprite 0 and 3, between sprite 1 and 2, and
between sprite 1 and 3, and there is no way to distinguish between them.


An example of a collision between sprites, with odd sprites disabled for
collision detection, is in lesson7w1.s. Load it and check how it works.
An


example of a collision between sprites with an odd sprite enabled is in
lesson7w2.s.
 You will notice that this example does not work as it is; to make it work, you will need to follow the changes indicated in the comment.
In this example, to distinguish whether a collision involves the odd sprite
enabled, or the even sprite paired with it, a technique
based on comparing positions is used, as illustrated in the comment.


Now let's look at collisions between sprites and the playfield.
It is possible to detect a collision between a pair of sprites and one or more
colours of the playfield. Again, collisions are detected
by considering pairs of sprites rather than individual members of the pair.
Enabling odd sprites via the CLXCON register bits also
has an effect in this case.
Collision detection works differently if we are using a
normal screen or Dual Playfield. With a normal screen, bits 1 to 4
of CLXDAT indicate a collision between a pair of sprites and the colour (or colours)
we have chosen for collision. Bit 1 indicates a collision between
the playfield and pair 1, bit 2 between the playfield and pair 2, bit 3 between
the playfield and pair 3, and bit 4 between the playfield and pair 4. Bits 5 to 8
should not be used.
In dual playfield mode, it is possible to detect a collision between one
of the two playfields and a pair of sprites, and the CLXDAT bits are used as
indicated in the CLXDAT register table: bits 1 to 4 indicate
collisions between playfield 1 and the various pairs of sprites, while bits 5 to 8
indicate collisions between playfield 2 and the various pairs of sprites.
To choose the colours with which to detect collisions, use the
CLXCON register. Let's start with the case of a single colour.
Bits 6 to 11 of CLXCON indicate which bit planes are active
for collisions. If we want to detect collisions between sprites and
a single colour, we must enable all bit planes that
are displayed for collisions. The colour used to detect a collision
is selected by writing the number of the register containing the
colour in bits 0 to 5 of CLXCON.
For example, suppose we have a normal 16-colour screen (4 bit planes)
and we do not want to consider collisions of odd sprites.
If we want to detect a collision between a sprite and colour 13, we must
write the value

111111
5432109876543210
$03cb=%0000001111001101

Let's look at the meaning of the bits. Bits 12 to 15 disable odd sprites
. Of bits 6 to 11, only bits 6, 7, 8, and 9 are set to 1. This indicates that
only bit planes 1 to 4 are enabled for collisions. These are the
only active bit planes. Bits 0 to 5 contain the number %001101=13, i.e.
the number of the register we are interested in. In the Dual Playfield case, the
situation is the same, except that by activating all the bit planes used for
collisions, collisions with two colours are enabled simultaneously:
for example, if with two playfields of eight colours each we want to enable
collision detection for colour 7 of playfield 1 and colour 2
of playfield 2, we must write the number

111111
5432109876543210
$0fbb=%0000111111011101

This combination of bits indicates that all bit planes are enabled for
collision detection (all bits from 6 to 11 are 1).
Furthermore, the colour number used for playfield 1 is given by bits
0, 2 and 4, which, when placed side by side, form the number %111=7, while the colour number
used for playfield 2 is given by bits 1, 3 and 5, which, when placed side by side,
 form the number %010=2.
Note that the collision of a sprite with a playfield 1 colour
causes a CLXDAT bit to be set, which is different from the case of collision of the
same sprite with a playfield 2 colour.
 For example, as you can see in the CLXDAT register table, the collision between sprite 0 and
playfield 1 sets bit 1 of CLXDAT to 1, while the collision between sprite 0 and
playfield 2 sets bit 5 of CLXDAT to 1.

It is also possible to detect collisions of a sprite with more than one colour
at the same time, although only under certain conditions.
To understand how this is possible, we need to consider the binary representation
of the colour register numbers.
As you know, there are 32 colour registers numbered from 0 to 31.
The possibility of detecting collisions with two colours at the same time is based
on the fact that the representations of some binary numbers are similar.
For example, consider the numbers 2 and 21.
In binary, we have 2=%00010 and 21=%10101 (considering 5 bits to be able to write
numbers up to 31).
As you can see, the binary representations of these two numbers are completely
different.
There is therefore no way to detect collisions with both colours
at the same time.
Let's consider the numbers 22 and 23 instead.
Now let's look at their binary representations: 22=%010110 and 23=%010111.
The representations of the two numbers differ only by one bit, the lowest bit.
In this case, it is possible to detect collisions with both colours.
In fact, the value of the lowest bit (which in this case differentiates the colours)
is given by bit plane 1.
If we do NOT enable bit plane 1 for collision detection, only the values of bit planes 2, 3, 4 and 5 will be taken into account (we are on a
32-colour screen, so there are 5 bit planes in total), and the value assumed by
bit plane 1 will have no influence.
Let us therefore write the value in CLXCON: 111111 5432109876543210 CLXCON= %0000011110010110

111111
5432109876543210
CLXCON= %0000011110010110

This means that the collision will be detected based only on the
enabled bit planes (i.e. 2, 3, 4 and 5) and precisely when our
sprite overlaps a pixel that has:

bit plane 1=(0 or 1) because it is not enabled
bit plane 2=1
bit plane 3=1
bit plane 4=0
bit plane 5=1

As we have seen, both the binary representation of 22=%010010
and that of 23=%010111 have this particular bit configuration,
therefore both colours cause a collision when the sprite passes.
Note that the bitplane that we have NOT enabled (1) corresponds
precisely to the only bit that differentiates the binary representations of 22 and
23.
This technique can be applied to any pair of colours whose
binary representations differ by a single bit. For example, the
numbers 8=%001000 and 9=%001001 also differ in the lowest bit, so
to detect collisions between the sprite and these two colours, bit plane 1 must also be disabled.
 If we consider the colours 10=%001010 and 14=%001110,
we notice that the two binary representations differ in bit 2 (we number the
bits from right to left starting from 0), which corresponds to bit plane 3.
To detect collisions between the sprite and these two colours, bit plane 3 must be disabled
and therefore the value shown below must be assigned to CLXCON:

111111
5432109876543210
CLXCON= %0000011011001010 ; bit 8=0 indicates bit plane 3 NOT enabled

If we disable 2 bit planes, we can detect collisions between 4 colours.
The principle is always the same. Let's take the colours:

1=%00001
3=%00011
5=%00101
7=%00111

These 4 colours have bits 0, 3 and 4 in common, while they differ
in that each colour has a different combination of values in bits 1 and 2.
To detect collisions between a sprite and all 4 of these colours, simply
disable bit planes 2 and 3, which correspond to bits 1 and 2.
By disabling 3 bit planes, collisions with 8 colours can be detected
simultaneously, and by disabling 4, with 16 colours.
Even when operating in Dual Playfield mode, it is possible, for each playfield,
to disable some bit planes to detect collisions between the sprite and 
more than one colour for each playfield (remember that if we need to detect a
collision between the sprite and 2 colours that belong to playfield 1
and one to playfield 2, this is not necessary, because in CLXDAT we have
a bit for each playfield that allows us to detect collisions with both playfields simultaneously
).


In lesson 7x1.s, we see an example of a collision between a sprite and
a playfield in ‘standard’ mode.


In lesson 7x2.s, there is an example with Dual Playfield mode.
In both listings, the comments show several examples of how to
detect collisions with more than one colour at a time.


The last type of collision is between playfield 1 and playfield 2, obviously in
Dual Playfield mode. It is possible to detect a collision between one or
more colours of playfield 1 and one or more colours of playfield 2 by enabling
only certain bit planes using exactly the same procedure as in the case of 
a collision between a sprite and a playfield.
When a collision between the two playfields is detected, bit 0 of CLXDAT
takes the value 1.


An example of this type of collision is in lesson7x3.s



DIRECT USE OF SPRITE REGISTERS

We will now look at a different method of using sprites. So far, we have
generated sprites using SPRxPT registers, which are pointers to
data structures (called sprite structures) that contain all the
information necessary to display the sprites. However, there is
another method for creating sprites that can be used as an alternative or
in addition to the pointer method. We will call this new method
‘direct use of sprites’. Direct use of sprites is not convenient
in most cases, but it can sometimes be useful.
To understand what this is all about, we need to take a closer look at
sprite display.
When we store the address of a sprite structure in an SPRxPT register
(according to the ‘standard’ technique for using sprites),
 we activate an automatic procedure that allows the sprites to be
actually displayed. In fact, the data on the position and shape that we
have stored in the sprite structure are transferred
automatically, through a hardware ‘mechanism’ called DMA, to
special registers, different from the SPRxPT registers; it is precisely the writing of the
data in these registers that ACTUALLY allows the sprites to be displayed
. We will talk more about DMA, which is a very important tool in the Amiga,
in a later lesson. For now, it is enough to know the role it
plays in the display of sprites. In practice, it behaves like
a postman. Imagine that the data structure of the sprite you have
built in memory is a pile of letters addressed to different
recipients (registers). The DMA takes care of delivering these letters to
their destination, sorting them among the various recipients.
The direct use of sprites consists, in fact, of writing
the sprite data directly into the appropriate registers, i.e. delivering the letters “in person”
to the various recipients, stealing the DMA's job. Since
the DMA does its job for free, you may wonder what the point of this
technique is. In fact, as we have already said, it does not usually offer
any advantages; 
however, in some cases it can be useful.
Let's see what this technique consists of. As we have already said, the
sprite data is written directly to certain registers. There are 4
registers for each sprite, called SPRxPOS, SPRxCTL, SPRxDATA, SPRxDATB (
instead of the x you must put the number of the sprite you want to use).
The addresses of these registers depend on the sprite you are referring to.
 We can calculate them with simple formulas. With ‘x’
we indicate the sprite number, from 0 to 7.

SPRxPOS address = $dff140+(x*8)
SPRxCTL address = $dff142+(x*8)
SPRxDATA address = $dff144+(x*8)
SPRxDATB address = $dff146+(x*8)

You can also search for them using the ASMONE help ‘=C’.

Now let's describe how these registers are used. The shape of a sprite is
written in the SPRxDATA and SPRxDATB registers, which constitute the two small 
bit planes of the sprite (SPRxDATB is plane 2). These registers have the
same role as the pairs of words that define the shape of a sprite line
in the sprite structure. Note that for each sprite there are two registers
containing data relating to a SINGLE sprite line. The horizontal position
of a sprite, as you know, consists of nine bits, called H0, H1 
.. H8.
 These 9 bits are divided into two registers: the H0 bit, i.e. the low bit, is located in bit 0 of the SPRxCTL register. 
The other 8 are in the low byte of the SPRxPOS register. In short, these two registers behave,
as far as the horizontal position is concerned, exactly like the two control words of the sprite structure.
The vertical position, on the other hand, is not determined with this technique, because sprites behave in a rather strange way.
To be displayed, a sprite must be activated. This happens when you write to the SPRxDATA register. Once activated, the sprite is displayed on every line in the horizontal position indicated.
To be displayed, a sprite must be activated.
This happens when you write to the SPRxDATA register.
Once activated, the sprite is displayed on each line in the horizontal position
indicated, as we have just seen, in the SPRxPOS and
SPRxCTL registers. The shape of the sprite for each line is that contained in the
SPRxDATA and SPRxDATB registers.
Therefore, if the contents of these registers are not changed on each line,
the sprite will have the same shape on each line.
The sprite is displayed until it is deactivated by writing to the
SPRxCTL register.
To display a sprite that changes shape on each line, you should therefore
use a copperlist made in this way:
(let's assume we are using sprite 0 and that VSTART=$40, VSTOP=$60, HSTART=$160)


dc.w    $4007,$fffe    ; WAIT - wait for the VSTART line
dc.w    $140,$0080    ; SPR0POS - horizontal position
dc.w    $142,$0000    ; SPR0CTL
dc.w    $146,$0e70    ; SPR0DATB - sprite shape row 1, plane 2
dc.w    $144,$03c0    ; SPR0DATA - sprite shape row 1, plane 1
; also activates display, for
; this must be written last.

dc.w    $4107,$fffe    ; WAIT - wait for line VSTART+1
dc.w    $146,$0a70    ; SPR0DATB - sprite shape row 2, plane 2
dc.w    $144,$0300    ; SPR0DATA - sprite shape row 2, plane 1

dc.w    $4107,$fffe    ; WAIT - wait for line VSTART+2
dc.w    $146,$0a7f    ; SPR0DATB - form sprite row 3, plane 2
dc.w    $144,$030f	; SPR0DATA - sprite shape row 3, plane 1

; repeat for each row Y
;    dc.w    $40+Y07,$fffe    ; WAIT - wait for line VSTART+Y
;    dc.w    $146,DATOY2	; SPR0DATB - sprite shape row Y, plane 2
;    dc.w    $144,DATOY1    ; SPR0DATA - sprite shape row Y, plane 1
; replacing DATOY1 and DATOY2 with the sprite shape data.

dc.w    $6007,$fffe    ; WAIT - wait for the VSTOP line
dc.w    $142,$0000    ; SPR0CTL - disable the sprite

As you can see, for fairly tall sprites, a very long and complicated copperlist is required.
 In this case, it is definitely better to use DMA.
However, let's suppose we need to display a sprite that has the same shape
on every line. For example, a sprite representing a column. In this
situation, our copperlist becomes very simple and short:

(let's assume we are using sprite 0 and that VSTART=$40, VSTOP=$60, HSTART=$160)


dc.w    $4007,$fffe    ; WAIT - wait for the VSTART line
dc.w    $140,$0080    ; SPR0POS - horizontal position
dc.w    $142,$0000    ; SPR0CTL
dc.w    $146,$0e70    ; SPR0DATB - sprite shape line 1, plane 2
dc.w    $144,$03c0	; SPR0DATA - sprite shape row 1, plane 1
; also activates display, for
; this must be written last.

dc.w    $6007,$fffe    ; WAIT - wait for the VSTOP line
dc.w    $142,$0000    ; SPR0CTL - deactivates the sprite

Note that our copperlist, besides being short, does not vary with the height
of the sprite.
On the contrary, if we wanted to use DMA to display this sprite, we would be
forced to store in the data structure the 2 words representing the
shape as many times as there are lines that make up the sprite.
Consider the case where you need to display a column 100 lines high.
If we used DMA, we would have to store a sprite structure that takes up a lot of
memory:

SpriteStructure:
dc.b    VSTART,HSTART,VSTOP,0
dc.w    $ffff,$0ff0    ; line 1
dc.w    $ffff,$0ff0    ; line 2
dc.w    $ffff,$0ff0    ; line 3
dc.w    $ffff,$0ff0    ; line 4
dc.w    $ffff,$0ff0    ; line 5
dc.w    $ffff,$0ff0	; line 6
dc.w    $ffff,$0ff0    ; line 7
dc.w    $ffff,$0ff0    ; line 8....

 and so on, until:

dc.w    $ffff,$0ff0    ; line 99
dc.w    $ffff,$0ff0    ; line 100
dc.w    0,0        ; end sprite


With direct use of sprites, however, a simple copperlist is sufficient:

dc.b    VSTART,7,$ff,$fe    ; WAIT - wait for the VSTART line
dc.w    $140
dc.b $00,HSTART	; SPR0POS - horizontal position
dc.w    $142,$0000    ; SPR0CTL
dc.w    $146,$ffff    ; SPR0DATB - sprite shape line 1, plane 2
dc.w    $144,$0ff0	; SPR0DATA - sprite shape row 1, plane 1
; also activates display, for
; this must be written last.

dc.b    VSTOP,7,$ff,$fe    ; wait for the VSTOP line
dc.w    $142,$0000    ; SPR0CTL - deactivates the sprite



A simple example of direct use of sprites is shown in lesson7y1.s.


In the programme lesson7y2.s, on the other hand, using sprites in direct access
we create vertical bars similar to those made
horizontally with the copper.


With the direct use of sprites, it is also possible to display
the same sprite multiple times on the same line. The method is explained and
applied in lesson7y3.s. Sprites generated multiple times on the same line
are also called MULTIPLEXED, i.e. ‘multiplexed’.
So we started by saying that there are only 8 sprites, but we have
seen that the assembler allows us to multiply sprites and also make them
take on many more colours than the standard ones, changing the palette several times
even horizontally. The only drawback is that it requires
very long copperlists, but it is definitely worth it.


Developing this idea further leads us to create a complete screen
using sprites, as shown in the example Lesson7y4.s.

To do this, however, we need to write a very long copperlist,
and to make it easier to understand, we have used SYMBOLS or EQUATES, an
assembler language directive that allows us to call a fixed number with a name of our choice,
 so that when we write the name, the
corresponding number is assembled.
Let's take this example: we want to access the COLOR0 register,
which, as we know, is $dff180. We can write:

move.w    #$123,$dff180

But if we wanted to, we could also write it like this:

COLOUR0        EQU    $dff180        ; Definition of a symbol

move.w    #$123,COLOUR0

In practice, we have defined that when the assembler finds COLOUR0 written, it must
assemble as if it had found $dff180. It is as if we were defining a label.
In fact, we have to invent a name and write it without preceding it with spaces, but
there is no need for : (in reality, you can also put :, in the same way
labels could have : or not have them, the ASMONE assembles anyway, but
some assemblers prefer LABELS to be followed by : and
symbols (or equates) not to have them). EQU means EQUAL TO.
Almost all assemblers also accept the = symbol instead of the
EQU symbol for the definition. Let's take another example:

NUMEROLOOP    =	10

MOVEQ    #NUMEROLOOP-1,d0
Loop:
clr.l    (a0)+
dbra    d0,NUMEROLOOP
rts

With this listing, we reset 10 longwords. The usefulness of EQUATES is that
we can put them all at the beginning of the listing, so that if we want to
modify certain values, such as how many loops to make or how many bitplanes
to point to, we just need to modify the value of the symbol after the = or EQU at the beginning
of the listing. It is also possible to perform operations between symbols. A practical example
could be calculating the space to be reset for a bitplane:

BytesPerLine    =    40
NumberOfLines    =    256
BitplaneSpace    =    BytesPerLine*NumberOfLines

...

section plane,bss_C

Bitplane:
ds.b    BitplaneSpace

In the listing, BitplaneSpace is equal to 10240, i.e. 40*256.
In Lesson7y4.s, symbols are defined for the copperlist.


Finally, in lesson7y5.s, we will scroll through the screen formed by the sprites and
take the opportunity to learn two new 68000 instructions, called
ROR and ROL. We will explain them in the comments to the listing.


SPRITE ANIMATION

We conclude this lesson with an explanation of sprite animation.
Let's now return to “normal” sprites, i.e. those generated using
SPRxPT pointers and the DMA. To animate a sprite, you need to change its
shape every time it is redrawn. Each shape assumed
by the sprite is called an “animation frame”.
Animation is usually done in such a way as to have a certain sequence of
frames that is continuously repeated.
Think, for example, of a little man walking across the screen; you will notice that 
all his steps are the same.
To animate a little man walking across the screen, a certain number of
frames are drawn which, when viewed in succession, depict a complete step
by the little man. When the little man has completed the step, he must start a new one:
at this point, the same frames are shown again, starting from the
first. By repeating the same frames for each step, we can 
show the little man walking for as long as we want, with a limited number
of frames (obviously, since the frames are images,
they take up memory, so you should try to use as few as possible).
So far, this applies to any animated object, and it is a good idea to
 
keep this in mind when we discuss animations created 
using blitters. Now let's look at animations created using 
sprites. This means that we have a sprite that moves on the screen and
takes on a different shape each time it is redrawn. This is usually
done as follows: for each frame, a sprite structure is created,
and each time the sprite is redrawn, the SPRxPT register
is pointed to a different frame (i.e., to a different data structure). The position
of the sprite is written each time in the frame structure to which
SPRxPT is pointed.

A practical example can be found in lesson7z.s

This example also concludes lesson 7 and DISK 1 of the course.
At the time of writing (May 1995), disk 2 is not yet complete,
 but the topics covered are:

- BLITTER (copymode, linemode and fill)
- Interrupts, CIAA/CIAB, loading from disk, keyboard
- Audio
- More on the 68000, a look at the 68020
- Video game programming
- Math routines (3D, fractals)
- AGA chipset
- Compatibility and optimisations
- Programming the PICASSO II video card!!!!

I don't know if I'll have time to finish such a huge job. Even this first
disc (which, to be honest, didn't cover that many topics) seemed endless to me.
I must thank Luca Forlizzi (The Dark Coder) for helping me finish LESSON 7, and also the two willing beta testers, ANDREA SCARAFONI and FEDERICO STANGO, who pointed out where I wasn't clear, or even where I had made mistakes.
helping me finish LESSON 7, and also the two willing beta testers
ANDREA SCARAFONI and FEDERICO STANGO who pointed out where I wasn't
clear, or even where I had written incomprehensible sentences.
Unfortunately, I can't thank those who only PROMISED to help me but
then disappeared, such as Alvise Spanò (AGA/LUSTRONES).

To receive disc 2, or at least what I have managed to do in time,
you can write me a letter, or better still, send me a disc with your
programmes:

Fabio Ciucci
Via S.Leonardo n.13
55100 LUCCA

Don't write to me until you have really assimilated everything on
this disc; you don't become a programmer just by having lists.
In the meantime, copy this disc for everyone; everyone must have it, even the
Pope when he looks out from his balcony... anyone with an Amiga in Italy must
have this disc. And don't just give it to those you think might be interested,
because I've found that those who have followed the course and learned the
most are those I least expected to do so. Just think, the most
advanced here in Lucca is a young man, Michele, whom I gave the disc to
so he could copy it for a friend of his who seemed interested.
 I didn't hear from them for a couple of months, then Michele showed up at my house with a
preview of his game!!! While his friend was still stuck!
So spread this disc around like flyers for your political party
or pamphlets for your religion, write announcements on notice boards
or in your school or university newspapers to let everyone know that
you have the disc to learn how to program the Amiga, give copies of the disc
to Amiga dealers in your area and ask them to give them to anyone who asks
for information about Amiga programming. In short, evangelise (assemble)
this poor country!

When the time comes for disc 2, I hope to have finished it,
but I'll send you what I have anyway. You should send me a normal letter
costing 750 lire with a brief introduction including your age, distinguishing features, computer
you own, aspirations and whatever else you like, with your address, of
course. At the same time, you should send me a postal order for a donation of your choice,
minimum 10,000 (so far, almost everyone has sent me 10,000, some 20,000,
then increasingly rare 30,000 and a legendary 60,000 from a Genoese, just to
dispel the myth that they are stingy). In the letter, you must specify how much
you have sent me by postal order, because letters and postal orders usually arrive at
slightly different times. I hope there won't be any galactic delays for the PT.

Otherwise, you can do it this way: you can send me a diskette with
the letter in .txt format, and maybe some of your lists or other stuff to
fill up the disk. Please note that it is best to put the diskette in a
small shipping envelope and seal it only with the sample fastener or
the envelope's own sticker, without putting any papers or letters other than the
diskette inside. In short, you don't have to seal everything with adhesive tape or anything else,
this is to allow postal inspection, which they never do anyway, but
if the package is like this, you pay less.
You should then write “pacchetto” (small package) on the envelope and tell the (hopefully) friendly
post office clerk that it is a package without any letters
inside, and this will save you money compared to a sealed parcel with a letter,
which counts as a “HEAVY LETTER”!
A package like this with only one disc should cost 1200 lire.
If you want it to arrive sooner, you can send it by express delivery, adding 3000 lire, but
then you should calculate how long you need to finish disc 1 and
send it in time... what kind of programmers are you if you're not smart?
NOTE: If you want me to send you disc 2 by express delivery, you can do the calculations
as before, or start from a minimum base of 13,000 lire and indicate in the
letter (paper or .txt) that you want disc 2 by express delivery.

A final option would be to put the money in cash in the
letter or package, but it must be placed so that it cannot be seen through
the envelope, and the package should then be sealed... you decide
how to proceed, but I think a letter or package + money order is best.

Any donations or contacts will encourage me and my “collaborators” to
continue the work of writing this course. We would also greatly appreciate
any offers of collaboration from experienced programmers,
especially those who have programmed games (I know all the demo makers
here in Italy, the scene is like a family, with
family quarrels, though!).

I must also point out the best Amiga user club, where you may find
other programmers, graphic designers or musicians for collaboration:

Amiga Expert Team

Mirko Lalli
Via Vecchia Aretina 64
52020 Montalto
Pergine V.no
AREZZO
