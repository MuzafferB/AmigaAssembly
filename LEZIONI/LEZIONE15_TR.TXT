
*************************************************************
*                DERS 15: AGA                 *
*************************************************************

Bu, A1200 ve
A4000'de bulunan yeni AGA yonga seti hakkında merakla beklenen ders. Amiga4000 1992'nin sonunda piyasaya çıktığında, bir arkadaşım
hemen satın aldı ve ben de onun evine taşındım, o kadar ki, onu
onun kadar ben kullandım. O ilk aylarda, işletim sisteminin bakır listelerini
ve KickStart'ın bütün parçalarını parçaladım, çünkü defnedilmiş Commodore
AGA hakkında kimseye dokümantasyon vermiyordu. Garip ama gerçek. Her neyse, denemeler sonucunda
bir şeyler anlamaya başladım, ama AGA iffconverter de yoktu ve
IFF'den RAW'a resimleri elle “dönüştürmek” zorunda kaldım. O zamanlar AGA ekranlarını görüntüleyebilen tek program
yeni DeLuxePaint idi, bu yüzden
256 renkli bir resmi yükledim, sonra çoklu görev modunda asmone'yi yükledim ve
hafızada .raw resmi ve copperlist'i bulup kaydetmeye çalıştım.
Daha sonra raw'ı yeniden yükledim, copperlist'e yönlendirdim ve
parmaklarımı çaprazladım. Yine de AGA demosunu ilk yapan ben olamadım
, ilk yapan ABYSS oldu, küçük bir demo 
kader belirleyen 256 rengi görüntüleyen küçük bir demo. Olağanüstü bir şey değildi, ama ilkler onlardı.
AGA'yı keşfetme konusunda Abyss ile hemen hemen aynı noktadaydım,
ve cesaretimi kaybetmedim. Artık Şubat 1993'tü, 640*256 çözünürlükte ve 256 renkte, 1/4 piksel akıcılıkla dalgalanan bir logolu bir intro
hazırlamıştım (yeni BPLCON1'i kullanarak), tam o sırada ilk GERÇEK AGA demosu çıktı, yani
TEAM HOI'nin PLANET GROOVE'u.
Hemen Hollanda'daki BBS'lerini aradım ve kodlayıcı Rhino'ya bir mesaj bıraktım. O günden itibaren
Hemen Hollanda'daki BBS'lerini aradım ve kodlayıcı Rhino'ya bir mesaj bıraktım.
O günden itibaren aramızda (pahalı) mesajlaşmalar başladı ve
en son keşiflerimizi ve bilinmeyen son bitlerin işlevlerini paylaşıyorduk.
Kısa bir süre önce ZOOL AGA çıkmıştı, ama aslında AGA ile hiçbir ilgisi yoktu
, bu yüzden tek düzgün AGHIZZATO kodu Rhino'nun demosuydu. Rhino
aynı zamanda bir Iffconverter AGA (ilk çıkan) programladı ve ben de onu büyük bir zevkle kullandım
.
1200'ün donanımı hakkında hiçbir belge olmadığı ve
dolayısıyla AGA demosu veya oyunu görülmediği için, Rhino ile birlikte keşfettiğim bilgileri
bir AGADOC.TXT dosyasında topladım, ama onu BBS'lerde dağıtmaya
hazır olduğumda, Fransız bir kodlayıcı olan Yragael'in yazdığı hard1200.txt adlı küçük bir metin çıktı.
Bu metinde bilmediğim bazı şeyler vardı
ama benim bildiğim birçok şey eksikti.
 Fransa'daki birkaç BBS'yi aradım ve onu buldum. Onun da AGA için bir
iffconverter programladığını ve 64 piksel genişliğindeki sprite'ları da kaydettiğini öğrendim.
Bu tarihi IffConverter, kursun yardımcı program diskinde bulunmaktadır.
Tüm bilgileri bir araya getirdim ve 68020 hakkında bilgilerle dolu
güzel bir metin hazırladım. Bu metin bbs'lerde ve
partilerde dolaştı. Teorik olarak bir aga demosu yapmaya hazırdım ve
1993 Ekim'inde Milano'daki SMAU için bir tane yaptım, ama aslında bu bir demo
“çok teknik” bir slayt gösterisi (2 haftada programladım, her şeyi
son dakikada yaparım!). Yine de 256 renkli
entrelaced yüksek çözünürlüklü resimler, 24 bit AGA fade (sinemadaki gibi!) ve
HAM8 (sanırım bir demoda gösterilen ilk HAM8 figürüydü!!!) ve
çok başarılı olan 24 bitlik bir “çapraz” fade efekti vardı.
Günümüzde çok sayıda AGA demosu çıkıyor ve SUPER STARDUST veya BRIAN
THE LION gibi oyunlar nihayet yeni olanakları kullanıyor.
İlk İtalyan AGA demosunu programlamış olmama rağmen, sonra “durdum”
ve hiçbir şey yapmadım, o kadar ki son yaptığım demo A500 içindi.
Neden? Bilmiyorum.
Yine de AGADOC.TXT ve birkaç tavsiyemle
ikinci İtalyan AGA demosunun, yani EXECUTOR/RAM JAM tarafından programlanan ve çeşitli doku eşlemesi içeren IT CAN'T BE DONE'un
programlanmasına katkıda bulundum.
Executor, demosunda bana verdiği yardım için teşekkür ederken,
 ilk yabancı AGA demolarının çok azında bana selamlar
ama sanırım çoğu benim değerli (en azından o zamanlar)
agadoc'umu kullanmıştır.
Bir süre sonra Commodore, AGA özellikleri kılavuzunu
yazılım şirketlerine göndermeye başladı, bu yüzden biri onu “çaldı” ve
kopyaladı (COMBAT 18'di), sonuç olarak benim agadoc'um daha az
“özel”.
Bu, AGA'nın keşif hikayesiydi, burada kendimi ilk
10 öncü arasında sayabilirim, ancak hala bunun değip değmediğini merak ediyorum, çünkü
birkaç ay sonra herkes güzel ve hazır belgeleri okuyarak beni geçti.
İlk AGADOC'umun İtalyanca çevirisini sunuyorum, çünkü
onu İngilizce yazdım. Öncelikle, AGA görüntülerini görüntülemek için 68020 komutlarını kullanmak gerekmediğini belirtmek gerekir, tüm komutları 68000 temel komutlarıyla bir AGA demosu yapılabilir.
İngilizce yazdığım için İtalyanca çevirisini sunuyorum.
Öncelikle, AGA görüntülerini görüntülemek için
68020 komutlarını kullanmaya gerek olmadığını belirtmek gerekir, tüm komutları
68000 tabanlı bir aga demosu yapılabilir, çünkü farklar COPPER'da. Bu,
68020 komutlarını desteklemeyen TRASH'M'ONE ile de programlama yapabileceğiniz anlamına gelir,
ancak bunları kullanacaksanız, Utility diskinde bulunan TFA ASMONE 1.25'e geçmeniz daha uygun olacaktır.
 Bu programda, TRASH'M'ONE'da olduğu gibi aga kayıtları için çevrimiçi yardım da bulunmaktadır,
 ancak “=C” yerine “=R” kullanmanız gerekir. Örneğin,
 $dff106 (BPLCON3) kaydını görmek için “=R 106” yazmanız yeterlidir.
Aga'yı “devre dışı bırakma” yöntemini daha önce görmüştük:

move.w    #0,$1fc(a5)        ; FMODE - 64/32 bit getirmeyi devre dışı bırakır.
move.w    #$c00,$106(a5)        ; BPLCON3 - 24 bit paleti devre dışı bırakır
move.w    #$11,$10c(a5)        ; BPLCON4 - normal palet.

Peki, şimdi hepsini nasıl etkinleştireceğimizi görelim!
Öncelikle, yeni olanakların bir özetiyle başlayalım, böylece bunları nasıl kullanacağınızı öğrenmek için heveslenirsiniz
: palet artık 12 bit, yani 4096
renk yerine 24 bit, yani 16 milyon renge çıkarıldı.
Daha önce her RGB bileşeni için 0 ile 15 arasında bir sayı seçilebiliyorken
artık 0 ile 255 arasında bir sayı seçilebiliyor.
Yani: 16*16*16=4096 renk mümkündü OCS ve ECS eski modunda,
256*256*256=16777216 renk arasından seçim yapabilirsiniz AGA'da.
Örneğin, önceden en fazla 16 gri tonu yapabilirdiniz, yani
renk kayıtlarına $0000, $0111, $0222, $0333 vb. girilirdi, şimdi ise
256 gri tonu yapılabilir.
Kullanılabilir bit düzlemleri de artmıştır, artık
8, yani 256 renk olabilir. (8 bit=256 olasılık).
Ekran üzerinde “teorik” olarak 262144 renk içeren özel bir HAM8 modu da mevcuttur,
ancak normal HAM6'ya benzer bazı sınırlamalar (hafif “bulanıklıklar”) vardır.
HAM8, 8 bit düzlemli HAM anlamına gelirken, HAM6 normal 6 bit düzlemli HAM'dır.
Yeni Dual Playfield, playfield başına 4 bit düzlemine kadar (bir playfield 16 renk,
 diğeri 16 renk) sahip olabilir ve 256 renk paletindeki 16 renk bankası
her oyun alanı için bağımsız olarak seçilebilir.
Bu da yetmezmiş gibi, sprite'lar da “gelişti”.
16 piksel genişlik sınırını hatırlıyor musunuz? Artık 8 sprite
her biri 32 veya 64 piksel genişliğinde olabilir ve ekran çözünürlüğünden bağımsız olarak
düşük çözünürlükte veya yüksek çözünürlükte olmaları seçilebilir.
Örneğin, 256 renkli düşük çözünürlüklü bir ekranda 64 piksel genişliğinde 8 sprite yüksek çözünürlükte görüntülenebilir.
Bağlı sprite'lar her zaman kullanılabilir.
Çift ve tek sprite'lar, toplam 256 renk paletinden kendi bağımsız 16 renk bankalarını kullanabilir.
renk bankını kullanabilir. Ancak, bağlı olmayan bir sprite
her zaman en fazla 3 renk + arka plan ve bağlı bir sprite 15 renk + arka plan kullanabilir.
Yeni bir özellik de, sprite'ların kenarlarda,
yani DIWSTART-DIWSTOP penceresinin dışında da görünmesi, oysa normalde bu mümkün değildi.
Bu özelliği etkinleştirmek için $dff106 (BPLCON3) bitini 1 olarak ayarlamanız yeterlidir.
Yetmezmiş gibi, yatay konumlandırma 32 ns'ye çıkarılmıştır,
yani ekranı yatay olarak geçmek için 320 “adım” atmak yerine
artık daha küçük adımlar atabilirler, hatta çeyrek piksel kadar, sanki
ekran 1280*256 çözünürlükteymiş ve 1 piksel atlayarak ilerliyormuş gibi.
Bu, hiçbir MS-DOS bilgisayarın SUPER VGA kartının yapamadığı şekilde sprite'ları dalgalandırmaya
olanak tanır.
1/4 piksel adımlarla son derece akıcı bir kaydırma olanağı
bitplanes için de uygulanmıştır. Bu, eski BPLCON1'de bulunan $dff102'deki “ekstra” bitlerdir.
eski BPLCON1'de bulunan “ekstra” bitlerdir. Bilgisayar tarihinin en inanılmaz kaydırma ile düzinelerce paralaks seviyesi oluşturmak mümkündür.
Yeni $dff102, 1/4 piksel ‘adımlarla’ kaydırma yapmanın yanı sıra,
 artık 16 yerine maksimum 64 piksele kadar kaydırma yapabilir.
Daha az ilgimizi çekse de, ECS ile 31khz ekranları, yani multisync monitörleri yönetmek zaten mümkündür. AGA yonga seti ile ekranları “deinterlacing” yapmak mümkündür.
Her ne kadar bizi çok ilgilendirmesede, ECS'den
31khz ekranları, yani multisync monitörleri yönetmek mümkündür. AGA yonga seti ile
15Khz ekranları, bitplanes ve sprite dahil, SUPERVGA monitörler için “deinterlacing” yapmak mümkündür.
Demo ve oyunlar genellikle PAL'dadır!
Tüm bu yenilikler “etkinleştirilmedikçe” etkinleştirilmedikçe, önceki derslerdeOCS/ECS kaynaklarını çalıştırarak kontrol ettiğiniz gibi, eski yonga setiyle
uyumluluğu etkilemez.
Özellikle $dff1fc (FMODE) ve BPLCON0'ın 0 bitini sıfırlamanız gerekir.
Bu biti önceki derslerde her zaman sıfırda tuttuk.
Bu bit ayarlandığında, BPLCON3'teki diğer bitler ($dff106) içindeki diğer bitler devreye girer, bunların arasında
BRDRSPRT, “kenarların” dışındaki sprite'lar.
CLXCON tarafından desteklenmeyen bitplanes 7 ve 8 ile çarpışmaları algılamak için
CLXCON2 ($dff10e) vardır, bu eski CLXCON'a yazarak sıfırlanır
ve OCS oyunlarında çarpışmaların doğru şekilde bildirilmesini sağlar.
Şu anda, gelecekte piyasaya çıkacak Amiga'ların
AGA'yı mı yoksa sadece ECS'yi mi destekleyeceği bilinmemektedir. Belki de sadece
OCS/ECS'yi emülasyonda destekleyecekleri ve farklı bir grafik sistemine sahip olacakları söylenmektedir.
Ancak Commodore'un satışı ile ilgili sorunlar nedeniyle
bu yeni modellerin piyasaya sürülmesi ertelendi, bu nedenle
AGA uzun yıllar boyunca kullanılmaya devam edecek ve bu da muhtemelen
yeni Amiga makinelerde de desteklenmesine yol açacaktır.
Bununla birlikte, AGA'yı destekleyen CD32 de mevcuttur.
CD32 için oyun programlamak istiyorsanız, 11 “düğmeyi” destekleyen 2 joystick bağlantı noktası olduğunu
dikkate alın, bu nedenle kodu bu joystick'e uyarlamanız gerekir.
CD32'nin diğer farklılıkları arasında 1Kb flash RAM, burada
HIGH SCORE veya oyun şifrelerini kaydedebilirsiniz, ayrıca AKIKO çipi,
Chunky grafikleri Planar'a dönüştürebilmelidir, ancak çok hızlı olmadığı görülmüştür
.
Chunky (VGA gibi video modu) grafikleri Amiga Bitplanes'e dönüştürmek,
dokulu grafikler için gereklidir, PC MSDOS'taki DOOM'a bakınız.
Daha sonra belki kendi DOOM'umuzu yapacağız.

Öncelikle bilgisayarınızda AGA olup olmadığını kontrol etmelisiniz, daha önce
algılama rutinini gördük:

LEA    $DFF000,A5
MOVE.W    $7C(A5),D0    ; DeniseID (veya LisaID AGA)
MOVEQ    #100,D7        ; 100 kez kontrol edin (güvenlik için,
eski denise rastgele değerler verdiği için)
DENLOOP:
MOVE.W    $7C(A5),D1    ; Denise ID (veya LisaID AGA)
CMP.B    d0,d1        ; Aynı değer mi?
BNE.S    NOTAGA        ; Aynı değer değil: Denise OCS!
DBRA    D7,DENLOOP
BTST.L    #2,d0        ; BIT 2 sıfırlandı=AGA. AGA var mı?
BNE.S    NOTAGA        ; hayır...
ST.B    AGA         ; evet... o zaman “AGA” bayrağını ayarlayalım.
NOTAGA:                ; AGA değil... veya OCS/ECS veya gelecekteki AAA...
...

*****************************************************************************
*            YENİ 24 BIT PALET             *
*****************************************************************************

Tamam, şimdi 128 veya 256 rengi nasıl görüntüleyebileceğimizi,
“24 bit” bakırla nasıl tonlama yapabileceğimizi vb. pratikte görelim.
Öncelikle yeni paletin nasıl çalıştığını anlamak önemlidir, çünkü
geri kalanı sadece bitplanes eklemek veya sprite'ları genişletmek için
burada ve orada birkaç bit ayarlamakla ilgilidir.
Kırmızı, yeşil ve mavi olmak üzere 3 bileşenin her birine
0 ila 15 yerine 0 ila 255 arasında bir değer verilebileceğini söylemiştik.
Daha önce sarıyı ayarlamak için kırmızıya $F, yeşile $F ve maviye 0
gerekirken, şimdi kırmızıya $FF, yeşile $ff ve maviye $00 gerekiyor.
Buraya kadar her şey açık. Daha önce sarı için $dff180'e $0ff0 değerini koymamız gerekiyorsa
($0RGB), şimdi $00FFFF00'ı nereye koyacağız?
Kayıt defterinde, ki bu bir kelimedir, $00ffff00 ile ilgisi yoktur yani $00RRGGBB.
Tasarımcılar, OCS ile uyumluluğu korumak
ve eski 32 adet 12 bitlik kayıt defterine 256 adet 24 bitlik rengi sığdırmak için bir yol buldular!
Öncelikle ilk sorunu nasıl çözdüklerine bakalım. yani
COLOR0 ($dff180) içine 1 renk $RRGGBB'yi sığdırmak
.
 Şu hususu göz önünde bulunduralım: 12 bitlik “$f32” rengi olsaydı,
24 bitlik eşdeğeri ne olurdu? Tabii ki $f03020. Şimdi,
OCS/ECS'de normal olarak kullanılan 4 bit renklerin, AGA'nın 8 bit renklerinin üst 4 biti,
diğer bir deyişle üst nibble olduğu görülebilir.
Ve aynen öyle! AGA kayıtlarını sıfırlayıp COLOR0'a
veya başka bir renk kaydına bir değer koyarsak, 3 RGB bileşeninin en yüksek 4 bitini değiştiririz,
 en düşük 4 biti sıfır bırakırız, böylece ortaya çıkan renk
OCS'dekiyle aynı olur. 
24 bitlik bir rengi ayarlamak için yüksek bitleri ($RxGxBx) $dff180'e ayrı ayrı koymanız, ardından
bir şeyi “değiştirmeniz” ve düşük bitleri ($xRxGxB) bitlerini yine $dff180'e koymak gerekir.
Bir örnek verelim: 24 bitlik renk $437efa, yani KIRMIZI = $43,
YEŞİL = $7e, MAVİ = $fa. Copperlist'te bunu şöyle yapıyoruz:

dc.w    $180,$47f    ; yüksek nibble'ları koyuyorum
“değiştir”
dc.w    $180,$3ea    ; düşük nibble'ları koy

Şimdilik ‘değiştir’ yaptık, şimdi pratikte ne yapmamız gerektiğini görelim
$dff180 işlevini “düşük nibble alıcı” “yüksek nibble alıcı
” olarak değiştirmek için.
Yüksek bitleri seçmek için, BPLCON3 ($dff106) değerine $c00 değerini koyduk
çünkü ECS emülasyonunda renk kayıtları her zaman renklerin
yüksek bit alıcıları olarak geçerlidir. Teorik olarak $dff106 değerine $000 da koyabilirdik,
çünkü bit 10 ve 11'i ayarlamak sadece DUAL PLAYFIELD modunda
daha sonra göreceğimiz bazı şeyleri sıfırlamak için gereklidir.
Dolayısıyla, $dff106'daki “belirli bir bit” sıfırlandığında,
renk kayıtları yüksek bitleri alır, ayarlanmışsa ise yüksek bitleri
alır.
RGB değerlerini bu şekilde bölmek karmaşık görünebilir, ancak
figürler için palet iffconverter tarafından hazır olarak kaydedildiğinden, şikayet edecek bir şey
yoktur.
Ayrıca, copperlist yapan veya renkleri bu şekilde “bölücü”
rutinler de yapılabilir.
Renk kayıtlarının işlevini “değiştiren” $dff106 bitinin
dokuzuncusu LOCT olarak adlandırılır. Yüksek nibble'lara (MSB) yazdığımızda
düşük nibble'lar (LSB) OCS/ECS ile uyumluluk için sıfırlanır, 24 bitlik bir renk
ayarlamak istediğinizde önce yüksek bitleri, sonra düşük bitleri yüklemeniz gerekir.


İşte %RRRRrrrrGGGGggggBBBBbbbb (ikili) renginin bir şeması, burada
büyük harfler tonun yüksek bitlerini, küçük harfler ise düşük bitlerini temsil eder.

BIT# 11,10, 9, 8 7, 6, 5, 4 3, 2, 1, 0
---- ----------- ----------- -----------
LOCT=0 R7 R6 R5 R4 G7 G6 G5 G4 B7 B6 B5 B4
LOCT=1 r3 r2 r1 r0 g3 g2 g1 g0 b3 b2 b1 b0 

R = KIRMIZI G = YEŞİL B = MAVİ


AGA renk kayıtlarının iki yüzü olduğu söylenebilir ve bu yüzler
$dff106'nın 9 bitini ayarlayarak veya sıfırlayarak döndürülebilir.
Bit 9 ayarlandığında $200 (%0000001000000000) değeri üretilir. Bu nedenle
“değiştir” yerine $106,$200 yazılabilir:


dc.w    $106,$000    ; Yüksek nibble'ları seçiyorum
dc.w    $180,$47f    ; Yüksek nibble'ları koyuyorum
dc.w    $106,$200    ; Düşük nibble'ları seçiyorum
dc.w    $180,$3ea    ; Düşük nibble'ları koyuyorum


Birçoğu, daha önce de belirttiğimiz gibi sadece
çift oyun alanı için gerekli olan 10 ve 11 bitlerini de ayarlar, ancak bu zarar vermez:


dc.w    $106,$c00    ; Yüksek nibble'ları seçer
dc.w    $180,$47f    ; Yüksek nibble'ları ayarlar
dc.w    $106,$e00	; Düşük nibble'ları seçin
dc.w    $180,$3ea    ; Düşük nibble'ları koyun


Yani, yüksek bitleri seçmek için $c00, düşük bitleri seçmek için $e00.
Tabii ki, 10 renk ayarlamak gerekiyorsa, her seferinde
BPLCON3 'ü bir renk ile diğerinin arasına koymayız, sadece şunu yaparız:


dc.w    $106,$c00    ; Yüksek nibble'ları seçerim

dc.w    $180,$47f    ; tüm renklerin yüksek nibble'larını koyarım
dc.w    $182,$123
dc.w	$184,$456
dc.w    $186,$789
dc.w    $188,$abc
dc.w    $18a,$def

dc.w    $106,$e00    ; Düşük nibble'ları seçin

dc.w    $180,$3ea    ; tüm renklerin düşük nibble'larını koyuyorum
dc.w    $182,$111
dc.w    $184,$444
dc.w    $186,$888
dc.w    $188,$434
dc.w    $18a,$abc


Şimdi tüm bunların çalıştığını pratikte kontrol etme zamanı, ders 3'teki gibi “çubuklar” yapmaya çalışalım, ancak AGA: Ders 15a.s'ye bakın.

AGA'da copperlist'i yazmanın çok uzun sürdüğünü fark edeceksiniz. Bu nedenle,
bazı nüanslar veya tekrarlayan şeyler için bir rutin oluşturmak daha hızlı olacaktır.
Özellikle nüanslar için Ders 15b.s'ye bakın.

*****************************************************************************
*         128 ve 256 RENKLİ YENİ MODLAR             *
*****************************************************************************

Şimdi, renk kayıtları sadece 32 tane iken 256 rengi nasıl “yükleyebileceğimizi” görelim.
Aslında, her renk kaydının 2 yüzü olduğunu biliyoruz, biri düşük nibble'ları
diğeri yüksek nibble'ları görür, ancak en fazla 32 renkli bir şekil yapabiliriz,
 bu renkler 24 bitlik bir paletten seçilse bile.
Peki, başka bir püf noktası var, bu da yine $dff106'da.
Peki, başka bir püf noktası daha var, bu da $dff106'da.
Renk kayıtlarının 256 olması gerekir, ancak 32 tane vardır, yani ihtiyacımız olanın sekizde biri.
$dff106'yı sıfırlayarak ilk 32 renge erişilir,
bu durumda, ayarlandığında 33 ila 64 arasındaki renk kayıtlarına
erişimi sağlayan bir bit olması gerektiği anlaşılır. her zaman $dff180-$dff1be'ye yazarak.
Aslında, her biri 32 renk kaydı içeren 8 banka vardır ve
(dff106'nın 13, 14 ve 15 bitleriyle) renk kayıtlarına yazarak 8 bankadan hangisine erişileceğine karar verilmelidir
:

------- bit --- $dff106 (BPLCON3) ------------------------------------

15    BANK2     | Bu 3 bit ile 8 banka
14    BANK1     | kayıtlarından birini seçerek 256 AGA rengine erişilir
13    BANK0     |
----------------------------------------------------------------------

“Banka” seçimi, BPLCON0 ($dff100) içindeki bit düzlemi seçimine benzer şekilde çalışır.
 Aslında bu 3 bit “birlikte” okunur ve içerdikleri sayıya göre
karşılık gelen bankayı seçer:

3 bitin değeri - karşılık gelen renk bankası - $dff106'nın değeri

000		RENK 00 - RENK 31        $c00 / $e00
001        RENK 32 - RENK 63        $2c00 / $2e00
010        RENK 64 - RENK 95        $4c00 / $4e00
011		RENK 96 - RENK 127        $6c00 / $6e00
100        RENK 128 - RENK 159        $8c00 / $8e00
101        RENK 160 - RENK 191        $ac00 / $ae00
110        RENK 192 - RENK 223        $cc00 / $ce00
111        RENK 224 - RENK 255        $ec00 / $ee00


Bu tablo, 256 renge erişmek için eski renk kayıtlarını $180'den $1be'ye
nasıl yeniden kullanabileceğinizi açıklamaktadır. Sağda,
$dff106 (BPLCON3) bitlerinin alması gereken değerler, çeşitli bankalara erişmek için gösterilmiştir.

Bir örnek verelim: 33 numaralı rengi değiştirmek istiyorsanız, şunları yapmanız gerekir:


DC.W    $106,$2C00    ; PALET 1'İ SEÇ (32-63), ÜST NIBBLE
dc.w    $182,$47f    ; üst nibble'ları koyuyorum
DC.W    $106,$2E00	; PALET 1'İ SEÇ (32-63), ALçak NIBBLE
dc.w    $182,$3ea    ; alçak nibble'ları koy


Aslında, 32'den 63'e kadar olan bankayı seçmelisiniz ve
sonuç olarak $dff180'e yazmak, 32 numaralı renge yazmak anlamına gelir;
$dff182'ye yazmak, renk 33'e yazmak anlamına gelir ve bu şekilde
$dff1be'ye kadar devam eder, bu normalde renk 31 olur, ancak bu durumda
renk 63, yani 31+32 olur.
64 ila 95 renkleri arasındaki bankayı seçmiş olsaydık, $dff182
65 rengi olurdu, vb.

İşte copperlist'e koymaya hazır $dff106 değerlerinin listesi, Amiga+b+c+i ile “kes ve yapıştır” işlemleri için
yararlı olabilir:


DC.W    $106,$c00    ; PALET 0'I SEÇ (0-31), ÜST NIBBLE
DC.W    $106,$e00    ; PALET 0'I SEÇ (0-31), ALT NIBBLE
DC.W    $106,$2C00	; PALET 1 (32-63) SEÇ, ÜST NIBBLE
DC.W    $106,$2E00    ; PALET 1 (32-63) SEÇ, ALT NIBBLE
DC.W    $106,$4C00    ; PALET 2 (64-95) SEÇ, ÜST NIBBLE
DC.W    $106,$4E00    ; PALET 2'Yİ SEÇ (64-95), DÜŞÜK NIBBLE
DC.W    $106,$6C00    ; PALET 3'Ü SEÇ (96-127), YÜKSEK NIBBLE
DC.W	$106,$6E00    ; PALET 3'Ü SEÇ (96-127), ALçak NIBBLE
DC.W    $106,$8C00    ; PALET 4'Ü SEÇ (128-159), YÜKSEK NIBBLE
DC.W    $106,$8E00	; PALET 4'Ü SEÇ (128-159), DÜŞÜK NIBBLE
DC.W    $106,$AC00    ; PALET 5'İ SEÇ (160-191), YÜKSEK NIBBLE
DC.W    $106,$AE00    ; PALET 5'İ SEÇ (160-191), DÜŞÜK NIBBLE
DC.W    $106,$CC00    ; PALET 6'YI SEÇ (192-223), YÜKSEK NIBBLE
DC.W    $106,$CE00    ; PALET 6'YI SEÇ (192-223), DÜŞÜK NIBBLE
DC.W    $106,$EC00    ; PALET 7'Yİ SEÇ (224-255), YÜKSEK NIBBLE
DC.W    $106,$EE00    ; PALET 7'Yİ SEÇ (224-255), DÜŞÜK NIBBLE


Her şey mükemmel görünüyor. Ama bir ayrıntı eksik! BPLCON0'da
8 bit düzlemini nasıl seçebiliriz? Sadece 7 bit düzlemi için yer var.
Aslında, 12, 13 ve 14 bitleri mevcuttur %000'dan
sıfır bit düzlemine %111'e kadar 7 bit düzlemine, yani 128 renge kadar gidebilir.
%1000, yani 8 elde etmek için bir bit daha fazla olması gerekir.
Sorun yok, bu bit $dff100'ün dördüncü biti olarak atanmıştır.
8 bit düzlemi ayarlamak için, 12, 13 ve 14 bitlerini sıfırlamanız ve
dördüncüyü ayarlamanız yeterlidir. Örneğin:

;5432109876543210
dc.w    $100,%0000001000010001    ; 8 bit düzlem düşük çözünürlük (320*256)
dc.w    $100,%1000001000010001	; 8 bitplanes hires (640*256)
dc.w    $100,%0111001000000001    ; 7 bitplanes lowres (320*256)

Genlock için bit 9'u her zaman ayarlı bırakıyoruz ve
bit 0, ECSENA'yı ayarlıyoruz, bu da daha sonra göreceğimiz özel bitleri etkinleştirir.
Ekstra half bright olmayan 6 bitplanes de olabileceğini unutmayın, yani
64 renk, paleti normal olarak seçebilirsiniz, 6
bit düzlemi seçip BPLCON2 ($dff104) bit 9'u (KillEHB) ayarlamak yeterlidir. Bu bit
ayarlanmazsa, eski EHB, 32 renk + 32 “karartılmış” renk ile emüle edilir.

Şimdi, söylediklerimizi doğrulamak için,
256 renkli bir resmi, Ders 15c.s'de görüntüleyelim.

Resim bana ait. AGONY
ve SHADOW OF THE BEAST gibi oyunların tarzından ilham aldığımı itiraf ediyorum, sanatsal olarak yenilikçi bir şey değil, ama bence
uygun, değil mi? Her neyse, listelemenin amacına iyi hizmet ediyor.
Copperlist ve resmin öncesinde şunların olduğunu fark etmişsinizdir:

CNOP    0,8    ; 64 bit'e hizala

Aslında FMODE ($dff1fc) sıfırlandığında “gerekli” değildir, nedenini sonra göreceksiniz.

Aga olmayan şekillerde gördüğümüz gibi, paleti şeklin
altına “yapıştırabilir” ve bir rutinle copperlist'e ekleyebilirsiniz.
Bu rutin biraz daha karmaşıktır, ama çok da değil: Ders15c2.s

Artık bu rutini öğrendiğimize göre, ders 8'de gördüğümüz fade rutinini değiştirerek
24 bit fade elde etmeyi daha kolay anlayabilirsiniz.
Bunu Ders15c3.s'de görebilirsiniz.

Şimdi bunu “optimize edelim”, Ders15c4.s'de

Son olarak bunu %100 “gerçek zamanlı” olarak yapalım: Ders15c5.s

Şimdi resminizi 320*256, 128 veya 256 renge dönüştürmeyi deneyebilirsiniz.
Tercihinize göre, yardımcı program diskindeki PicCon, IffConv veya AgaConv programlarını kullanın.
PicCon'un diskteki talimatlarını okumanızı şiddetle tavsiye ederim.

*****************************************************************************
*                FMODE                     *
*****************************************************************************

AGA resminizi görüntüleyebildiniz mi?
Peki, 640*256 yüksek çözünürlükte bir resmi görüntülemeyi denediğinizde,
doğru RAW ve PALETTE'yi ekleyip BPLCON0'ın 15 bitini ayarladığınız halde
ekranda sadece siyah bir ekran görürsünüz...
Bunun nedeni, $dff1fc (FMODE) değerini sıfırlamış olmamızdır.
Bu kayıt, BURST'u, yani verilerin bellekten “video”ya aktarılma şeklini kontrol eder.
Normalde aktarım 16 bit'tir, ancak daha “gelişmiş” grafikleri görüntülemek için
aktarımı 32 bit veya 64 bit olarak ayarlamak gerekir.
Aktarım 16 bit olarak gerçekleşirse, aktarılması gereken şey çift adresli olmalıdır, yani WORD (16 bit) ile hizalanmış olmalıdır.
Aktarım 16 bit ile gerçekleşirse, aktarılması gereken veriler
çift adrese, yani WORD (16 bit) ile hizalanmış olmalıdır.
Aslında, bir bit düzlemini tek bir adrese yöneltmemelisiniz!
Şimdi, burst 32 bitlik bloklar halindeyse, veriler
32 bit ile hizalanmış, yani longword adresinde olmalıdır! Örneğin, $16dfc
adresi 4'ün katlarıdır (4*23423) ve bu nedenle 8 bitlik 4 baytın katlarıdır, yani
4*8=32 bit. Kısacası, 32 bit ile hizalanmış bir adrestir.
Verileri 32 bit adreslere hizalamak için “CNOP 0,4” komutu vardır.
“EVEN”, yani “CNOP 0,2” 2 bayta, yani 16 bite hizalarken, cnoppare 0,4
4 bayta, yani 32 bite hizalar.
Burst 64 bit ise, 64 bit hizalamayı sağlamak için copperlist,
sprite ve bitplane'lerden önce “CNOP 0,8” koymak gerekir.
Assembler sorun çıkarır ve hizalamayı yapmazsa, şekil
“dilimlenmiş” yani dikey şeritler halinde görünür, çünkü 32 veya 64 bitlik bloklar
şeklin başlangıcına uymaz.
Bir etiketin 64 bit hizalı olup olmadığını kontrol etmek için, derleyin, ardından
“M” komutuyla bu etiketin adresini kontrol edin, ardından adresi
8'e bölün ve sonucu tekrar 8 ile çarpın.
Eğer orijinal adres geri gelirse, bu 8'in katı olduğu anlamına gelir ve her şey
, farklı çıkarsa bir kalan vardır ve 8'in katı değildir.
Bu durumda, adresin üzerine “dc.w 0” yazın ve “elle” hizalamayı deneyin.
Tabii ki, patlamayı (bant genişliği) her zaman
maksimumda, yani 64 bit olarak tutmak iyi olur. Bunu, $dff1fc'ye 3 değerini yazarak yapabilirsiniz.
Ancak, bit düzlemlerini genişletmek istiyorsanız,
bunların her seferinde 8 baytlık “bloklar” halinde genişletilmesi gerektiğine dikkat etmelisiniz. Örneğin,
bazı durumlarda, örneğin kaydırma ve blitter ile metin kaydırma için, video penceresinin “yanında” bir bit düzlemi parçası olması
yararlıdır. Bu durumda, sadece 2 bayt ekleyemeyiz, 8 bayt eklemeliyiz.
Diğer bir husus ise, bit düzlemleri için bellekte yer bulmak amacıyla ASLA Allocmem kullanmamalısınız
çünkü 16 bitlik adreslere hizalanır ve
sadece tesadüfen 64 bitlik adreslere de hizalanabilir.
Dersin ilk kaynaklarında, gerekli olmasa da,
hizalama kuralı izlenmiştir:


CNOP 0,8        ; 64 bit adrese hizala
sprite:
incbin “agasprite1”

CNOP 0,8        ; 64 bit adrese hizala
pic:
incbin “AGAbitplanes”

FMODE ($dff1fc) kaydının ilk iki bitini biraz daha yakından inceleyelim:

bit 1    BPAGEM	| Bit düzlemi Sayfa modu (çift CAS)
bit 0    BLP32    | 32 bit genişliğinde bit düzlemi

Bitlerin her ikisi de sıfırsa, burst “OCS/ECS emülasyonu”dur,
 yani aktarım 16 bittir.
Her ikisi de ayarlanmışsa mod 64 bittir.
İlk 2 bitin bulunabileceği 4 durumu görelim:


[x1]    %00    - 2 baytlık bitplane veri aktarımı (16 bit)
Bellek döngüleri: Normal CAS
Bus genişliği 16 bit
Gerekli: 16 bitlik hizalanmış bitplanes

[x2]    %01	- 4 baytlık bit düzlemi veri aktarımı (32 bit)
Bellek döngüleri: Normal CAS
Bus genişliği 32 bit
Gerekli: 32 bit hizalanmış bit düzlemleri (Çift)
Modül = Modül -4

[x2]    %10    - 4 baytlık bit düzlemi veri aktarımı (32 bit)
Bellek döngüleri: ÇİFT CAS
Bus genişliği 16 bit
Gerekli: 32 bit hizalanmış bitplanes (Çift)
Modül = Modül -4

[x4]    %11    - 8 baytlık bitplane veri aktarımı (64bit)
Bellek döngüleri: ÇİFT CAS
Bus genişliği 32 bit
Gerekli: 64 bit hizalanmış bitplanes (Quadruple)
Modül = Modül -8


Her zaman %11, yani $3 kullanmanın gayet uygun olduğunu söyleyebilirim. 
Tek sorun
, blitter ve
işlemci (FAST RAM ile donatılmamış) AGA yongalarının hipergalaktik aktarımının 64 bitlik nehrinde takılırsa DMA'ların karışması olabilir. Bu tür türbülanslar durumunda,
iyileşme görürseniz %01 veya %10'u tercih edebilirsiniz.
Şimdi çeşitli grafik çözünürlükleri için gerekli minimum bant genişliğini görelim
AGA (her zaman 64 bit olarak ayarlamaya çalışacağız!).

Daha önce gördüğümüz gibi, 8 bit düzlemli 320*256 düşük çözünürlük için 16 bit ($1fc,0) yeterlidir:

LORES (320x256),     64, 128, 256 renk veya HAM8 için 16 bit yeterlidir

HIRES (640x245),     32, 64, 128, 256 renk veya HAM8 için 32 bit gerekir

SUPERHIRES (1280x200)    2, 4 renk için 16 bit yeterlidir
8, 16 renk için 32 bit gerekir
32, 64, 128, 256, HAM8 için 64 bit gerekir

Bu arada, düşük çözünürlüklü sakin figürümüzün görüntüsünde BURST'u en yüksek seviyeye getirerek başlayabiliriz.
 Görünürde hiçbir şey olmayacak olsa da,
 aktarım daha GALAKTİK olacaktır.
Ancak çok ÖNEMLİ bir açıklama yapmak gerekir: FETCH'i değiştirmek,
 donanım koşulları nedeniyle MODÜL'ün de düzeltilmesini gerektirir.
Dolayısıyla, FMODE sıfırlanmışsa ve aktarım 16 bit ile gerçekleşiyorsa, modül
0 olmalıdır, aksi takdirde normaldir.
BURST 32 bit ise, modül -4 modülüne eşittir, bu nedenle
sıfır ise, telafi etmek için BPL1MOD/BPL2MOD'a -4 yazmak gerekir.
BURST 64 bit ise, modül normal modül -8 ile aynıdır:


BANDWIDTH 1: dc.w $1FC,0    ; O zaman bit düzlemleri
; en az word (16 bit) hizalanmalıdır ve modül
; normal modüle eşittir.

BANDWIDTH 2: dc.w $1FC,1 veya 2    ; O zaman bit düzlemleri
; en az long (32 bit) hizalanmalıdır ve modül
; normal modüle eksi 4

BANDWIDTH 4: dc.w $1FC,3    ; O zaman bit düzlemleri
; en az quadword (64 bit) hizalanmalı ve modül
; normal modül eksi 8'e eşittir

Her şeyi kontrol etmek için, Lezione15c.s dosyasını yeniden yükleyin ve
FMODE değerini 1 veya 2 olarak değiştirin ve 32 bit burst'u etkinleştirin.
Başka bir değişiklik yapmazsanız, şeklin modülünün
yanlış olduğunu göreceksiniz.
Modülü de = -4 olarak değiştirin, resmin
“düzeldiklerini” göreceksiniz.
Aynı şekilde, burst'u 64 bit'e ayarlayın ve copperlist'teki “dc.w $1fc” (FMODE) değerini
$3 olarak değiştirin.
Şimdi, PIC'i görebilmek için modülü, hem $108 hem de $10a, -8 olarak ayarlamanız gerekir.

Bu durumu açıklığa kavuşturduktan sonra, FMODE'yi her zaman $3'te tutun, yani her zaman ilk 2 biti ayarlayın
ve 256 renkli yüksek çözünürlükte görüntüleyebilirsiniz.

32 veya 64 bit burst'un etkileriyle ilgili son bir ayrıntı daha var.
DDFSTRT ve DDFSTOP değerleri de değiştirilir.
Normal bir 16 bit burst ile, yatay MIOX konumunda başlayan bir yüksek çözünürlüklü ekranı açmak için
“formül” ile belirlenirdi:

DDFSTRT=(MIOX-9)/2

Bunun yerine, 32 bit burst ile şunları yapmanız gerekir:

DDFSTRT=(MIOX-17)/2

Çünkü bir kelime yerine bir uzun kelime okunur.
Ancak, standart genişlikteki ekranlar kullanılıyorsa sorun yoktur ve
sorun olursa deneme yapabilirsiniz!
Her neyse, pratikte, patlama etkin olduğunda, yüksek çözünürlüklü bir şekil görüntülerseniz
DDFSTART ve DDFSTOP'u $003c ve $00d4'e ayarlamanız gerekmez, ancak aynı
lowres ile aynı şekilde:

dc.w    $92,$0038    ; DdfStart lowres, burst ile HIRES için uygun
dc.w    $94,$00d0    ; DdfStop düşük çözünürlük, yukarıdaki gibi

Bu, ChipRam'den Chip Lisa'ya “turbo” aktarım için gereken bellek döngüleri
nedeniyledir.

Ders 15d'de 256 renkli bir resmi yüksek çözünürlükte görüntüleyelim.
s
Söz konusu resim Cristiano Evangelisti'nin eseri, kullanıcı adı “KREEX”,
bir “bağımsız” grafikçi, öğrencimin programladığı bir macera oyunu için grafikler yapıyor.
*****************************************************************************

*                HAM8                     *
*******************************************************************
**********

Eski 6 bitplanes HAM, yeni 8 bitplanes HAM8 tarafından “devrilmiştir”.
6 bitplanes renkler için, 2 bit ise kontrol bitleri için kullanılır.
Ayrıca, sadece LowRes'te değil, tüm çözünürlüklerde kullanılabilir.
Etkinleştirmek için, 8 bitplanes ve BPLCON0 ($100) içindeki HAM bitini ayarlamanız yeterlidir. 8 bit'ten 6 bit yüksek bitler 64 temel renk kaydı olarak kullanılır.
Etkinleştirmek için, 8 bit düzlemi ve BPLCON0 ($100) içindeki HAM bitini ayarlamak yeterlidir.
8 bitten, en yüksek 6 bit 24 bitlik 64 temel renk kaydı olarak veya
6 bitlik bir MODIFY değeri olarak kullanılır, ayrıca en düşük 2 bit hold veya
18 bitlik modify modu için kullanılır. Bu, 256000'den fazla rengin görüntülenmesini sağlar.
2 kontrol düzlemi ve 6 renk düzlemi “dahili olarak” HAM8'in 8
bitinde birleştirilir, ancak sırası tersine çevrilir: önce 3,4,5,6,7,8 sonra 1 ve 2.
Bu, göreceğimiz bit düzlemlerinin değişmesine neden olur.

İşte eski HAM6 ve yeni HAM8'in karşılaştırması.

HAM6'daki kontrol bit düzlemleri 5 ve 6'nın işlevi:

+-----+-----+--------+--------+------------------+
| BP6 | BP5 | KIRMIZI | YEŞİL | MAVİ         |
+-----+-----+--------+--------+------------------+
| 0 | 0 | yeni temel kaydı seçin (16'dan 1) |
+-----+-----+--------+--------+------------------+
| 0 | 1 | tut | tut | değiştir         |
+-----+-----+--------+--------+------------------+
| 1 | 0 | değiştir | tut | tut         |
+-----+-----+--------+--------+------------------+
| 1 | 1 | tut | değiştir | tut         |
+-----+-----+--------+--------+------------------+

HAM8'de kontrol bit düzlemleri 1 ve 2'dir:

+-----+-----+--------+--------+------------------+
| BP2 | BP1 | KIRMIZI | YEŞİL | MAVİ		 |
+-----+-----+--------+--------+------------------+
| 0 | 0 | yeni temel kayıt seç (64'ten 1) |
+-----+-----+--------+--------+------------------+
| 0 | 1 | tut | tut | değiştir         |
+-----+-----+--------+--------+------------------+
| 1 | 0 | değiştir | tut | tut         |
+-----+-----+--------+--------+------------------+
| 1 | 1 | tut | değiştir | tut         |
+-----+-----+--------+--------+------------------+

Bu 2 ALÇAK bit komuttur: yeni temel kayıt veya
KIRMIZI, YEŞİL, MAVİ bileşenlerinden birini değiştir. Rengin 2 alçak bitinin
değiştirilemeyeceğine dikkat edin, bu nedenle başlangıç paleti
iyi seçilmelidir. (Ancak bu, grafikçilere ve AdPro veya ImageFX gibi programlara bağlıdır).

Şimdi, bir HAM8 figürünü nasıl görüntüleyebileceğimizi pratikte görelim. Öncelikle
palet 256 renk değil, 64 renktir: ham'ı oluşturmak için bu “az” renk
yeterlidir, çünkü RGB bileşenlerini ‘tutmak’ veya “değiştirmek” için kontrol bitleri vardır.
 Bunu etkinleştirmek için BPLCON0'da 8 bit düzlemi ve HAM modunu
ayarlayın, yani bit 4 ve bit 11'i ayarlayın.
Ancak son bir “özellik” daha var. Bit düzlemlerinin
1-2'nin dahili olarak bit düzlemleri 3-4-5-6-7-8 ile ‘değiştirildiğini’ daha önce belirtmiştik. Peki,
bit düzlemlerini "bitplanes'i “işaretlerken” bu sorun ortaya çıkar.
PicCon ile RAW'ı kaydederseniz, 256 renkli bir resim için yaptığınız gibi
resmi normal şekilde işaretleyebilirsiniz. Bunun nedeni, PicCon'un
RAW'daki sırayı “geri dönmesi” için önceden değiştirmesidir.
Bunun yerine, AgaConv veya diğer iffconverters ile raw'ı kaydederseniz, raw
"olduğu gibi“ olarak kaydedilir, bu nedenle ilk 6 bitplanes'i
3,4,5,6,7,8 bitplanes'leriymiş gibi işaretlemeniz ve son olarak 1 ve 2 plane'leri işaretlemeniz gerekir.

; RAW dosyasını AgaConv veya
; plane'leri kendi başına ”ters çevirmeyen" başka bir iffconverter ile kaydederseniz, bitplanes'lerin sırası budur.

BPLPOINTERS:
dc.w $e8,0,$ea,0    ; üçüncü     bit düzlemi
dc.w $ec,0,$ee,0    ; dördüncü     "
dc.w $f0,0,$f2,0    ; beşinci	 “
dc.w $f4,0,$f6,0    ; altıncı         ”
dc.w $f8,0,$fA,0    ; yedinci     "
dc.w $fC,0,$fE,0    ; sekizinci     “
dc.w $e0,0,$e2,0    ; birinci      ”
dc.w $e4,0,$e6,0    ; ikinci     "

Örnek listede RAW, PicCon ile kaydedilmiştir, bu nedenle düzlemler
normal şekilde işaretlenmiştir. Ders15e'yi yükleyin.s

Şimdi HAM8 ile normal 256 renk arasında bir karşılaştırma yapabiliriz.
Ders15e2.s dosyasında görebilir ve karar verebilirsiniz.

Tüm AGA paletini değiştirmek
on kadar raster satırı gerektiren bir işlemdir! Bu örnekte “sadece” 64 rengi değiştiriyoruz,
bu nedenle 2 veya 3 satır yeterlidir, ancak örneğin, ekranın üst kısmında 256 renkli bir resim
ve alt kısmında bir kontrol paneli olan bir macera oyunu yapmak istersek, palet değiştirildiğinde
10 pikseli
‘siyah’ bırakmalıyız ve paletin tamamen değişmesini beklemeliyiz, ancak “yeniden paletleme” süresini de dikkate almak gerekir. Her bakırın her MOVE'u 8 piksel düşük çözünürlükte yer kaplar ve yaklaşık 52 hareket alt kısımda yer kaplar. “siyah” bırakmamız gerekir ve paletin tamamen değişmesini beklememiz gerekir,
ancak “yeniden paletleme” süresini de hesaba katmak gerekir.
Copper'ın her MOVE'unun 8 piksel lowres kullandığını ve yaklaşık 52
move'un bir satır kapladığını hatırlıyor musunuz?

**************************************************************************
*                SPRITE                     *
**************************************************************************

Sprite'larla ilgili birçok yenilik var.
İlk olarak, genişliğini 16, 32
veya 64 piksel arasından seçerek belirleyebilirsiniz. Bildiğiniz gibi, normalde maksimum genişlik 16 pikseldi!
Ayrıca sprite, arka plandaki resmin çözünürlüğünden bağımsız olarak düşük çözünürlük, yüksek çözünürlük veya süper yüksek çözünürlükte görüntülenebilir.
Bunların nasıl yapıldığını pratikte görelim.

Sprite çözünürlüğü, BPLCON3
($dff106) kaydının 6 ve 7 bitleriyle belirlenir ve sprite genişliği önemli değildir:

bit 7 bit 6

0    0    DÜŞÜK ÇÖZÜNÜRLÜK, OCS/ECS emülasyonu (140ns)
0    1	DÜŞÜK ÇÖZÜNÜRLÜK, (140ns) (Standart ECS yöntemi değildir!)
1    0    YÜKSEK ÇÖZÜNÜRLÜK (70ns)
1    1    SÜPER YÜKSEK ÇÖZÜNÜRLÜK (35ns)


Bu iki bit, değişiklik olsun diye SPRES0 ve SPRES1 olarak adlandırılmıştır.
Hemen bir hires sprite örneği görelim, çünkü sadece
7 bitini ayarlamak yeterlidir, Lezione15f.s

32 veya 64 PIKSEL GENİŞLİKLİ SPRITES

Şimdi 32 veya 64 piksel genişliğinde sprites nasıl yapılabileceğini görelim.
Öncelikle, bu tür sprite'ları kaydeden bir iffconverter'a ihtiyacımız var
! PicCon veya AgaConv bunları uygun şekilde kaydeder, sorun yoktur.
Her zamanki gibi, genişliği belirleyen birkaç bit vardır.
Bunlar, FMODE ($dff1fc) kaydının 3 ve 2 bitleridir ve SPAGEM ve SPR32 olarak adlandırılır.
SPAGEM ve SPR32 bitleri sprite'ın genişliğini ve dolayısıyla SPRxDATA'ya aktarılacak
verilerin 16,32 veya 64 bit olması gerektiğini belirler,
bit düzlemlerinde olduğu gibi.
32 bitlik sprite'ların
“cnop 0,4” ile, 64 bitlik sprite'ların ise “cnop 0,8” ile hizalanması gerektiği de benzerdir.
Bunun nedeni, 16 bitlik aktarımların
bant genişliği *1 gerektirirken, 32 bitlik aktarımların *2 gerektirmesidir, dolayısıyla
64 bitlik aktarımlar *4 gerektirir.
Ancak sprite'larda kontrol kelimeleri değişir ve 32 veya 64 bit'lik durumlarda sprite'ın geri kalanıyla birlikte “genişler”.

FMODE'un SPAGEM ve SPR32 bit değerlerinin tablosuna bakalım:

bit 3 | bit 2 | Genişlik | Kontrol kelimesi
------+-------+-------------+----------------------------------
0 | 0 | 16 piksel | 2 kelime (normal) - cnop 0,2 gerektirir
1 | 0 | 32 piksel | 2 uzun kelime - cnop 0,4 gerektirir
0 | 1 | 32 piksel | 2 uzun kelime - cnop 0,4 gerektirir
1 | 1 | 64 piksel | 4 uzun kelime - cnop 0,8 gerektirir
---------------------------------------------------------------

“Genişletilmiş” sprite'lar, DMA'nın bunu yapamadığı durumlarda kullanılamaz
, özellikle 256 renkli süper yüksek çözünürlüklü taramalı durumlarda.

Öyleyse, iffconverter ile 32 veya 64 piksel genişliğinde bir sprite kaydettiğimizde
ve bunu 4 veya 8'in katları olan bir adrese hizaladığımızda,
16 piksel genişliğinde bir sprite ile aynı şekilde kontrol kelimelerine erişebilir miyiz?
Kesinlikle hayır, nedeni şu:

Bu, 16 piksel genişliğinde normal bir sprite'ın yapısıdır:


MIOSPRITE16:
VSTART:
dc.b $50    ; Sprite'ın başlangıç dikey konumu (2c'den $f2'ye)
HSTART:
dc.b $90    ; Sprite'ın başlangıç yatay konumu (40'tan $d8'e)
VSTOP:
dc.b $5d    ; $50+13=$5d    ; Sprite'ın bitiş dikey konumu
VHBITS:
dc.b $00    ; bit

dc.w	%0000000000000000,%0000110000110000 ; dati
dc.w	%0000000000000000,%0000111001110000
...
dc.w	0,0	; 2 sıfırlanmış kelime sprite'ın sonunu tanımlar.

Yani:

------------------------------------------------------------------------------
dc.w 0,0            ; 2 kontrol kelimesi
dc.w dataPlane1,dataPlane2    ; 2 kelime (16 bit - 16 piksel) ile 2 "düzlem“
dc.w dataPlane1,dataPlane2    ; 2 kelime (16 bit - 16 piksel) ile 2 ‘düzlem’
dc.w dataPlane1,dataPlane2    ; 2 kelime (16 bit - 16 piksel) ile 2 ”düzlem"
....
dc.w 0,0            ; 2 kelime sıfırlanarak sonlandırılır
------------------------------------------------------------------------------

Şimdi, 32 piksel genişliğindeki sprite'ların yapısı şöyledir:

------------------------------------------------------------------------------
dc.l 0,0            ; 2 kontrol uzun kelime
dc.l dataPlane1,dataPlane2    ; 2 uzun kelime (32 bit/piksel) ile 2 “düzlem”
dc.l dataPlane1,dataPlane2    ; 2 uzun kelime (32 bit/piksel) ile 2 ‘düzlem’
dc.l dataPlane1,dataPlane2    ; 2 uzun kelime (32 bit/piksel) ile 2 “düzlem”
....
dc.l 0,0            ; 2 uzun kelime sıfırlanarak sonlandırılır
------------------------------------------------------------------------------

64 piksel genişliğindeki sprite'lar için ise şöyledir:

------------------------------------------------------------------------------
dc.l 0,0,0,0                ; 2 çift kontrol uzun kelime
dc.l data1a,data1b,data2a,data2b    ; 2 çift uzun kelime (64 bit/piksel)
dc.l data1a,data1b,data2a,data2b    ; 2 çift uzun kelime (64 bit/piksel)
dc.l data1a,data1b,data2a,data2b    ; 2 çift uzun kelime (64 bit/piksel)
....
dc.l 0,0,0,0                ; 2 çift uzun kelime = 0 sonlandırmak için
------------------------------------------------------------------------------

Şimdi, ilgilendiğimiz şey, uzun kelime ve çift uzun kelimeye genişletilmiş yeni kontrol kelimelerinde bitlerimizi bulmaktır
.
32 bit genişliğindeki sprite'lar için:

------------------------------------------------------------------------------
SPRITE32:
VSTART:
dc.b $50    ; Sprite başlangıç dikey konumu (2c'den f2'ye)
HSTART:
dc.b $90    ; Sprite başlangıç yatay konumu (40'dan d8'e)
DC.W 0        ; 32 piksel genişliğindeki sprite'a “eklenen” kelime
VSTOP:
dc.b $5d    ; $50+13=$5d    ; sprite son dikey konumu
VHBITS:
dc.b $00    ; bit
DC.W 0        ; Word “ekleme” 32 piksel genişliğinde sprite içinde

dc.l %00000000000000111100000000000000,%0000000000001000000000000000000 ; veriler
dc.l %0000000000001111111100000000000,%0000000000010111100000000000000
...
dc.l    0,0        ; Sprite sonu (2 kelime yerine 2 uzun kelime).
--------------------------------------------------------------

Görüldüğü gibi, 2 kontrol kelimesi 2 uzun kelimeye dönüştü ve
kontrol bitleri yüksek kelimedeki gibi kaldı.

Şimdi 64 piksel genişliğindeki pikselleri ele alalım:

------------------------------------------------------------------------------
SPRITE64:
VSTART:
dc.b $50    ; Sprite başlangıç dikey konumu (2c'den f2'ye)
HSTART:
dc.b $90    ; Sprite başlangıç yatay konumu (40'tan d8'e)
dc.w 0		; Çift
dc.l 0        ; 64 piksel genişliğindeki sprite'ta longword (2 long!)
VSTOP:
dc.b $5d    ; $50+13=$5d    ; sprite'ın dikey bitiş konumu
VHBITS:
dc.b $00    ; bit
dc.w 0		; Çift
dc.l 0        ; 64 piksel genişliğinde sprite içinde longword (2 long!)

dc.l data1a,data1b,data2a,data2b    ; 2 çift longword (64 bit/piksel)
dc.l data1a,data1b,data2a,data2b	; 2 çift uzun kelime (64 bit/piksel)
dc.l data1a,data1b,data2a,data2b    ; 2 çift uzun kelime (64 bit/piksel)
...
dc.l    0,0,0,0        ; Sprite'ın sonu (2 çift uzun kelime!).
------------------------------------------------------------------------------

Buradan, UniMuoviSprite'da küçük değişiklikler yapılması gerektiği sonucu çıkar.
'da küçük değişiklikler yapılması gerektiği sonucu çıkar.

32 piksel genişliğinde bir sprite örneği Lezione15f2.s

64 piksel genişliğinde bir sprite örneği Lezione15f3.s

Bu büyük böceği gördünüz mü? Bunun gibi 8 tane yapabilirsiniz, ya da 16 renkte 4 tane
bağlı olarak.
 PicCon, ekli sprite'ları tek sayı sprite'larda bit 7 (ekleme)
ayarlanmadan kaydeder, bu nedenle bu IffConverter ile kaydederseniz “elle” ayarlamanız gerekir
.

YENİ YATAY KONUMLANDIRMA 1/4

Çeyrek piksel mi? Evet!
Sprite'ın yatay konumuna 2 “düşük” bit eklendi,
böylece 4 kat daha küçük ‘adımlarla’ hareket ettirilebilmesini ve dolayısıyla daha akıcı olmasını sağladı.
Bu bitlerin nereye yerleştirildiğini, SPRxCTL'yi analiz ederek görelim. SPRxCTL,
sprite'ın ikinci kontrol kelimesinin “eşdeğeri” olan kayıt serisidir. sprite:

$dff142/14A/152/15A/162/16A/172/17A - SPRxCTL - Controllo e posiz. sprite

+-------+-------+-------------------------------------------------------+
| BIT | isim    |    FONKSİYON                    |
+-------+-------+-------------------------------------------------------+
| 15-08    | EV7-0	| VSTOP - Dikey konumun son 8 bit'i)    |
| 07    | ATT    | Bağlı kontrol bitleri (sadece tek sprite)    |
| 06    | SV9    | Dikey başlangıç konumunun onuncu bit'i    |
| 05    | EV9    | Dikey son konumunun onuncu bit'i		|
| 04    | SH1=0    | Yatay konum, 70nS artış (yarım piksel)    |
| 03    | SH0=0    | Yatay konum, 35nS artış (1/4 piksel)    |
| 02    | SV8    | Başlangıç dikey konumunun dokuzuncu biti (vstart)    |
| 01    | EV8    | Dikey son konumun dokuzuncu biti (vstop)    |
| 00    | SH2    | Yatay konum, artış 140nS (1 piksel)    |
+-------+----------+----------------------------------------------------+

Bizi ilgilendiren bitler SH0, SH1, SH2, yani Start Horizontal'dır.
Gördüğünüz gibi, bilinen SV8, EV8 bitlerinin yanı sıra, yani VSTART ve
VSTOP'un sekizinci bitlerinin yanı sıra, HSTART ile ilgili iki yeni bit daha bulunmaktadır:
“düşük” bir piksel kaydırmamızı sağlayan “düşük” bitin yanı sıra, bir pikselin yarısını veya 1/4 pikselini kaydırmamızı sağlayan
bir çift daha ‘düşük’ bit eklenmiştir.
140ns (nanosaniye) ile video kaydırma “süresi” kastedilmektedir.
Ancak 140ns'nin 1 düşük çözünürlüklü piksele karşılık geldiğini, 140/2= 70ns'nin ise 1 yüksek çözünürlüklü piksele (veya yarım düşük çözünürlüklü piksele) karşılık geldiğini belirtmek daha açıktır.
Ancak 140ns'nin 1 düşük çözünürlüklü piksele karşılık geldiğini,
140/2= 70ns'nin ise 1 yüksek çözünürlüklü piksele (veya yarım düşük çözünürlüklü piksele) karşılık geldiğini söylemek daha açıktır. Son olarak
70/2= 35ns'nin 1/4 düşük çözünürlüklü piksele veya
1280*xxx çözünürlükte bir piksele, yani süper yüksek çözünürlüğe karşılık geldiği açıktır.

Peki, sprite'ı 1/4 piksel adımlarla nasıl hareket ettirebiliriz?
Bir yol, UniMuoviSprite rutinini, girişte
0 ila 320 yerine 0 ila 1280 arasında bir X konumu kabul edecek şekilde değiştirmektir.
böylece her seferinde 1 eklediğimizde kaydırma 1/4 piksel,
2 eklediğimizde yarım piksel veya her seferinde 4 eklediğimizde
bir piksel kaydırma elde ederiz. Basit, değil mi?

Uygulamayı Lezione15f4.s ve Lezione15f5.s dosyalarında görebilirsiniz.

Pratikte, AGA yatay konumu 9 bit yerine 11 bitlik bir sayıdır.

BRDRSPRT BİTİ

BRDRSPRT biti, ayarlandığında,
sprite'ların diwstart/diwstop ile tanımlanan kenarların dışında da görüntülenmesini sağlar.
Bu bit etkinleştirildiğinde, bitplanes bplcon0'da devre dışı olsa bile sprite'lar görüntülenir!
Ancak, bplcon0'ın 0 bitini de ayarlamayı unutmayın
 ($dff100) bitini de ayarlamanız gerektiğini unutmayın,
bu bit diğer özel bitleri de etkinleştirir.
Söz konusu bit, $dff106 (bplcon3) içindeki ikinci (01) bitidir.

Bunun Lezione15f6.s içindeki uygulamasını görelim.


ATTACCHED MODU

Sprite'lar herhangi bir şekilde eklenebilir, ECS
SHRES (1280*xxx, 35ns) modu hariç.

SPRITE PALETİ

Sprite paleti olarak, 256 renk paletinden alınan herhangi bir 16 renk bankası
kullanılabilir.
ESPRM7'den ESPRM4'e kadar olan bitler, sprite renk haritasını “yeniden konumlandırmaya”
, OSPRM7'den OSPRN4'e kadar olan bitler ise tek sayı sprite'ların renk haritasını yeniden konumlandırmaya
yarar.
OCS/ECS'de sprite'ların 16 rengi her zaman ve zorunlu olarak
color16 ($dff1a0) ile color31 ($dff1be)
, bu nedenle 16'dan fazla renge sahip bir şekil, 16'dan 31'e kadar olan renkleri sprite'larla paylaşmak zorundaydı.
AGA ile ise bu 16 renkli bankayı 256 segmentin herhangi birine taşıyabilirsiniz.
Örneğin, 128 renkli bir şekilimiz varsa, sprite'ların renklerini color129'dan itibaren
 böylece paleti şekille paylaşmak zorunda kalmayız.
Bu özellik, 16'dan fazla renge sahip şekillerde kullanışlıdır.
Ancak bit düzlemleri 8 ve renkler 256 ise, 16'lık bankalardan hangisini kullanacağımızı seçebiliriz
kullanacağımızı seçebiliriz, ancak bu 16 renk her zaman şekil ile ortak olacaktır.
OCS'de paletin renkleri sprite'lara şu şekilde atanır:

Sprite'lar | Renkler
------------------
0-1 | 00-03    ; $dff1a0/1a2/1a4/1a6
2-3 | 04-07
4-5 | 08-11
6-7 | 12-15
------------------

Böylece 3 renkli 4 sprite çifti vardır.
Örneğin, ilk sprite'ın 3 rengini tanımlamak için:

dc.w    $1A2,$462    ; renk17, düşük nibble
dc.w    $1A4,$2e4    ; renk18, düşük nibble
dc.w    $1A6,$672    ; renk19, düşük nibble

AGA yonga setinde ise, 256 renk paletinin hangi kısmını sprite'lar için kullanacağınızı seçmenin yanı sıra,
 2 palet seçebilirsiniz, biri
çift sprite'lar için, diğeri tek sprite'lar için, böylece toplam 32-8 renk,
yani 24 renk elde edilir, çünkü renk0 şeffaftır ve sayılmaz.
Özetle, OCS'de her biri 3 gerçek renge sahip 8 sprite varken,
 bunlar “çift” ilişkisiyle birbirine bağlıydı ve toplam renk sayısı 3*4=12 idi, AGA'da
sprite'lar her zaman 3 renklidir, ancak çiftler halinde paleti paylaşmazlar!
Ancak, sprite'lar birbirine bağlıysa, tüm sprite'lar için tek
düz renk paleti kullanılır, bu da tek sprite'lara atanan palettir.

Dolayısıyla, 256 renkli AGA paletinde, 16 renkli 16 palet
arasından seçim yapabiliriz, bplcon4 ($dff10c)
7 ila 4 arasındaki bitler, çift sprite'lar için kullanılacak 16 alt paletin “numarasını” seçmek için kullanılır
,
 3 ila 0 arasındaki bitler ise tek sprite'lar için
alt paleti seçmek için kullanılır.

bplcon4 ($dff10c) kaydının alt 8 bitine bakalım:

bit    “adı”

0    ESPRM7 \ Çift sprite'lar için kullanılacak alt paleti seçin
1    ESPRM6 \
2    ESPRM5 /
3    ESPRM4 /
4    OSPRM7 \ Tek sprite'lar için kullanılacak alt paleti seçin
5    OSPRM6 \
6    OSPRM5 /
7    OSPRM4 /

İşte paleti seçmek için bir referans tablosu:

bit 3 | bit 2 | bit 1 | bit 0 | Çift sprite
bit 7 | bit 6 | bit 5 | bit 4 | Tek sprite
------+-------+-------+-------+------------------------------------------
0 | 0 | 0 | 0 | $180/palet 0 (renk 0)
0 | 0 | 0 | 1 | $1A0/palet 0 (renk 16)
0 | 0 | 1 | 0 | $180/palet 1 (renk 32)
0 | 0 | 1 | 1 | $1A0/palet 1 (renk 48)
0 | 1 | 0 | 0 | $180/palet 2 (renk 64)
0 | 1 | 0 | 1 | $1A0/palet 2 (renk 80)
0 | 1 | 1 | 0 | $180/palet 3 (renk 96)
0 | 1 | 1 | 1 | $1A0/palet 3 (renk 112)
1 | 0 | 0 | 0 | $180/palet 4 (renk 128)
1 | 0 | 0 | 1 | $1A0/palet 4 (renk 144)
1 | 0 | 1 | 0 | $180/palet 5 (renk 160)
1 | 0 | 1 | 1 | $1A0/palet 5 (renk 176)
1 | 1 | 0 | 0 | $180/palet 6 (renk 192)
1 | 1 | 0 | 1 | $1A0/palet 6 (renk 208)
1 | 1 | 1 | 0 | $180/palet 7 (renk 224)
1 | 1 | 1 | 1 | $1A0/palet 7 (renk 240)
-------------------------------------------------------------------------

Kullanımı şu şekildedir: örneğin, çift ve tek sayı sprite'lar için
ikinci paleti, yani renk 16'dan renk 31'e kadar olan paleti seçmek istersem,
%0001 yazmalıyız, %0001'i ise 4
'ten 7'ye kadar olan bitlere yazmalıyız. Böylece alt bayt %00010001 olur.
Şimdi, benim tercihim OCS/ECS moduna karşılık geliyor, bu modda
sprite paleti her zaman renk 16'dan renk 31'e kadardır.
Aslında, onaltılık sistemde %00010001, $11'dir ve bu yüzden şunu yapıyoruz:

move.w    #$11,$10c(a5)        ; BPLCON4 sıfırlandı

Sprite paletini sıfırlamak için!!!
Bu gizemi çözdük, şimdi ayarı daha kullanışlı bir şekilde değiştirelim
: sprite paletini en alta taşıyarak, yani
color240'tan color256'ya kadar olmasını belirleyelim. Bu durumda %11111111 elde ederiz.
Şimdi ise çift sprite'lar için tek sprite'lardan farklı bir 16'lık banka seçebiliriz
!
Örneğin, çift sprite'lara 224'ten 240'a kadar renkleri ve tek sprite'lara
240'tan 256'ya kadar renkleri atayalım. Sonuç $dff10c'de %11101111'dir.

Bunu Lezione15f7.s'de uygulayalım.

******************************************************************************
BITPLANELER İÇİN YENİ SÜPER AKICI YATAY KAYMA (1/4 piksel)
******************************************************************************

1/4 piksel yatay kaydırma, bitplanes için de uygulandı.
Nasıl olduğunu tahmin edin? BPLCON1 ($dff102) bitlerine bitler ekleyerek.
Sprite'larda gördüğümüz gibi, , kaydırma değerinin “düşük”
birkaç biti eklendi. Ayrıca,
bir seferde 16 piksel, maksimum 64 piksel kaydırmaya izin veren iki yüksek bit de eklendi.
16 ve 32 piksel kaydırmaların yalnızca
burst (FMODE-$dff1fc) 32 veya 64 bit.
Böylece artık kaydırma 0 ila 64 piksel arasında, 1/4 piksel adımlarla yapılabilir.
Özetleyelim:
Daha önce her oyun alanının yatay sapma değeri
0 ila 15 (%1111) arasında değişebiliyorken ve 2 düşük bit ve 2 yüksek bit eklendi, 
şimdi 0 ile %11111111 arasında değişebilir, yani 0 ile 255 arasında (8 bitlik bir değer!) olabilir, ancak
1/4 piksel adımlar olarak anlaşılmalıdır, bu nedenle düşük çözünürlüklü piksel cinsinden ölçülen maksimum kaydırma
256/4=64'tür.
Ancak bu bitlerin eski bplcon1 ($dff102) yüksek baytına hangi konumda “yerleştirildiğini” görelim
:

BIT    “ad”        açıklama

15    PF2H7    \ kaydırma değeri playfield 2'nin yüksek bitleri (6 ve 7)
14    PF2H6    /
13    PF2H1    \ kaydırma playfield 2 değerinin düşük bitleri (0 ve 1)
12    PF2H0    /
11    PF1H7    \ kaydırma playfield 1 değerinin yüksek bitleri (6 ve 7)
10    PF1H6    /
09    PF1H1    \ kaydırma playfield 1 değerinin düşük bitleri (0 ve 1) kaydırma değeri oyun alanı 1
08    PF1H0    /

07    PF2H5    \
06    PF2H4     \ “orta” bit (2,3,4,5) kaydırma değeri oyun alanı 2
05    PF2H3     /
04    PF2H2	/
03    PF1H5    \
02    PF1H4     \ kaydırma oyun alanı değerinin “orta” bitleri (2,3,4,5) 1
01    PF1H3     /
00    PF1H2    /

Not:
PFxH0 biti 1/4 piksel (35ns) kaydırır
PFxH1 biti 1/2 piksel (70ns) kaydırır
PFxH2 biti 1 piksel (140ns) kaydırır
PFxH3 biti 2 piksel kaydırır
PFxH4 biti 4 piksel kaydırır
PFxH5 biti 8 piksel kaydırır
PFxH6 biti 16 piksel kaydırır (32 bit patlama aktif olmalıdır)
PFxH7 biti 32 piksel kaydırır (64 bit patlama aktif olmalıdır)

Gördüğünüz gibi, düşük bayt aynıdır, yüksek bayt ise AGA'ya özeldir.

Şimdi, bir bit düzlemini sağa doğru
1/4 piksel adımlarla, bplcon1 ile mümkün olan en yüksek değere, yani 64 düşük çözünürlüklü piksele eşdeğer 256 konuma kaydırmak istediğimizi varsayalım.
Scoll değerini 0'dan 255'e kadar 3 “parça”ya ayırmalıyız: iki düşük bit
PHxH0/1'e, 4 “orta” bit PFxH2-5'e ve iki
yüksek bit PFxH6/7'ye yerleştirilmelidir. Bu, birkaç AND ve LSL/LSR ile kolayca yapılabilir.

Lezione15g1.s (1 oyun alanı) dosyasında bir uygulamayı görelim.

Lezione15g2 dosyasında bir uygulamayı görelim.s (2 oyun alanı)

Şimdi 1/4 piksel hassasiyetinde bir “dalga” efekti yapmaya çalışalım,
bir sintab'ı bplcon1 değerlerine dönüştürerek ve bunu
copperlist'e satır başına bir kez değiştirerek: Ders15g3.s

Özel bir durum: şekil yüksek çözünürlüklü ise, kaydırmanın en yüksek biti “çalışmaz”,
 bu nedenle değerler 0 ile 127 arasında değişebilir. Ders15g4.s

*****************************************************************************
PALETİ DÖNDÜRMEK İÇİN YENİ BİR OLANAK
*****************************************************************************

BPLCON4'ün düşük bitlerinin işlevini daha önce gördük. Yüksek bitler ise
paletteki renkleri, palette kayıtlarının içeriğini değiştirmeden “değiştirmek” için kullanılır
.

BPLTCON4 ($dff10c)

BIT    AD

15    BPLAM7
14    BPLAM6
13    BPLAM5
12    BPLAM4
11    BPLAM3
10    BPLAM2
09    BPLAM1
08    BPLAM0


BPLAMx = Bu 8 bitlik alan, 8 bitlik düzlem renk adresi ile XOR`ed edilir, böylece
renk tablosuna gönderilen renk adresi değiştirilir (x=1-8)
BPLCON4'ün 15 ila 8 bitleri, 8 bit düzlem adresi için 8 bitlik bir maske oluşturur ve
tek tek bitleri XOR'lar. Bu, bakırın tek bir komutla renk haritalarını
değiştirmesini sağlar.

A ve B renkleri arasında bir değişim örneği görelim:

- Donanım renk kaydının içeriği değiştirilmez

- A rengi kullanılarak görüntülenen tüm pikseller artık
B rengi kullanılarak görüntülenir ve B rengi kullanılarak görüntülenen tüm pikseller
A rengi kullanılarak görüntülenir. (pratik olarak: DEĞİŞTİRİLMİŞTİR!)

- 00 renginden (2^n)-1 rengine kadar olan 2^n renk grubu
2^n renginden 2^n+(2^n)-1 rengine kadar olan 2^n renk grubuyla değiştirilir

- 2*2^n ile renk 2*2^n+(2^n)-1
arasındaki renk grubu, renk 3*2^n ile renk
3*2^n+(2^n)-1

arasındaki 2^n renk grubu ile değiştirilir. Değiştirme işlemi, donanım değiştirilecek başka renk grubu bulamadığında sona erer.

Örnek verelim: İkinci biti, BPLAM1 (BPLCON4'ün 9. biti) ayarları yaparsak,
işlem öncesi ve sonrası palet şöyle görünür:

ÖNCE        |    SONRA
---------------------------------------
Renk 00    |    Renk 02
Renk 01    |    Renk 03
Renk 02    |    Renk 00
Renk 03    |	Renk 01
Renk 04    |    Renk 06
Renk 05    |    Renk 07
Renk 06    |    Renk 04
Renk 07    |    Renk 05...
        |    ...

Renkler, 2^1=2 renk grupları kullanılarak değiştirilmiştir.

Tek bir renk değiştirilemez. Bir BPLAMx bitini değiştirirseniz,
tüm palet değişir.

Ancak değiştirme işlemleri birleştirilebilir. Birden fazla
BPLAMx bit ayarlanmışsa, her bit için değiştirme işlemleri
BPLAM0 bitinden başlayarak BPLAM7 bitine kadar sırayla gerçekleştirilir.

Örnek: $dff10c, $0500 (%0000010100000000) içerir. BPLAM0 ve BPLAM2 bitleri
ayarlanmıştır. Önce 2^0 renk grupları kullanılarak değiştirilir,
ARDINDAN sonuçta ortaya çıkan palet 2^2 renk grupları kullanılarak değiştirilir,
 aşağıdaki tabloda gösterildiği gibi:

ÖNCE        | BPLAM0 değişimi    | BPLAM1 değişimi
-----------------------------------------------------------------
Renk 00    |    Renk 01    |    Renk 05
Renk 01     |    Renk 00    |    Renk 04
Renk 02    |    Renk 03    |    Renk 07
Renk 03	|    Renk 02    |    Renk 06
Renk 04    |    Renk 05    |    Renk 01
Renk 05    |    Renk 04    |    Renk 00
Renk 06    |    Renk 07    |    Renk 03
Renk 07    |    Renk 06    |    Renk 02
Renk 08    |	Renk 09    |    Renk 13
Renk 09    |    Renk 08    |    Renk 12
Renk 10    |    Renk 11    |    Renk 15
Renk 11    |    Renk 10    |    Renk 14
Renk 12    |	Renk 13    |    Renk 09
Renk 13    |    Renk 12    |    Renk 08
Renk 14    |    Renk 15    |    Renk 11
Renk 15    |    Renk 14    |	Renk 10
...        |    ...     |    ...

Pratikte, BPLCON4'ün 8 bit BPLAM0-7'si, her bit için bir XOR (EOR) yapıldığından,
8 bit düzleminin adresi için bir maskedir.

Bu bitlerin etkilerinin sadece “eğitim amaçlı” bir örneğini görelim: Ders15h.s


****************************************************************************
DUAL PLAYFIELD AGA
****************************************************************************

Yeni Dual Playfield, playfield başına en fazla 4 bit düzlemine sahip olabilir (16 renk
bir playfield ve 16 diğer playfield) ve 256 renk paletindeki 16 renk bankası
her playfield için bağımsız olarak seçilebilir.

Çift Playfield'ı etkinleştirmek için, BPLCON0'ın 10. bitini her zamanki gibi
ayarlamanız, bitplanes'i seçmeniz (8 planes için BPLCON0'ın 12, 13, 14 bitlerini sıfırlayın
ve 4'ü ayarlayın, aksi takdirde 2 ila 6 arasında 12, 13, 14 bitlerini kullanın ve
4'ü sıfırlayın). Şimdi 2 figürü işaret etmek gerekir, biri çift bplpointer'da ve diğeri
tek bplpointers'da. Ardından, 2 resim için hangi renk banklarının kullanılacağını seçmek gerekir
,
 sprite'larda gördüğümüze benzer şekilde.

Bu, BPLCON3 ($dff106) bitleri 10,11,12 ile belirlenir:

| PF20F | İLGİLİ BITPLANE | OFFSET |
+---+---+---+-------------------------------+------------+
| 2 | 1 | 0 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | (ondalık) |
+---+---+---+-------------------------------+------------+
| 0 | 0 | 0 | - | - | - | - | - | - | - | - | 0 |
| 0 | 0 | 1 | - | - | - | - | - | - | 1 | - | 2 |
| 0 | 1 | 0 | - | - | - | - | - | 1 | - | - | 4 |
| 0 | 1 | 1 | - | - | - | - | - | 1 | - | - | 8 (varsayılan)|
| 1 | 0 | 0 | - | - | - | 1 | - | - | - | - | 16 |
| 1 | 0 | 1 | - | - | 1 | - | - | - | - | - | 32 |
| 1 | 1 | 0 | - | 1 | - | - | - | - | - | - | 64 |
| 1 | 1 | 1 | 1 | - | - | - | - | - | - | - | 128 |
+---+---+---+---+---+---+---+---+---+---+---+------------+

Playfield 2, Playfield 1'den önceliklidir. Gördüğünüz gibi
varsayılan durum, bit 10 ve 11 ayarlandığında ortaya çıkar, çünkü
varsayılan olarak $c00 (%110000000000) değerini $dff106'ya yerleştiririz.

******************************************************************************
*        VGA/PRODUCTIVITY 640x480 interlaced olmayan         *
*******************************************************************
***********

Demo ve oyunlar, televizyonlar veya 1084 gibi monitörler tarafından desteklenen PAL veya NTSC çözünürlüklerinde normal şekilde çalışır.
PAL dikey frekansı 50Hz, NTSC ise 60Hz'dir.
Yatay frekans 15Khz'dir.
Bildiğiniz gibi, bu iki frekans arasından seçim yapmak için şu şekilde yapmanız gerekir:

move.w    #$20,$dff1dc    ; BEAMCON0 - PAL modu

move.w    #$00,$dff1dc    ; BEAMCON0 - NTSC modu

Ancak bu, 1990
veya 1991'den önce üretilen eski Amiga bilgisayarlarında çalışmaz. Pratikte, A1000 ve ilk a500/a2000 modellerinde BEAMCON0'ı “içeren” FAT AGNUS yoktur,
bu kayıt ise
1990-91'den sonra üretilen A500/a2000 kickstart 1.3 modellerinde ortaya çıkmaya başlamıştır.
Ancak bir AGA makinesi KESİNLİKLE bu kayda da sahiptir.

Workbench 2.0'dan itibaren monitör türünü seçmenin ve
entrelaceless “VGA” video frekansı ayarlamanın mümkün olduğunu fark etmişsinizdir.
Yani 640x480 31KHz veya 800x600 ve diğer özel çözünürlükler.

NTSC (525 satır, tarama satırı başına 227,5 renk saati) 15Khz
PAL (625 satır, tarama satırı başına 227,5 renk saati) 15Khz
VGA (525 satır, tarama satırı başına 114,0 renk saati) 31Khz

Ancak, bu çözünürlükleri görüntülemek için en az “VGA”
veya multisync/multiscan özellikli bir monitör gerekir. Televizyonlar ve
1084 gibi “normal” monitörler bu frekansları yakalayamaz.

O zaman şöyle düşünebilirsiniz: Bir VGA/multisync monitör alayım, en azından
PAL/NTSC çözünürlüğünü ve 31Khz'lik taramalı olmayan çözünürlüğü görebilirim!
Ne yazık ki, 640x480 çözünürlüğü görüntüleyebilen monitörlerin çoğu
çözünürlüğünü görüntüleyebilen monitörlerin çoğu, 50/60Hz “televizyon” çözünürlüğünü görüntüleyemez, bu nedenle
bir çözünürlüğü görmek için bir monitör, diğerini görmek için
bir monitör daha gerekir. Bu nedenle dikkatli olmak gerekir! 
multisync/multiscan bir monitör satın almak istiyorsanız, önce
video oyunları/demolar için 320x256 PAL'ı doğru görüntülediğinden emin olun, örneğin C= 1950 gibi.

800x600 veya benzeri çeşitli video modlarını programlamak karmaşıktır ve
tüm monitörlerle uyumlu değildir, bu nedenle sadece 640x480 modunu nasıl yapacağımızı göreceğiz, bu mod
MSDOS PC'lerin en kötü VGA monitörleri tarafından da desteklenmektedir.

Şimdi senkronizasyon için bazı yeni kayıtlara bakalım:

VSSTRT        - VSYNC başlangıcı için dikey satır konumu.
VSSTOP        - VSYNC durdurma için dikey satır konumu.
HSSTRT        - HSYNC başlangıcı için yatay satır konumu.
HSSTOP        - HSYNC durdurma için yatay satır konumu.
HCENTER        - Interlace'de VSYNC için yatay konum.

Ve programlanabilir boşaltma için diğerleri:

HBSTRT        - HBLANK başlangıcı için yatay çizgi konumu.
HBSTOP        - HBLANK durdurma için yatay çizgi konumu.
VBSTRT        - VBLANK başlangıcı için dikey çizgi konumu.
VBSTOP        - VBLANK durdurma için dikey çizgi konumu.

Video modumuzla ilgili verilerimiz şunlardır:

VGA (525 satır, tarama satırı başına 114,0 renk saati) 31Khz

Bu nedenle VTOTAL'a satır sayısı-1 (524) ve HTOTAL'a
tarama satırı başına renk saati sayısı-1 (113) değerlerini ve diğer ayarları girmeliyiz.

Yatay frekansı 15Khz (TV, monitör 1084) değerinden VGA/Multiscan/Multisync monitörlerin 31Khz
değerine değiştirmek için, BEAMCON0 (diğer kayıtları etkinleştirmek için kullanılır)
kayıtlarının yanı sıra, birçok kayıt üzerinde işlem yapmamız gerekir:


LEA    $DFF000,A5

;5432109876543210
MOVE.W    #%0001101110001000,$1DC(A5) ; BEACON0 - ayarlanmış bit listesi:

; 3 - BLANKEN - COMPOSITE BLANK OUT TO CSY PIN
; 7 - VARBEAMEN - DEĞİŞKEN IŞIN SAYACI ENABLED
; Değişken ışın karşılaştırıcılarını
; ana yatay sayıcıda çalışmak üzere etkinleştirir
; ve ekranın yatay ve dikey donanım durdurmasını
; devre dışı bırakır.
; 8 - VARHSYEN - DEĞİŞKEN YATAY SENKRONİZASYON ENABLED
; HSSTRT/HSSTOP kayıtlarını etkinleştirir (HSY değişkeni)
; 9 - VARVSYEN - DEĞİŞKEN DİKEY SENKRONİZASYON ETKİN
; VSSTRT/VSSTOP kayıtlarını etkinleştirir (VSY değişkeni)
; 11- LOLDIS - UZUN/KISA HAT DEĞİŞTİRMEYİ DEVRE DIŞI
; Uzun/kısa hatlar arasındaki değişimi devre dışı bırakır.
; 12- VARVBEN - DEĞİŞKEN DİKEY BOŞLUK ETKİN
; VBSTRT/VBSTOP kayıtlarını etkinleştirir ve
; video penceresinin donanım “sonunu” devre dışı bırakır.

MOVE.W    #113,$1C0(a5)    ; HTOTAL - HIGHEST NUMBER COUNT, HORIZ LINE
; Yatay satır için maksimum renk saati:
; VGA, tarama satırı başına 114 renk saatine sahiptir!
; Değer 0 ile 255 arasında değişir: 113 uygundur!

MOVE.W    #%1000,$1C4(a5)    ; HBSTRT - HBLANK BAŞLANGICI İÇİN YATAY ÇİZGİ KONUMU
; Bit 0-7, yatay blanking'in başlangıç
; ve bitiş konumlarını
; 280 ns'lik artışlarla içerir. Bit 8-10,
; 35 ns (1/4 piksel) konumlandırma için kullanılır.
; Bu durumda 2240 ns ayarladık.

MOVE.W    #14,$1DE(a5)    ; YATAY SENKRONİZASYON BAŞLANGICI - Senkronizasyon başlangıcı için renk
; saat sayısı.

MOVE.W    #28,$1C2(a5)    ; HSYNC DURDURMA İÇİN YATAY ÇİZGİ KONUMU
; Senkronizasyon durdurma için renk saat sayısı.

MOVE.W    #30,$1C6(a5)    ; HBLANK DURDURMA İÇİN YATAY ÇİZGİ KONUMU
; Horiz BLANK durdurma yatay çizgisi

MOVE.W    #70,$1E2(a5)    ; HCENTER - VSYNCH'in interlace'de YATAY KONUMU
; değişken ışın sayıcıları durumunda.

MOVE.W    #524,$1C8(a5)    ; VTOTAL - EN YÜKSEK NUMARALI DİKEY ÇİZGİ
; En yüksek numaralı dikey çizgi, yani
; sayacın sıfırlanacağı çizgi
; dikey konum.
; VGA modunda 525 çizgi olduğunu biliyoruz.

MOVE.W    #0,$1CC(a5)    ; VBSTRT - VBLANK BAŞLANGICI İÇİN DİKEY ÇİZGİ
MOVE.W    #3,$1E0(a5)    ; DİKEY SENKRONİZASYON BAŞLANGICI

MOVE.W    #5,$1CA(a5)    ; VSYNC DURDURMA İÇİN DİKEY ÇİZGİ KONUMU
MOVE.W    #29,$1CE(a5)    ; VBSTOP - VBLANK DURDURMA İÇİN DİKEY ÇİZGİ

MOVE.W    #%0000110000100001,$106(a5)    ; 0 - harici boşluk etkin
; 5 - KENAR BOŞLUĞU
; 10-11 AGA çift oyun alanı düzeltmesi

Şimdi, BPLCON0 ($dff100) bitinin 0'ının ayarlanması gerektiğini ve 1'den fazla bit düzlemi isteniyorsa
FMODE ($dff1fc) ile 32/64 bit patlamayı etkinleştirilmesi gerektiğini unutarak, bakır listemizi $dff080'e yöneltin.
Örneğin: COPPERLIST: dc.w    $8E,$1c45    ; diwstrt dc.w    $90,$ffe5    ; diwstop dc.w    $92

Örneğin:

COPPERLIST:
dc.w    $8E,$1c45    ; diwstrt
dc.w    $90,$ffe5    ; diwstop
dc.w    $92,$0018    ; ddfstrt
dc.w    $94,$0068    ; ddfstop
dc.w    $1e4,$100
dc.w    $108,0        ; modül (değil -8??)
dc.w    $10A,0

; 640x480 boyutunda bir şekil işaretleyin.

BPLPOINTERS:
dc.w $e0,0,$e2,0    ; birinci     bit düzlemi
dc.w $e4,0,$e6,0    ; ikinci     “
dc.w $e8,0,$ea,0    ; üçüncü         ”
dc.w $ec,0,$ee,0    ; dördüncü	 “
dc.w $f0,0,$f2,0    ; beşinci     ”
dc.w $f4,0,$f6,0    ; altıncı         “
dc.w $f8,0,$fA,0    ; yedinci     ”
dc.w $fC,0,$fE,0    ; sekizinci     "

dc.w    $100,$1241    ; bplcon0 (hires bitini ayarlamayın, sadece
; plan sayısı ve 0-9 bitleri ile SHRES (6))

; burada palet

dc.w    $180,$000

dc.w    $1fc,$8003    ; sprite tarama iki katına çıkarma???
dc.w    $FFFF,$FFFE    ; Coplist Sonu


Ders15i.s'de pratik bir örnek görelim (31Khz görüntüleyebilen bir monitörünüz yoksa
sadece “çizgiler” göreceksiniz).

Bir not: Hiç kimse 31Khz'de bir demo veya oyun yapmamıştır, çünkü
VGA+ monitöre sahip Amiga kullanıcıları çok azdır. Bu modda grafik görüntüleme seçeneğini eklemeye karar verirseniz, önce
normal frekansı mı yoksa 31Khz'yi mi kullanmak istediğinizi soran bir pencere açmalısınız!
****************************************************************************************************************

**************************************************************************
*                ÇARPIŞMALAR                 *
**************************************************************************

7 ve 8 bit düzlemleri eklendiğinden, bu 2 düzlemle çarpışmaları kaydedebilecek bir CLXCON2 gerekliydi
.

CLXCON2     $dff10e    - Genişletilmiş çarpışma kontrolü -
bit düzlemleri 7 ve 8 algılamaya dahilse kontrol eder!
Bu kayıt, eski CLXCON'a yazıldığında sıfırlanır
- Bitlerin işlevi
CLXCON'dakine benzer

BIT    AD    AÇIKLAMA

15-08        Kullanılmıyor
07    ENBP8    Bit düzlemi 8 kontrolünü etkinleştir
06    ENBP7    Bit düzlemi 8 kontrolünü etkinleştir
05-02        Kullanılmıyor
01    MVBP8    Bit düzlemi 8 çarpışma için eşleşme değeri
00    MVBP7 Bit düzlemi 8 çarpışma için eşleşme değeri

Not: Bit düzlemlerini devre dışı bırakmak çarpışmaları önlemez: tüm düzlemler
devre dışı bırakıldığında çarpışmalar “sürekli” olur.

****************************************************************************
*				BLITTER ECS+
****************************************************************************

Blitter, ECS ile zaten bazı iyileştirmeler almıştı, ancak uyumluluk
için her zaman OCS modunda blitter kullanmak daha iyidir. Bunun yerine, AGA algılanırsa,
ECS+ blitter kullanabileceğinizden emin olabilirsiniz, tabii bu sizin için yararlıysa.

Pratikte BLTSIZV ($dff05c) ve BLTSIZH ($dff05E) eklenmiştir.
Bunlar, pratikte, klasik BLTSIZE ($dff058) yerine, blittğin DİKEY
ve YATAY boyutlarını girmek için kullanılan iki kayıttır.
Önce BLTSIZV'ye, ardından BLTSIZH'ye yazmanız gerekir, ardından bleaching başlar.
BLTSIZV'ye satır yüksekliği girilmelidir, bu değer 0 ile 32767 arasında olabilir.
Aynı yükseklikte bleaching işlemleri arka arkaya yapılırsa
BLTSIZV ($dff05c) dosyasına yeniden yazmanıza gerek yoktur, son girilen değer kalır.
Bliçleme, BLTSIZH ($dff05e) yazıldığında başlar, burada
bliçlemenin yatay boyutunu word olarak yazmak gerekir (0 ile 2047 arasında, yani
32768 piksele kadar). Bu 2 kayıt defterine sıfır yazmak, en yüksek değere eşittir,
“eski” BLTSIZE gibi.
Böylece, maksimum blittata,
eski maksimum blittata olan 1024x1024'e kıyasla 32768*32768'e çıkarılmıştır.

Ayrıca, birkaç önemsiz ayrıntı daha vardır:

1) $dff05b baytı (BLTCON0L), minterms'in LF baytına “benzer” bir bayttır,
yani BLTCON0'ın ($dff040) düşük baytıdır. Bazı blipping işlemlerini
biraz daha hızlı hale getiriyor gibi görünüyor, özellikle bltcon0'ın yüksek baytı
her zaman aynıysa ve düşük baytı buraya yazarak değiştirilirse....
Ancak, özel bir hızlanma fark etmedim.

2) BPLCON1 ($dff042) bit 7, “DOFF” olarak adlandırılır ve ayarlandığında
D kanalındaki blitter çıkışını devre dışı bırakır. Ancak bu,
A, B ve C kanallarına giriş veya adres değişiklikleri yapılmasına izin verir, ancak bunlar
D kanalına “yazılmaz”.


Umarım yeterince açık oldum ve AGA'yı programlamak için gerekli olan her şeyi
söyledim. Artık bahaneniz yok! AGA yonga seti için bir şeyler yapmalısınız
.

Her neyse, AGA'nız varsa 68020+'nız da vardır, bu nedenle
bunu ele alan bir sonraki dersi okumak sizin için yararlı olabilir!
