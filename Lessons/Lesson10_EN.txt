. : .
¦.:.:.:..::.::.¦
|::·· _____:!
| _____ ____ |
_! “____ | ||
/ __ | || ||
\ /\ `--°-”`-°--'| xCz
_ __ _________________)\ \____C¯ l___l___________________ __ _
¯¯ `---'
ASSEMBLER COURSE - LESSON 10
- -- ----------------------------------------------------- -- -

In this lesson, we will learn how to use the most advanced features of the
blitter.

***************************************************************
*                MINTERMS                 *
*******************************************************************************

In lesson 9, we said that the blitter allows us to perform
different types of operations. We also said that the type of operation is
defined by the MINTERMS, which are bits 0 to 7 of the BLTCON0 register, i.e.
the low byte (called LF - Logic Function byte) of that register. Depending
on the value written in these bits, the operation performed by the
blitter
changes. For example, we know that to clear the memory, the LF byte must be set to
$00, while to copy from channel A to channel D, it must be set to $f0.
These values were not chosen at random by the blitter designers,
but follow a very specific logic, which we will now explain.
First of all, let's clarify that the operations that can be performed by the blitter are
LOGICAL operations, i.e. NOT, AND and OR, which you should now be familiar with
(in reality, there are also those who can perform arithmetic operations, but
we will talk about that, perhaps, in the next disc!).
The blitter can also combine several operations of this type in a
single blit. But let's go in order.
As you know, the blitter has three input channels and one output channel. For the moment,
 let's not worry about enabling or disabling the channels.
A blit is a logical operation that takes three input values
through the three channels A, B, and C and produces a result through channel D.
Like all logical operations, it is performed bit by bit, even though the
blitter always reads (and writes) words, just like the 68000 does with
a logical instruction such as AND.
Therefore, each bit of the output word is calculated based on the values of the
corresponding bits of the input words.
The 3 input bits can give rise to 8 different combinations.
A blitter operation is defined by establishing, for each possible
combination of input bits, whether the output result will be 0 or 1.
In practice, each of the 8 minterms (bits 0 to 7 of BLTCON0) is
associated with a different combination of input bits; if the minterm is 0,
it means that the input combination produces a result of 0, if
it is 1, the result will be 1.

This can be visualised with a truth table, as shown below.
The three source channels are listed, along with the possible values for a single bit
of each. The bit associated with each combination is shown alongside.


A    B    C         BLTCON0 position
-    -    -     -----------------

0    0    0            0

0    0    1            1

0    1    0            2

0    1    1             3

1    0    0            4

1    0    1            5

1    1    0            6

1    1    1            7

Fig. 27    MINTERMS

For example, if we want a bleed to produce an output equal to 1 when
input A is 0, B is 1 and C is 0, and to produce an output
equal to 0 in all other cases, we must set minterm 2 to 1 and reset
all other minterms to zero. We will then write the value $04 in the LF byte.
For another example, the value $80 (= 1000 0000 binary) in LF sets only
the destination bits for which the corresponding bits of sources A,
B, and C are all set to 1.
All other destination bits corresponding to other combinations
for A, B, and C are reset to zero.
This is because bits 6 to 0 of the LF byte take the value 0.
Of course, it is possible to set more than one minterm to 1 at the same time.
For example, if we set LF to the value $42 (= 0100 0010 in binary), we “turn on”
2 minterms.
Therefore, with this value, we will have an output equal to 1 in two cases: when
A=0, B=0, and C=1 (corresponding to bit 1 of LF) and when A=1, B=1, and C=0
(corresponding to bit 6 of LF). In the other cases, we will have an output equal to 0.
Let's now try to understand the meaning of the minterm values we
used for deletion and copying.
In the case of deletion, we have LF=$00.
All minterms are worth 0. This means that for any combination
of source channels, the output is always 0.
In practice, whatever we read, we always write 0, i.e. we delete (
in reality, during deletion we do not read anything because we do not enable
channels A, B and C, but we still have to set LF=$00, we will explain why
later). To make a copy from A to D, let's set, as you know,
LF=$F0 (=%11110000). In this way, the output is 1 for 4
different combinations, while it is 0 for the remaining 4. As you can see
in the table in fig. 27, the combinations corresponding to the minterms that 
we have set to 1 are all the possible combinations with A=1, and in the
in the same way, the combinations corresponding to the minterms set to 0
are those with A=0. This means that every time A=1, the output is 1
and when A=0, the output is 0, regardless of the value of B and C.
In practice, this means that the output takes on the same value as channel A, and is therefore
an exact copy of it. If we wanted to copy from channel B to channel D,
we would have to use a different LF value, setting the minterms that
correspond to the combinations with B=1 (which, as can be seen in Fig. 27, are
minterms 2, 3, 6 and 7) and setting the others to zero (minterms 0, 1, 4 and 5), obtaining
LF=$CC (=%11001100).
By programming the minterms appropriately, many operations can be performed with the
blitter.
Suppose, for example, that we want to set all the pixels of a rectangle to 1
(basically the opposite operation to deletion, which sets all
bits to 0).
As with deletion, we only use the output channel.
What we want is for the output to always be 1, for any combination
of inputs.
To achieve this result, we set all minterms to 1, obtaining LF=$FF.

You can see this operation in the example lesson10a1.s.

In the example lesson10a2.s, we show the NOT operation.

Please refer to the listing for an explanation.
______ ______
(:::::\`~-. ___ /|\ ___ .-~ /:::::)
`\:::::\ `\ __\\\\|||||////__ /“ /:::::/”
`\-::::\_ `\.\\\\\|||||////./“ _/::::-/”
`--..__`\/ \\\\|//// \/ __..--“
>” .--. `\ /“.--. `<
_...--/ -< | | >- \--..._
/ \ `\()| |()/” / \
/|| `\| ____. ` “ .____ |/” ||\
/||| | “ `\ /::\ /” ` | |||\
|||||\ .---. __|_. /::::::\ ._|__ .---. /|||||
|||||||-._|_ `-._ /::::::::::\ _.-' _|_.-|||||||
\||||||||||| /::/“ |::| `\::\ |||||||||||/
\|||||||||| /::/ |::| \::\ ||||||||||/
`\||||||||\ (:::`---”::`---“:::) /||||||||/”
/ `-._`-.::::::::::::.-“_.-” \
| .________. |
| |
| |
| |
\ /
`\ /“
`~-.________________________.-~”

Let's now move on to an example of a 2-operand operation, for example OR.
We want the output to be equal to the OR of channels A and B.
Looking back at the truth table for OR, we can see that the output must
be 1 in all cases where A=1 and in all cases where B=1.
As you can see from Fig. 27, there are a total of 6 cases that give rise to
LF=$FC.

The example lesson10b1.s shows an OR operation, while the example
lesson10b2.s performs an AND operation.

Another way to calculate the LF byte that performs a particular operation
is through the use of Venn diagrams:

______ 0 ______
/     \ / \
/     \/     \
/     /\     \
/ A     / \ B    \
| -     | | -     |
|     | 6 |     |
|    4 |____| 2     |
|     /| |\     |
|    / | 7 | \     |
\ / \ / \    /
\ / 5 \/ 3 \ /
\ |     /\     | /
\|_____/ \_____|/
|		 |
|     1     |
|         |
\         /
\ C     /
\ - /
\______/


Fig. 28    Venn diagram

Let us illustrate the use of this diagram with a few examples


1. To select a function D=A (i.e., destination = source A only),
select only the minterms that are totally included in circle A in the
figure above. This is the series of minterms 7, 6, 5, and 4. When
written as a series of 1s for the selected minterms and 0s for the
unselected ones, the value becomes:

Minterm number        7 6 5 4 3 2 1 0
Selected minterms    1 1 1 1 0 0 0 0
-----------------
F 0 or $F0

2. To select a combination function of two sources, look for the
minterms from both circles (their intersection). For example, the
combination A ‘AND’ B is represented by the area common to circles
A and B, i.e. minterms 7 and 6.

Minterm number        7 6 5 4 3 2 1 0
Selected minterms    1 1 0 0 0 0 0 0
-----------------
C 0 or $C0

3. To use a function that is the inverse, or ‘NOT’, of one of the sources, e.g.:

NOT A

take all minterms not included in the circle represented by A.
In this case, we have minterms 0, 1, 2, and 3.


Number of Minterms        7 6 5 4 3 2 1 0
Selected Minterms    0 0 0 0 1 1 1 1
-----------------
0 F, i.e. $0F


4. To combine minterms, i.e. an ‘OR’ between them, perform an OR of the values.
For example, the operation (A AND B) OR (B AND C) becomes

Minterm number            7 6 5 4 3 2 1 0
A AND B                1 1 0 0 0 0 0 0
B AND C                1 0 0 0 1 0 0 0
-----------------
(A AND B) OR (B AND C)        1 1 0 0 1 0 0 0
-----------------
C 8 or $C8


In any case, if you really want to save yourself the trouble (bad, LAZY! :),
here is a table of the most commonly used Minterm values.
This table uses a different notation from the one used so far:

If two terms are adjacent, an AND operation is performed between them
(e.g. AB means A AND B);

a dash above a term indicates NOT:
_
(e.g. A means NOT A);

if two terms are separated by a “+”, an OR is performed between them
(e.g. A+B means A OR B);

AND has the highest priority, so AB + BC is equal to (A AND B) OR (B AND C).
Here is the table:

Operation    Value        Operation    Value
Selected     LF        Selected     LF
--------    -------        --------    -------
D = A         $F0        D = AB         $C0
_
D = A         $0F        D = AB         $30
_
D = B         $CC        D = AB         $0C
_
D = B         $33        D = AB         $03

D = C         $AA        D = BC         $88
_
D = C         $55        D = BC         $44
_
D = AC         $A0        D = BC         $22
_
D = AC         $50        D = AC         $11
_                     _
D = AC         $0A        D = A + B     $F3
_                 _     _
D = AC         $05        D = A + B     $3F
_
D = A + B     $FC        D = A + C     $F5
_
D = A + B $CF D = A + C $5F
_
D = A + C $FA D = B + C $DD
_
D = A + C $AF D = B + C $77
_
D = B + C     $EE        D = AB + AC     $CA
_
D = B + C     $BB


Fig. 29    Most commonly used minterms


NOTE: To find the desired LF value for your purposes, you can
also use the ‘minterm’ utility, programmed by Deftronic, the same as
Trash'M'One.
This short utility can be found on this disk.
The syntax is as follows: for NOT, enter the channel letter without shifting
(lowercase), for example ‘abc’.
For the normal channel, use the shifted letter (uppercase).
Two adjacent letters mean an AND between the channels, while if they are separated
by ‘+’ it means an OR between the channels.
__
Example: if you want ABC:

minterm    Abc

result: $10

Example 2: if you only want source A:

minterm    A

result: $F0    (as expected)

Example 3: if you only want (A AND B) OR C:

minterm	AB+C

result: $DA.

___________
\ _/___
\____________)
|. _ |
|___/ |
`------'
./ _ \.
__ |___/ ) |
(__|_____/ |
|________|____. _ __ ____
| _) | - --- --- --- -( )
| |----. | -- - ( ( ) )
__| | |__| _ - -- -- vrooom ) )
___|_____|________/ | --- -- - ---( ( ( )
(____________________| (____ _ __)
(_) (_)

*******************************************************************************
*                THE BOBS                     *
*******************************************************************************

We are almost at the main part of the lesson, namely the BOBs.
Before tackling them, we need to introduce another idea: the bit-plane
mask. This is simply a bitplane that forms the “shadow” of
a figure, i.e. a bitplane of the same size as a figure that has
set the pixels corresponding to the pixels of the figure to 1, coloured with a
colour different from the background, and set the pixels corresponding to the
background colour of the figure to 0.
For example, consider the following table of numbers:

0020
0374
5633
0130

This represents an 8-colour image (3 bitplanes) 4 pixels wide and 4 rows high.
Each number indicates the colour associated with the pixel. The mask for this
image is as follows:

0010
0111
1111
0110

Note that colours other than 0 (the background) have at least one bitplane
set to 1.

Therefore, the mask can be constructed from the figure by doing the OR
of all the bitplanes, as illustrated in the examples lesson10c1.s and lesson10c2.s
which also allow you to review the use of the blitter to perform
logical operations. In particular, in lesson10c2.s we show for the first time
a blitter that uses all 4 channels of the blitter.

The Kefrens Converter, however, has an option to automatically create the
mask of a figure.
Mask bitplanes are useful because they allow us to display
parts of an image based on the shape of another image.

We see examples of this in lesson10c3.s and lesson10c4.s, where we use a
circle-shaped mask to create a reflector that illuminates an image,
 making part of it visible.

Although the two examples achieve the same effect, they use very different techniques
, as explained in the comments.
Study lesson q4.s particularly carefully, as it is essential for understanding
BOBs later on.
In this example, the mask bitplane is used to ‘select’
parts of an image consisting of 5 bitplanes. The selection is made by performing an
AND operation between the mask bitplane and the 5 bitplanes that make up
the image. Since the image is in normal format, 5 separate 
blits are performed, one for each plane. The mask is obviously always the
same for each blit (it consists of a single bitplane).
If we want to apply the technique from example lesson10c4.s to a screen in
interleaved format, we encounter a problem. When we operate
in this format, we actually blits all the planes at the same time.
However, the mask has the size of a plane and therefore cannot be
used in a bitmap that has a size equal to the number of planes that
make up the image. To solve this problem, we need to modify
our mask. Since each row of the mask must select the corresponding row
corresponding row of ALL the bitplanes in the figure, we must repeat the row
as many times as there are bitplanes. In interleaved format, therefore, we must
use a mask bitplane that has each row repeated as many times as there are
bitplanes in the figure. In the case of the figure we saw earlier
(3 planes), our interleaved mask is as follows:

0010\
0010 |    - first row of the normal mask repeated 3 times
0010/
0111
0111
0111
1111
1111
1111
0110
0110
0110

As you can see, since the figure has 3 bitplanes, each line of the
mask in normal format has been repeated 3 times to obtain
the interleaved mask. The interleaved format, therefore, forces us to
use a mask that takes up more memory than that required by the
normal format.

The example lesson10c5.s is the interleaved version of lesson10c4.s, and allows us
to see what we have said in practice.

___
_( )_ 
__( . . .)__ 
_( _ .. ._ . )_ 
( . _/(_____)\_ )
(_ // __ | __ \\ __)
(__( \/ o\ /o \/ )__)
( .\_\__/ \__/_/. )
\_/¬(_. ._))\_/
/___( )___\
( | |\___/| | )
 
||__| | |__||
||::|__|__|::||
||:::::::::sc||
.||:::__|__:;:||
/|. __ __ .|\.
 
./(__..| . .|.__) \.
(______|. .. |______)
/| |_____|
/|\
:

If you have understood how masks work, you are ready to
solve the background problem with BOBS once and for all.
As you will remember, in the example in lesson9i3.s we came quite
close to solving the problem. The background is saved and then
redrawn in its place. The only problem is that in the rectangle surrounding
the BOB figure, the background is deleted and replaced with colour 0.
In reality, when we draw a BOB, we do not use the colour 0 as just any colour,
 but simply to denote the pixels of the rectangle that do not
belong to the BOB figure. It is exactly the same thing we do
with sprites: we use the colour 0 as “transparent”.
When we draw the BOB on the screen, we want the background to appear in place of the pixels coloured 
with colour 0. In practice, we should only be able to write pixels of a colour other than 0 on the
screen.
This is not possible because, as you know, the blitter writes (and reads) ALWAYS
WHOLE words.
We therefore adopt a different strategy. Instead of simply copying the
BOB to the destination, we perform a more complicated blitting operation.
We read the background from memory, as well as the BOB, and “mix” them together,
so that the pixels of the background appear in place of the pixels of colour 0 in the BOB
background appear, and we write the result on the screen.
The strategy is illustrated in the following figure, in which we have a BOB
and a 6*8 pixel piece of background.
The symbol “.” represents a pixel of colour 0, the symbol “#” represents
a pixel of the BOB of a different colour, and the symbol “o” represents a pixel
of the background of a different colour:


BOB            BACKGROUND........

        ...o....
..####..        ...oo...
.#.##.#.        ..oooo..
..####..        ..ooooo.
...##...        .ooooooo
..#..#..        oooooooo

\             /
\             /
\             /

BOB superimposed on BACKGROUND
...o....
..####..
.#o##o#.
..####o.
.oo##ooo
oo#oo#oo


Fig. 30    Bob and background

This gives us the desired effect.
It remains to be understood how to "mixthe BOB with the background.
To ‘mix’ correctly, we need to know which pixels in the BOB are
colour 0 and which are not.
This information is contained in the BOB's mask bitplane, which, as
you know, has a bit set to 0 for each pixel of colour 0 in the BOB and a bit set to 1 for each
pixel of any other colour.
The mixing operation is therefore carried out as follows:

- For each pixel, we read the mask
- If the mask has a value of 1, we copy the corresponding pixel from the BOB
- If the mask has a value of 0, we copy the corresponding pixel from the background.

We can carry out this procedure with a single blit, operating
as follows: we read the mask through channel A of the blitter, the
the BOB through channel B, the background through channel C, we use the mask
to select the pixels to be copied (either from the background or from the BOB) and write the
result in channel D (the assignment of channels is not random).
The selection is made using the following logical equation:

D = (A AND B) OR ( (NOT A) AND C)

This equation behaves exactly like the selection procedure
described above. When the mask A = 1 (i.e. we have a
BOB pixel with a colour OTHER than 0), the equation is simplified as follows
:

D = (1 AND B) OR ( (NOT 1) AND C) = B OR (0 AND C) = B OR 0 = B

The BOB pixel is then copied.
When A = 0 (i.e. we have a BOB pixel with colour 0), the equation
becomes:

D = (0 AND B) OR ( (NOT 0) AND C) = 0 OR (1 AND C) = 0 OR C = C

The background pixel is then copied.
This logical equation is executed by the blitter (as you can calculate
yourselves) by setting LF = $CA, a value known as ‘COOKIE CUT’ or ‘cookie cut’
. As mentioned earlier, the channels have been assigned
carefully based on their characteristics.
In fact, to make smooth horizontal movements, it is necessary to use
the blitter shift for the BOB and the mask; for this reason, channel C
(which cannot shift) is used for the background. In addition, we apply
the trick of masking the last word to the mask bitplane, so that
the last word of it is reset, thus causing the background to be blitted in the last word
.

The examples lesson10d1.s and lesson10d1r.s show (in normal and interleaved versions, respectively) the long-awaited BOB moving on a background.
_|_ __|__ |___| |\ |o__| |___| | \ |___| |___| |o \ _|___| |___| |__o\ /...\_____|___|____\

_|_
__|__ |___| |\
|o__| |___| | \
|___| |___| |o \
_|___| |___| |__o\
/...\_____|___|____\_/
\ o * o * * o o /
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*******************************************************************************
*        BLITTER SPEED (AND MORE)             *
*******************************************************************************

It's time to deal with a very important issue: the
speed of the blitter. As you know, the blitter takes a certain
amount of time to complete its tasks, and this must be taken into account
when programming complex effects.
To measure the speed of the blitter, we will use a very simple technique,
known as "copper monitor‘, which shows us the result on the screen in
real time.
The technique is very simple: we use a certain colour (usually black)
as the background.
Then, just before starting the blitting, we change the background colour with the
processor, using a ’MOVE.W #$xxx,$dff180".
When the blitting is finished, we restore the background to its initial colour.
This way, we know that the blit takes a time proportional
to the portion of the screen that is coloured differently.
Note that this technique is used to measure any type of routine,
and is particularly useful for understanding when it becomes faster or slower
following a change, such as an optimisation.

An example is shown in lesson10e1.s

In this example, we use the blitter to copy a rectangle onto the screen.
Based on this example, we can begin to make some observations
about the speed of the blitter. First of all, as we have already mentioned, the
speed depends on the size of the blitter.
Try changing the height and/or width of the rectangle in the example,
and you will see for yourself.
This is reasonable, as the larger the rectangle, the greater
the number of words to be moved. Similarly, the number of bitplanes
affects the speed (try changing the number of
iterations of the ‘DrawObject’ routine in lesson10e1.s), because the more bitplanes there are,
 the greater the amount of data to be moved.

The example lesson10e1r.s is the rawblit version of the previous example.

When you run it, you will notice that it is slightly faster.
But then, you may ask, what is the advantage of rawblit?
In reality, as we have already mentioned, the rawblit technique is useful not
so much because it speeds up the blitter, but rather because it saves time
for the processor.
In the two examples we have seen so far, we have only measured the time taken
by the blitter.

In the examples lesson10e2.s and lesson10e2r.s, however, we use different colours
to highlight both the time taken by the blitter and that taken by the
processor.

A comparison of these examples fully demonstrates the advantages of rawblit mode:
with this technique, the processor is only busy for a very short time, just long enough to
load the blitter registers, and is then free to perform other tasks,
unlike in normal mode, where the processor must
wait for the end of a blit to launch the next plane
blit.
It is clear that to take advantage of the rawblit technique,
the routine following the blit must NOT use the blitter.
In fact, if (as in the examples) after a blit there is immediately a
routine that uses the blitter, the processor will still have to wait for
the blitter to finish its task, and we will therefore have no advantage.
Therefore, a criterion to follow in order to optimise programmes is to place,
where possible, routines that use the blitter “far apart”, i.e.
interspersed with other routines that do not use it, so that the blitter
and the processor can proceed in parallel.
It should be noted, however, that this criterion is particularly valid on machines
equipped with fast memory, since if the processor has to access the chip memory
chip, memory access conflicts are generated, which we will discuss
in more detail in a moment.
For now, let's note another thing about the examples lesson10e2.s and lesson10e2r.s:
the blitter takes about the same time to clear (green screen)
and to draw (red screen). If you think about it, this should
seem strange: it is true that the two blits are the same size,
 but we must consider that clearing is a blit that uses only one
channel, while copying uses two. It is clear that as the number of
channels increases, the number of words read and written by the blitter increases, so the
blit should take longer.

o . o . o . o . o . o
o
..
 ___
_n_n_n____i_i ________ ______________ _++++++++++++++_
*>(____________I I______I I____________I I______________I
/ooOOOO OOOOoo oo oooo oo oo ooo ooo
------------------------------------------------------------

Guardate pero` l'esempio lezione10e3.s.

This example is similar to the previous ones, but instead of making a simple copy
of the figure, it performs an OR operation between the figure and a zeroed plane.
Of course, the effect is always the same, but you can see how the
routine, which performs a 3-channel blit (D=A OR B), is now considerably
slower.
The speed depends on which and how many channels are used in a
rather complicated way, which can be summarised in the following table:

bit 8-11
of Channels 
BLTCON0 used     Memory access sequence
--------- -------- --------------------------------------
F A B C D A0 B0 C0 - A1 B1 C1 D0 A2 B2 C2 D1 D2
E A B C A0 B0 C0 A1 B1 C1 A2 B2 C2
D A B D A0 B0 - A1 B1 D0 A2 B2 D1 - D2
C A B A0 B0 - A1 B1 - A2 B2
B A C D A0 C0 - A1 C1 D0 A2 C2 D1 - D2
A A C A0 C0 A1 C1 A2 C2
9 A D A0 - A1 D0 A2 D1 - D2
8 A A0 - A1 - A2
7 B C D B0 C0 - - B1 C1 D0 - B2 C2 D1 - D2
6 B C B0 C0 - B1 C1 - B2 C2
5 B D B0 - - B1 D0 - B2 D1 - D2
4 B B0 - - B1 - - B2
3 C D C0 - - C1 D0 - C2 D1 - D2
2 C C0 - C1 - C2
1 D D0 - D1 - D2
0 none - - - -

This table shows, for each combination of active channels, the sequence
of memory accesses performed by the blitter, in the case of a
3-word blit.
For each access, the channel performing it is indicated, and the dashes
indicate bus cycles not used by the blitter. For example, the string:

A0 B0 - A1 B1 - A2 B2

indicates that channel A (A0) first accesses the bus, then B (B0), then the blitter
does not use a bus cycle (allowing the processor to access the
memory), then it is the turn of channel A (A1) again, and so on.

The table shown is only indicative, because it does not take into account
many factors, such as the use of special blitter modes and
competition with the processor and other DMA channels (see
lesson 8 for more information). Nevertheless, it is very useful for getting an idea of
the best channel combinations. Keep in mind that this
table refers to a 3-word blit. For blits of more words
, the blitter repeats the sequence of accesses shown in the table
‘in the middle’ as many times as necessary. For example, a 5-word blit using channels
A and D has the following sequence:

A0 - A1 D0 A2 D1 A3 D2 A4 D3 A5 D4 - D5

Studying the table allows us to make some interesting observations.
If we look at the sequence relating to the use of channel D alone, we see that the
blitter uses the bus every other cycle. On the contrary, when
channels A and D are used, the blitter uses (except in the cases of the first and
last words) all bus cycles. This explains why
in the examples the deletion routine (channel D) has approximately the same
speed as the drawing routine (channels A and D). Note, however, that if
we make a copy from B to D, things are different.

You can see this in practice in lesson10e4.s.

Similarly, consulting the table, we see that in the case of blitting with
2 sources, it is better to use A and B or A and C, but not B and C because
more cycles are wasted.

However, you must remember that the speed of the blitter also depends on
any conflicts with other DMA channels (video, audio, copper, processor)
that can “steal” cycles from it, causing delays. In fact, as we explained in
lesson 8, the blitter has priority over the CPU when accessing the bus.
This means that if another device (e.g. the copper) wants to access
the RAM at the same time as the blitter, the other device has priority
.
The only thing that gives priority to the blitter is the processor.
However, even here the priority is not absolute. In fact, the blitter, showing
great generosity, if it notices that the processor has tried to access the bus three times in a row
but has not succeeded because someone else
has taken precedence, it says: ‘Go ahead this time,’ and grants it
the bus for one cycle.
This mechanism reduces the possibility that, in cases of DMA overload,
 the processor will be blocked waiting for the bus for too long.
However, it is possible to suppress the blitter's generosity.
By setting bit 10 (called blitter_nasty) of the
DMACON register to 1, the blitter will no longer behave in this way, but will 
take precedence over the processor every time.
If the routines of our programme all use the blitter,
so that the processor does nothing but load the registers and wait,
 it is definitely advisable to set this bit to 1.
Obviously, this makes sense if the program is contained
in chip memory and there are no caches, because otherwise there will be
no conflicts between the processor and the blitter for access to the RAM.

An example of the Blitter Nasty bit can be found in lesson10e5.s.

To optimise the use of the blitter, you need to speed up the
writing of the registers related to it as much as possible.
In the examples we have given so far, and also in those we will give in the rest of
the lesson, for the sake of clarity, we have not optimised
the register writing as we could have done.
During a blit, the only registers that change are the BLTxPT and
BLTSIZE registers. The BLTCONx, BLTxMOD and BLTxWM registers remain constant.
This means that if the contents of these registers are not modified by
other routines, there is no need to rewrite them at the beginning of each blit.
A precaution to take to optimise the routines in the event that there
are blitting loops is to place the values to be written in the
blitter registers in processor registers, and replace the MOVE.W #YYY,$DFFxxx inside the loop
with MOVE.W Dx,$DFFxxx, which are faster.
These optimisations in register writing, taken one by one, give
very small speed increases, which are difficult to notice with the copper monitor.
 However, in a demo with many complex effects, when put together they have
an impact.

As an example, look at the listing lesson10e6.s, which is a version
optimised with these tricks from lesson10c3.s.

\\\|/// 
\\ ~ ~ //
( @ @ )
______________________________oOOo_(_)_oOOo____________________________________
*******************************************************************************
*            DOUBLE BUFFERING                 *
*******************************************************************************

All the examples we have seen so far relating to bobs always had a
single bob moving on the screen. Let's now try to add more.
For example, let's try to apply the ‘fake’ background technique: we use
a bitplane for the background and 3 planes where the bobs can move.
Since all the bobs move on the same bitplanes, we will still have to
draw them using the bitplane mask technique.
However, we will have the advantage of not having to save and restore the background,
because the bitplanes of the bobs are initially reset to zero.
It will therefore be sufficient to delete these planes at each frame, before
redrawing the bobs in their new positions.

This technique is applied in the example lesson10f1.s.

However, when you run this programme, you will have an unpleasant surprise: the bobs are
drawn correctly only in the lower part of the screen, while in the upper
part they are not drawn correctly. Why is this?
Is there a bug in our routines? No, our routines are fine.
The problem is that they are too slow. As you know, while our
program is running, the electronic brush draws the image on the
screen.
To make an image appear stable, we try to modify the screen
(i.e. erase, draw bobs, lines, etc.) during the Vertical Blank,
i.e. the period of time when the electronic brush is inactive.
However, if we have to make many changes to the screen, it may happen that
our routines are not fast enough to do their job
during the Vertical Blank. This is exactly what happens in this case.
By increasing the number of bobs, the time needed to draw them increases and
as a result, it is no longer possible to do so during the Vertical Blank.
The result is that sometimes the bobs are drawn on the screen AFTER
the electronic brush has drawn that part of the screen, and therefore the bobs
are not displayed.
Since the electronic brush moves from top to bottom, the higher the bobs are
drawn, the more often this happens.
If you look closely at the example, you will see that the area of the screen in which
all the bobs are drawn correctly is the one that is displayed AFTER
the drawing routines have finished their work, as highlighted
by the copper monitor.
The ‘double buffering’ technique allows us to solve this problem.
This is a general-purpose technique that you can use with any
effect, not just bobs. In particular, we will use it for 3D routines.
This technique consists of using two screens (called buffers)
instead of just one.
The two buffers are displayed alternately, one frame at a time
.
While one of the buffers is displayed, we can draw freely
on the other, without worrying about stability, since the image that is
displayed is that of the first buffer, which we do not modify.
When the next Vertical Blank occurs, the two buffers are swapped.
The one we drew on previously is displayed,
showing the changes we made, while the buffer that was previously displayed
is now available for us to draw on.
By repeating the swap at each Vertical Blank, we will always have a
buffer that is not displayed on which to draw, without worrying about what
the electronic pen is doing.
Thanks to this technique, the only time limitation on our drawing routines
is that they must end before the electronic brush
reaches the end of the screen. This gives us a time equal to 1/50th of a
second (in Pal, 1/60 in NTSC).


<>+<> ////// __v__ __\/__
`\|||/ /---\ ‘’‘“”’" | _ - | (_____) . / ^ _ \ .
(q p) | o o | <^-@-@-^> (| o O |) .(O O), |\| (o)(o) |/|(
_ooO_<_>_Ooo_ooO_U_Ooo_ooO__v__Ooo_ooO_u_Ooo_ooO__(_)__Ooa__oOO_()_OOo___
[_____}_____!____.}_____{_____|_____}_____i____.}_____!_____{_____}_____]
__.}____.|_____{_____!____.}_____|_____{.____}_____|_____}_____|_____!__
[_____{_____}_____|_____}_____i_____}_____|_____}_____i_____{_____}_____]
*******************************************************************************
*        USE OF NON-ACTIVATED BLITTER CHANNELS             *
*******************************************************************************

There are cases in which it is useful to have non-active channels also ‘participate’ in the blitter.
To understand what this means, you need to know one more thing about the blitter.
To understand what this means, you need to know one more thing about the blitter.
When an input channel (A, B or C) is active, it reads words from memory.
Each word, after being read, is copied to a special register called the
blitter data register.
Each channel has its own data register, whose name includes the letter that
identifies the channel: we therefore have BLTADAT (channel A, $DFF074), BLTBDAT
(channel B, $DFF072), BLTCDAT (channel C, $DFF070) and BLTDDAT (channel D $DFF000).
The word from the data register is then subjected to logical operations
with the words coming from the other channels, and the result is
written to memory through channel D.
Let's take an example to understand this better. Consider the case of a blitter that
performs an AND between channels B and C.
The following happens inside the blitter:

1 - Channel B reads a word and copies it to BLTBDAT
2 - Channel C reads a word and copies it to BLTCDAT
3 - An AND operation is performed between the contents of BLTBDAT and BLTCDAT
4 - The result is written through channel D
5 - Steps 1 to 4 are repeated for the subsequent words.

In reality, things work a little differently, because some operations
are performed in parallel to speed up the blitter, but at a logical level
things work like this, and that is what we need to know.
What happens when a channel is disabled? Of course, it will not read
anything from memory, so the corresponding BLTxDAT register will not be
changed.
The contents of this register are retained and can still be used
in logical operations.
In addition, this register can also be written by the CPU, which allows us
to set it to appropriate values (not the BLTDDAT register!).
The situation is similar to what we saw in lesson 7 for sprites.
Sprites
also have DMA channels (the SPRxPT registers) that copy the data
read into data registers (SPRxDAT).
In some applications, however, it is useful to write to the data registers directly
with the processor (or with the copper).
Let's now look at the usefulness of this blitter feature.
For example, consider the case where we want to fill a series of
memory locations with a constant value, for example to draw a
rectangle on the screen that is not filled, but ‘striped’, or as graphic designers say, with
a ‘pattern’ (i.e. a texture).
We can solve the problem by storing our rectangle in the
data section of our programme and copying it with the blitter, exactly as if
it were a figure like any other.
However, a better solution is offered by the possibility of
disabling the blitter channels.
To solve the problem, we can copy from channel A to
D, KEEPING CHANNEL A disabled, and writing the ‘pattern’ in the
BLTADAT register. This gives us two advantages: we don't have to store the
rectangle in our program data, thus saving memory, and,
since channel A is disabled, we make fewer memory accesses
than we would in a normal copy from A to D, thus giving the
processor more opportunities to access the RAM.

To see this application in practice, load lesson10g1.s.

This technique can be applied not only to simple copies of a constant value,
 but also to more complex logical operations in which an operand
is constant.

You will find two examples in lesson10g2.s and lesson10g3.s.

.-----------.
| ¬ |
| |
| ___ |
_j / __\ l_
/,_ / \ __ _,\
.\¬| / \__¬ |¬/....
¯l_\_o__/° )_|¯ :
/ ¯._.¯¯ \ :
.--\_ -^---^- _/--. :
| `---------“ | :
| T ° T | :
| `-.--.--.-” | .:
l_____| | l_____j
T `--^--' T
l___________|
/ _ T
/ T | xCz
_\______|____l_
(________X______)

*******************************************************************************
*            THE ZERO FLAG AND COLLISIONS             *
*******************************************************************************

This is the last hardware feature of the blitter to be explained!
The blitter has a flag, called the Zero flag, which works in a similar way to the
Zero flag of the processor.
This flag is bit 13 of the DMACONR register. If a blit produces
ALL ZEROS as a result, the Zero flag is set to ONE.
Conversely, if at least one bit in one of the result words has a value of 1, the
flag assumes a value of ZERO.
The flag behaves in this way even if the result of the
blit is NOT written to memory, i.e. when channel D is
disabled.
This is very useful because it helps us detect collisions between a bob
and a drawing on the screen (which may be another bob already drawn).
Let's assume for the moment that we are working with single-bitplane images.
To detect collisions, we perform (with the blitter) an AND operation
between the bob and the part of the screen where the bob should be positioned, BUT
we do not write the result anywhere.
This blit is only used to test for collisions.
What happens when we perform an AND? As you know, the result of an AND between
two bits is 1 only if both operand bits are 1.
In our case, this means that a bit of the result can be 1 ONLY if
a bit of the bob with a value of 1 and a bit
of the image with a value of 1 coincide in the same position.
But this means that these bits produce a collision.
So if there is a collision, at least one bit of the result will have a value of ONE,
and the Zero flag will take on the value ZERO.
Conversely, if there is no collision, no bit of the bob coincides with
a bit of the background, so the AND is ALWAYS ZERO, and therefore the Zero flag
takes on the value ONE. So the Zero flag can tell us when there is a
collision and when there is not.
When dealing with images with multiple bitplanes, things get
complicated because a collision may occur between two
pixels of different colours that do not match when considered plane by plane.
For example, if there is a collision between a pixel of colour 1
 
(plane 1 = 1 and all others 0) and a pixel of colour 2 (plane 2 = 1 and
all others 0) by doing a plane-by-plane AND, the result is always 0.
In these cases, it is better to use mask bitplanes.
These have a bit set to 1 whenever the corresponding pixel of the bob
has a colour different from the background.
Therefore, by performing an AND between 2 mask bitplanes, collisions are detected regardless
of the colour of the pixels (it is like detecting collisions between the “shadows” of the
2 bobs, which are 1-plane images).

You can see an example in lesson 10h1.s

\\ ,\\ /, ,,//
\\\\\X///////
\¬¯___ __/
_;=( ©)(®_)
(, _ ¯T¯ \¬\
T /\ “ ,)/
|(”/\_____/__
l_¯ ¬\
_T¯¯¯T¯¯¯¯¯¯¯
/¯¯¬l___¦¯¯¬\
/___, ° ,___\
¯/¯/¯ °__T\¬\¯
( \___/ '\ \ \
\_________) \ \
l_____ \ \ \
/ ___¬T¯ \ \
/ _/ \ l_ ) \
\ ¬\ \ \ ())))
__\__\ \ ) ¯¯¯
(______) \/\ xCz
/ /
(_/

*******************************************************************************
*             THE SINUSCROLL                 *
*******************************************************************************

Almost all of you know what a sine-scroller is.
It is a scrolltext that moves up and down as it scrolls across the screen,
forming a sine wave.
Before explaining how the sine-scroller works, it is important to
clarify a few things.
First of all, time. A sine scroller is a very slow routine.
A good sine scroller can take up more than a quarter of the time
available in a frame. For systems without caches and fast memory
(basically the Amiga 500 and 600), it is extremely useful to set the
BLITTER_NASTY flag to 1, which gives the blitter absolute priority on the 68000 to
improve the performance of the routine.
You should also consider the ‘quality’ of the sine scroller you want to achieve.
This refers to how many pixels should be
shown in each sinusoidal position.
A 1-pixel sine scroller is the smoothest looking, but also
the most time-consuming.
Don't expect to have time for other effects if you are using a non-double buffered screen.
 On the other hand, even a 4-pixel sine scroller starts
to look very ‘pixelated’. For this reason, we will first explain how to
create a 2-pixel sine scroller, and then the changes to be made for
the 1- and 4-pixel versions.
Are you a little confused? Let's look at an example to see exactly what
we said about quality.

Imagine that the figure below is the letter A of a bitmap font:

.**************.
****************
****************
******....******
*****......*****
****************
****************
****************
*****......*****
*****......*****
*****......*****
*****......*****
*****......*****
*****......*****
*****......*****
................

Fig. 31 letter A


A ‘*’ indicates a bit set to 1, a ‘.’ is a bit set to 0.
When scrolled horizontally normally, the character ‘A’ always appears
the same as it is stored in the font data.
In a sine scroller, we do not want this. We want to change the
columns of pixels that make up the character so that they take on different
vertical positions based on the values of a sine wave.
In a 1-pixel sine scroller, each column of pixels takes on a different
vertical position. In a 2-pixel sine scroller, however, the columns of
pixels are paired 2 by 2, and each pair of columns takes on a vertical position
that is different from the other pairs.
A 1-pixel sine scroller distorts the character A as shown in the
following figure.

.
**
***
****
*****
******
*******
********
*********
*****..***
******..***
*******..***
********..***
*****.***.****
*****..***.****
.****...*******.
.***....*******
.**.....******
.*......*****
.......*****
......*****
.....*****
....*****
...*****
..*****
.*****
.****
.***
.**
.*
.


Fig. 31 Letter A distorted by a 1-pixel sine scroller

As you can see, each column of pixels is in a different vertical position
from the others. A 2-pixel sine scroller, on the other hand, produces the following result:

.*
**
****
****
******
******
********
********
*****.****
******..**
******..****
********..**
*****.**..****
*****.********
*****...**.****.
..***...********
***.....******
..*.....******
*......*****
.......*****
.....*****
.....*****
...*****
...*****
.*****
..****
****
..**
**
..

Fig. 32 Letter A distorted by a 2-pixel sine scroller

As you can see, pairs of adjacent columns have the same vertical position.
In a 4-pixel sine scroller, as you will have understood, the columns of pixels
are grouped in sets of 4, and each group takes on a different position from another
group.
Now you should understand what is meant by a “1-pixel” or “2-pixel” sine scroll.
The method for creating a sine scroller is very simple.
The method for creating a sine scroller is very simple.
We start with a normal text scrolling routine, like the ones we saw earlier.
However, instead of drawing and scrolling our text on the visible screen,
we do it in a data buffer allocated somewhere in memory.
This scroll buffer is never visible.
From this buffer, we take vertical “slices” of the scroller and copy them to the visible screen.
From this buffer, we take vertical “slices” of the scroller and
copy them to the visible screen.
Each “slice” is copied to a different vertical position, based
on the values of the sine wave.
The thickness of the “slices” determines the quality of the sine scroller.
If they are 1 pixel thick, we have a 1-pixel sine scroller; if they are
2 pixels thick, we have a 2-pixel routine, and so on.
Let's look in more detail at how to copy the ‘slices’.
Since the slices are very thin, we will do single-word wide blits.
To select only the slice (i.e. only the columns
of pixels) that we are interested in within the word, we will use one of the mask registers of channel A
(this means that we are forced to use channel A for reading)
which allows us to delete all the columns of pixels that are not part
of the slice we are interested in.
Of course, the value of the mask will vary depending on the ‘slice’ to be
read.
As we have already mentioned, writing takes place each time at a different
vertical position. When writing, it is not enough to make a
simple copy from A to D: if we did this, copying a ‘slice’
we would delete part of the previously copied ‘slices’ that belong
to the same word as the current “slice”.
In fact, even if the other ‘slices’ do not overlap ours (because
they are next to each other), since our bleed is one word wide,
with a simple copy we would also copy the columns of pixels
cleared by the mask next to the current ‘slice’ would also be copied onto the screen.
To solve this problem, we perform an OR operation between our word and the background
on which we write it. In this way, the cleared pixels of the current word
do not overwrite those of the background.
To create the sine scroller, simply copy the entire scroll text from the buffer to the screen,
using this procedure, one ‘slice’ at a time.
Obviously, the entire procedure must be repeated for each frame,
because the scroll text has moved and each time, before performing it,
it is necessary to clear the screen.
Note that the greater the amplitude of the sine wave, the greater the area of
the screen involved in the operation, and that we have to clear the screen each time.
It is therefore advisable to use a sine wave with a small amplitude to improve performance.

In lesson10i1.s and lesson10i2.s you will find a 2-pixel sine scroller
and a 1-pixel sine scroller respectively.

/#\ ...
/ \ : :
/ /\ \c o o ø
/%/ \ ( ^ ) /)OO
( u / __\ O / \ \)(/
UUU_ ( /) `-“` \ /%/
/ \| / < :\ )/ /
/ . \::. >.( \ ” /
/ /\ “::./|. ) \#/
/ / \ ”: ). )
__ û%,/ \ / (. )
( \% / / / ) .“
\_ò / / / `:”
\_/ / /
/\./
/.%
/ %
( %
\ ~\
\__)

*******************************************************************************
*                ANIMATION                 *
*******************************************************************************

Let's conclude the lesson with a brief explanation of how to create animations with
the blitter. An animation consists of a series of images (frames)
that must be displayed in a certain sequence.
Usually, the entire image does not change between frames, only
parts of it.
For example, we could have a castle with flags moving
in the wind.
Clearly, only the part of the screen on which the flags are drawn
changes between one frame and the next.
To save memory, it is not advisable to store all the images
in the animation: just store the first image and then the “pieces” of the
other images that contain the differences from the first.
In this way, to create the animation, you just need to copy the new “pieces” of
the image onto the old one.
For this purpose, the blitter is very useful, as you know, it is much faster
than the 68000 (basic) in copying data.
Basically, to create an animation, you need to make copies with the
blitter, something we are now masters at.
Animations can be divided into two types depending on how
the sequence of frames is structured.
In the first type of animation, called ‘cyclic’ animations, the frames
are drawn one after the other in a predetermined order.
After the last frame has been drawn, the animation continues from the
first frame.
In the second type of animation (‘forward-backward’ animations), the
frames are also drawn in order.
 However, after the last frame has been drawn, the animation continues by redrawing the frames in reverse order, from the penultimate frame back to the first.
At this point, the animation proceeds again in direct order until the last frame, then again in reverse order, and so on.
Depending on the type of animation, a different frame management routine must be used.
We present two examples of animation (one for each type) in the lesson10l1.s and lesson10l2.s listings.
Depending on the type of animation, a different frame management routine must be used
.

We present two examples of animation (one for each type) in the listings
lesson10l1.s and lesson10l2.s.

It is also possible to create animated bobs. These are bobs that change
shape each time they are drawn.
Of course, we also have a series of frames available for bobs
that are presented in sequence, based on one of the two techniques
we discussed earlier. Each time the bob needs to be drawn, a different figure must be used.
It is therefore very convenient to have a universal routine that can draw any figure, of any size, as a bob.
It is therefore very useful to have a universal routine that can
draw any figure of any size as a bob.

You will find such a routine for normal format screens in the example
lesson10m1.s and for INTERLACED format screens in the example lesson10m2.s.

.
.¦.¦:.:¦:.:¦
.;/'____ `;l
;/ / ¬\ __\
/ / ° \/o¬\\
/ \______/\__//
/ ____ \ \
\ \ \ , ) \
/\ \ \_________/
/ \ l_l_|/ /
/ \ \ / /
__/ _/\ \/\__/ /
/ ¬`----'¯¯\______/
/ __ __ \
/ / T \

******************************************************************************
*            SPECIAL BLITTER MODES             *
******************************************************************************

In addition to all the functions described so far, the blitter also
has the ability to draw lines and ‘fill’ areas, i.e.
set all bits in a given region of a bitplane to 1.
These additional capabilities are achieved through special modes of
operation of the blitter.

Let's start with line drawing. When the blitter operates in
line drawing mode (called ‘line mode’), it draws a line from one point
on the screen (which we call P1) to another (which we call P2). Let
X1 and Y1 as the x- and y-coordinates of P1, and X2 and Y2
as the x- and y-coordinates of P2. In line mode, many registers operate
completely differently than we have seen so far, and
they must be set appropriately. Some settings depend on the
position of P1 and P2. Before describing the use of registers, it is necessary to
make some preliminary considerations.
During tracing, the blitter considers the screen divided into ‘octants’
with respect to point P1. To better understand this, look at the following figure:

|
|
\ (2) | (1) /
\      | /
\ 3 | 1 /
\ | /
\ | /
(3) \ | / (0)
\ | /
7 \ | / 6
\|/
-------------*-------------
/|\
5 / | \ 4
/ | \
(4) / | \ (7)
/ | \
/ | \
/ 2 | 0 \
/      | \
/ (5) | (6) \
|
|


Fig. 1 Octants

In the figure, the asterisk (*) represents point P1. The blitter considers
the screen divided into 8 regions (called octants) shown in the figure.
The line to be drawn belongs to one of the octants, the one in which
P2 is located. The numbers in brackets are used to number the octants according to the
notation usually used by us ‘humans’ (i.e. counterclockwise).
The blitter, on the other hand, numbers them in a somewhat strange way, which is indicated by the
numbers without brackets. We will take this division of the screen into account
later.
 
We must also define some quantities that we will need to use to prepare the
blit. Let's call DiffX the difference between the abscissas of P2 and P1, changed of
sign if it is negative, so that it is always positive.
In formulas, we set:

DiffX = abs(X2 - X1)

where ‘abs’ indicates the function that calculates the absolute value of a number.
We do the same with the ordinates, setting:

DiffY = abs(Y2 - Y1).

At this point, we define DX and DY as the maximum and minimum values between
DiffX and DiffY, respectively. In formulas:

DX = max(diffX,diffY)
DY = min(diffX,diffY).

Let's now start looking at how to set the blitter registers, starting
with BLTCON1, which allows you to activate line mode. Bit 0 of BLTCON1 is used
for this purpose. When set to 1, line mode is activated. Bit 1
allows you to draw ‘special’ lines that allow subsequent
filling of areas of the blitter. We will discuss this later; for now, leave it
at 0 (normal lines). In bits 2, 3 and 4, write the octant number in
the octant in which point P2 is located. Of course, we will have to use the blitter numbering system.
 To easily convert the normal counterclockwise numbering
to that used by the blitter, you can refer to the following table:


BLTCON1 bit value     Octant number
---------------------     --------------
4 3 2
- - -
1 1 0            0
0 0 1            1
0 1 1            2
1 1 1            3
1 0 1            4
0 1 0            5
0 0 0            6
1 0 0            7

Bit 6 of BLTCON1 (called SIGN bit) must be set to 1 if
4*DY-2*DX<0. Otherwise (i.e. if 4*DY-2*DX>0), it must be set to 0.
Bits 12 to 15 of BLTCON1 contain the starting position of the line pattern.
In fact, it is possible to draw not only solid lines, but also
dashed lines, using a pattern that is repeated along the entire
line (we have already seen examples of patterns in lesson 9). Bits 12 to
15 of BLTCON1 indicate the pixel from which the pattern should be used.
Of course (we only have 4 bits), it must be one of the first 16 pixels
of the line.
All other bits of BLTCON1 should be left at 0.
Let's now move on to BLTCON0. The low byte of this register (LF, the minterms)
allows you to select 2 different drawing modes. Setting LF=$4A performs
an exclusive OR operation between the line and the background on which it is
drawn. In practice, the pixels crossed by the line are inverted.
Setting LF=$CA performs a simple OR operation between the line
and the background. In practice, the pixels crossed by the line are turned on.
The channels to be activated for the blitting are A, C and D. Therefore, bits 8, 9 and 11
must be set to 1, while 10 must be set to 0.
Bits 12 to 15 of BLTCON0 must contain the 4 least significant bits
(i.e. the lowest) of X1, the abscissa of point P1.
Fortunately, the settings for the other registers are simpler.
The BLTAFWM and BLTALWM registers must be set to the value $FFFF (they do not
mask anything).
The BLTADAT register must contain the value $8000, which represents the
pixel to be drawn. The BLTBDAT register contains the ‘pattern’ of the
line, which we mentioned earlier. A value of $FFFF draws a continuous line
.
When drawing lines, only the lower part of BLTAPT is used, i.e.
only the 16-bit register BLTAPTL, which must be set to the value 4*DY-2*DX.
The BLTAMOD register, on the other hand, must be set to the value 4*DY-4*DX.
The BLTBMOD register must be set to the value 4*DY.
The BLTCPT and BLTDPT registers must contain the address of the word on the
screen that contains pixel P1.
The BLTCMOD and BLTDMOD registers must contain the screen width
expressed in bytes.
Finally, the BLTSIZE register must be set to perform a
blit 2 words wide and a number of lines equal to DX+1 high.
This means that bits 0 to 5 must contain the number 2, while
bits 6 to 15 must contain the value DX+1. As usual, writing to the
BLTSIZE register activates the blitter. For this reason, this register must be
written last.

In summary, the values to be loaded into the registers are:
BLTADAT = $8000
BLTBDAT = line pattern ($FFFF for a solid line)

BLTAFWM = $FFFF
BLTALWM = $FFFF

BLTAMOD = 4 * (dy - dx)
BLTBMOD = 4 * dy
BLTCMOD = bitplane width in bytes
BLTDMOD = bitplane width in bytes

BLTAPT = (4 * dy) - (2 * dx)
BLTBPT = not used
BLTCPT = pointer to the word containing the first pixel of the line
BLTDPT = pointer to the word containing the first pixel of the line

BLTCON0 bits 15-12 = the 4 lowest bits of X1
BLTCON0 bits 11 (SRCA), 9 (SRCC), and 8 (SRCD) = 1
BLTCON0 bit 10 (SRCB) = 0
BLTCON0 LF control byte = $4A (per line in EOR)
= $CA (per line in OR)

BLTCON1 bit 0 = 1
BLTCON1 bits 4-2 = octane number (from table)
BLTCON1 bit 15-12 = initial bit for line pattern
BLTCON1 bit 6 = 1 if (4 * dy) - (2 * dx)) < 0
= 0 otherwise
BLTCON1 bit 1 = 0 (for normal lines)
= 1 (for special lines for fill)

BLTSIZE bit 15-6 = dx + 1
BLTSIZE bit 5-0 = 2

An example of line tracing is contained in lesson10n.s.
This is a routine that has been simplified as much as possible, without any particular optimisations,
 to facilitate understanding at the expense of execution speed
.


Area filling mode

In addition to copying data, the blitter can simultaneously perform a
fill operation during copying. This mode can be activated
with any standard blitter (copy, AND, OR, etc.) and is performed
AFTER all the other operations you already know (shift, masking, etc.).
To understand how filling works, imagine that the blitter writes
one bit at a time to the output (which is not true, as you know, because it always writes
ONE WORD at a time) and that it is performing a simple copy operation.
As long as it reads bits with a value of 0, it copies them normally. At a certain point, it
receives a bit with a value of 1. It copies it to the output as usual, but from
this point on, instead of continuing to copy the following bits, it sends
all bits with a value of 1 to the output. However, when it reads a second bit with a value of 1, it resumes
its normal behaviour. When it then reads a third bit with a value of 1, it starts
sending 1s to the output again, until the next 1 is input, and so on.
Let's see what happens to the copied data by showing a sequence of input bits
and the corresponding output:

input     000100010010010001000001000110010010
output        000111110011110001111111000110011110

In practice, bits with a value of 1 are considered the edges of the area and therefore
the blitter fills (i.e. sets to 1) the bits within the edges.
Let's now look at the technical details of the fill mode.
As we have already mentioned, it can be used in combination with any
blit, as the filling is performed after the data
read from the three sources has been combined according to the logical function
selected by the minterms.
However, the fill mode can only be used with blits performed in descending order
.
There are two different types of fill, called inclusive and exclusive. Each type
of fill has its own enable bit. To activate fill mode,
set one of the two enable bits to 1. It is not possible to activate
the two different fills simultaneously. Let's look at the differences between the two types of fill.
Inclusive fill mode fills between the lines, leaving them intact.
Exclusive fill mode fills between the lines, but while leaving the right-hand line intact, it deletes the left-hand line.
Therefore, exclusive fill produces shapes that are one pixel narrower than the
same pattern (outline) filled with inclusive fill.
For example, the pattern: 00100100-00011000 filled with inclusive fill produces: 00111100-00011000

For example, the pattern:

00100100-00011000

filled with inclusive fill produces:

00111100-00011000

with exclusive fill, the result would be:

00011100-00001000

(Of course, fills are always done on full 16-bit words.)

Let's take another example with the help of drawings:

inclusive fill:

before             after inclusive fill
_______________________ _______________________
|            |    |            |
|            |	|            |
| 1 1 1 1    |    | 11111 11111    |
| 1 1    1 1    |    | 1111    1111    |
| 1 1     1 1    |    | 111     111    |
| 11     11    |	| 11     11    |
| 1 1     1 1    |    | 111     111    |
| 1 1    1 1    |    | 1111    1111    |
| 1 1 1 1    |    | 11111 11111    |
|            |	|            |
|_______________________|    |_______________________|


exclusive fill:

before             after exclusive fill
_______________________     _______________________
|            |    |            |
|            |    |            |
| 1 1 1 1    |    | 1111 1111    |
| 1 1 1 1    |    | 111     111    |
| 1 1     1 1    |    | 11     11    |
| 11     11    |    | 1     1    |
| 1 1     1 1    |    | 11     11    |
| 1 1 1 1    |    | 111     111    |
| 1 1 1 1    |    | 1111 1111    |
|            |    |            |
|_______________________|    |_______________________|


As you can see, with the exclusive fill, the lines on the left side of the figure have been deleted.
 This results in figures with sharper edges
.
The inclusive fill enable bit is bit 3 of BLTCON1, while
the exclusive fill bit is bit 4, also of BLTCON1.

There is another bit that controls the fill.
This is bit 2 of BLTCON1 (called FILL_CARRYIN) which, when set
to 1, forces the filling of the areas outside the lines, rather than those
inside. Let's go back to the first example we did and see what happens
to our bit row when the FILL_CARRYIN bit is set to 1.
The starting row was:

00100100-00011000


With inclusive fill and FILL_CARRYIN=1, the output would be:

11100111-11111111

With exclusive fill and FILL_CARRYIN=1, the output would be:

11100011-11110111

Let's see what happens in the second example with inclusive fill and
FILL_CARRYIN=1.


before                 after
_______________________      _______________________
|            |    |            |
|            |    |            |
| 1 1 1 1    |    | 111 1111111 11    |
| 1 1    1 1    |    | 1111 11111111 11    |
| 1 1     1 1    |    | 11111 111111111 11    |
| 11     11    |    | 111111111111111111    |
| 1 1     1 1    |    | 11111 111111111 11    |
| 1 1    1 1    |    | 1111 11111111 11    |
| 1 1 1 1    |    | 111 1111111 11    |
|            |    |            |
|_______________________|    |_______________________|

inclusive fill and FCI bit = 1

The fill mode is mainly used for filling polygons. The edges
of the polygons are drawn using the blitter's line mode.
A very simple example is shown in the listing lesson10o.s, which
illustrates the various types of fill.
When the area to be filled is bounded by lines with a slope less than
45 degrees, a problem arises. In this case, a line
is formed by pixels that may be adjacent on the same horizontal row
of the screen. The situation is shown in the following figure
in which the asterisks (*) represent pixels with a value of 1.



*
*
*        line with a slope > 45 degrees
*
*


*
**
**        line with a slope < 45 degrees
*
**

As you can see, when a line has a slope greater than 45 degrees, it never happens
that two of its pixels are adjacent on the same row of the screen.
On the contrary, this happens when the slope of the line is less than 45 degrees.
This fact creates a problem in filling. In fact, when the blitter
encounters two pixels side by side on the same row during filling, it
considers them as two distinct edges, and therefore does not fill the pixels to the
right of the line. 
You can find an example of this problem in the listing
lesson10p.s. To overcome this problem, the blitter designers
have provided us with a special line drawing mode
(which we mentioned earlier) that produces lines with only one pixel
per horizontal row. Clearly, if you draw a line in this
mode without then filling it, it will appear ‘broken’.
In the listing lesson10q.s you will find the solution to the problem shown in
lesson10p.s.
In the example lesson10r.s we try to draw and fill a closed polygon
formed by many lines. We notice that the same small problem occurs here too.
The problem arises from the fact that the vertices of the polygon are shared by a
pair of lines. When we draw lines in EOR mode, we invert the
background pixels. The vertices are inverted twice and therefore end up
being reset to zero. This creates a ‘hole’ in the edge of the polygon, which
causes the fill to be done incorrectly. If, on the other hand, we draw the lines
in OR mode, the vertices remain at value 1. This creates problems with
the vertices at the top and bottom, as they are isolated on the line
to which they belong and therefore the filling starts from them but
never ends. To understand this better, look at the following figure (referring to the
bottom vertex):

* *        
* *        Before FILL
* *
*

^
+---- bottom vertex


**********        
*******        After FILL
****
************

^
+---- bottom vertex

As you can see, on the line where the last vertex lies, the fill does not
end because there is no other pixel set to 1 that acts as the left edge.
 In the case of lines in EOR mode, this problem does not arise
because the vertex is reset (i.e. due to the phenomenon that causes problems
for intermediate vertices).
In short, no matter what we do, there is always a vertex that messes up
the fill!
Let's see how we can get out of this mess. It is best to draw the lines in EOR mode,
so as to eliminate the problem of the top and bottom vertices. In addition, we make sure
to always draw the lines from top to bottom and, before
drawing them, we invert (with a BCHG) the first pixel. In this way, this pixel
will be inverted twice (by the BCHG and then by the blitting) and will therefore remain
unchanged. This solves the problem. In fact (since we have
ordered the points), each intermediate vertex is drawn once as the last
pixel of a line (and is therefore set to 1) and once as the first
pixel of the other line (and therefore remains unchanged, i.e. at 1).
This technique is presented in the example lesson10s.s
Let's now return to the processing of lines to illustrate a
special feature. It is possible to draw lines 2 pixels wide simply
by changing the initialisation value of BLTBDAT. The technique is illustrated
in the example lesson10t1.s. In the example lesson10t2.s, however,
a line drawing routine is presented that is better than the one used so far. This
routine exploits many special features of the 68000 assembler to
optimise the calculation and loading of the blitter registers.

/\\ ____ ,^-o,
_à /( <. `-,“ `-”;~~
~~ _}\ \( _ ) “,-”~`../ , \ .“‘v’”.
\(._(.)“ `^^ `^^ .:/ \ /\ = 'm” =
._> _>. |\__/| ,,///;, ,;/ ( ) ‘ \|/ ’--_o
@..@ / \ o:::::::;;/// .( o ). /m‘...’m\
(\--/) /_.~ ~,_\ >::::::::;;\\\ _,/
(.>__<.) \@/ “”\\\\\“‘ ”;\ <__ \_.---.
^^^ ^^^ A___A ';\ _ \_ / \
____ / o o \ O\ /O .-/ )-’‘’. \)\ /\.\
_/~____ =^= / O>!<O oP __/_)_( )* // \\
<______>__m_m_> o o "(__/ (___/ ,/' `\_,
_____ _____
oo/><><>\ ()-() (((( ~..~ \9
( -)><><><> (o o) AMIGA RULEZ ( )(:[ (oo)_____/
L|_|L|_|“ /\o/\ (((( WW WW
_ ,--, ___
('v”) _ ___/ /\| {~._.~} __ __
 
(,_,) ,;“( )__, ) ~ ( Y ) o-”'))_____\\
.,;;;;;,. // // “--; ()~*~() "--__/ * * * )
.;;”|/“;;;;” ' \ | ^ (_)-(_) c_c__/-c____/
^ ^

To conclude the lesson, we present some effects created by
tracing lines and fills, in the listings lesson10u1.s, lesson10u2.s,
lesson10v.s, lesson10x.s. In particular, in the last one you will see one of the
main techniques of the legendary demo ‘State of the Art’!
