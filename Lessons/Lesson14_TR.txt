
ASEMBLER KURSU - DERS 14

- AKUSTİK VE DİJİTAL SES TEMELLERİ -

(Kaynak Dizini8) - ardından “V Assembler3:sorgenti8” yazın

___
_( )_
__( . . .)__
_( _ .. ._ . )_
( . _/(_____)\_ )
(_ // __ | __ \\ __)
(__( \/ o\ /o \/ )__)
( .\_\__/ \__/_/. )
\_/ (_. ._) \_/
/___( )___\
( | |\___/| | )
||__| | |__||
||::|__|__|::||
||:::::::::sc||
.||:::__|__:;:||
/|. __ __ .|\.
./(__..| . .|.__) \.
(______|. .. |______)
/| |_____|
/|\


Yazar: Alvise Spanò

Hepinizin bildiği gibi, ses aslında bir DALGA, yani
fiziksel tanımına göre, "bir ortamda bir bozulmanın yayılması
 »dur; bizim alıştığımız sesler söz konusu olduğunda, dalgalanma
(dalga) ilk olarak maddenin (moleküller ve/veya
atomlar) titreşmesiyle ortaya çıkar ve ortam ise havadır (dalga, moleküller ve/veya atomlar arasında sürekli bir kinetik
ve potansiyel, dolayısıyla mekanik enerji alışverişi olan bir salınımdır
(fiziksel olarak madde parçacıkları arasındaki basınç değişimi) ve
bu nedenle var olmak ve yayılmak için maddeye İHTİYACI vardır: örneğin, boşlukta
iki ayrı ve birbirinden ayrı cisim arasında hiçbir ses dalgası veya başka türde titreşim
yayılmaz (en azından şu ana kadar bilinen tek istisna, elektromanyetik radyasyonlardır
- bilinen tek tür -
boşlukta bile hareket edebilirler, çünkü
kütleye sahip (her ne kadar çok küçük de olsa) (foton) ve dalga olmak üzere ikili fiziksel yapıya sahiptirler).
Bu sürekli enerji kaybını
ortamın bir noktasından diğerine tanımlamak için kullanılan fiziksel model, goniometrik fonksiyonun grafiğini gösterir
SENO (= sen = sin), yani bir SINUSOIDAL.

>>> DALGA FONKSİYONU: y = f(x ± v*t) <<<

x ör.: ARMONİK DALGA DENKLEMİ: y = asink(x±vt) = a * sin(k * (x ± v * t))

- y = BAĞIMLI DEĞİŞKEN: iki boyutlu bir kartezyen grafikte
(x,y), y ekseni
salınımın her x noktasına ait “yükseklikleri”ni temsil eder.

- a = DALGA YAYILMA KATSAYISI:
bildiğiniz gibi, -1 <= sin(x) <= 1 (x'in sinüsü (x =
herhangi bir gerçek sayı) -1 ile 1 arasında, uç değerler
dahil), bu nedenle
-a ile a (-a <= sin(x) <= a) arasında değişen bir salınım elde etmek için
sin(x) ile bir gerçek sayı a çarpılması gerekir.

- k = DALGA FREKANS: bu parametre değiştirildiğinde
frekans değişir ve ters orantılı olarak
dalganın PERİYODU, yani
bağımsız değişken ekseni boyunca dalga
sinüsünün dönebileceği minimum aralık, yani dalganın aynı özellikleri aldığı minimum aralık
.
Şimdi DALGA UZUNLUĞU
kavramını ve frekans kavramını daha ayrıntılı olarak inceleyelim: dalga uzunluğu (= periyotta kat edilen mesafe = iki bitişik döngü tepe noktası arasındaki mesafe) ve frekans: dalga uzunluğunun periyoduna bölünmesiyle elde edilen sayıdır.
(= periyotta kat edilen mesafe = iki bitişik döngü tepe noktası arasındaki mesafe) kavramını tanıtıp
frekans kavramını daha ayrıntılı olarak inceleyelim:
dalganın belirli bir zaman biriminde aynı özellikleri aldığı
sayısı, yani saniyede kaç kez
periyot (= saniyedeki döngü sayısı) okunur; genellikle dakika saniye [s] birimini ve Hertz [Hz = s^-1 = 1/s]
dönem okunur (= saniyedeki döngü sayısı);
genellikle dakika saniye [s] zaman birimi
ve Hertz [Hz = s^-1 = 1/s] frekans ölçü birimi
olarak kabul edilir.

- x = BAĞIMSIZ DEĞİŞKEN: iki boyutlu bir kartezyen grafikte
(x,y), x ekseni
önceden belirlenmiş bir zamanda
önceden belirlenmiş bir doğrusal uzay boyutu boyunca bir noktayı temsil eder; x
gerçek sayılara aittir ve teorik olarak sınırlaması yoktur,
yani tüm doğruyu kapsar ve
(x,y) düzleminde
eksene O(0,0)
'nın solunda ve sağında sonsuza kadar devam eden bir sinüzoid oluşturur: bu, sinüs fonksiyonunun
bir periyodikliğe sahip olduğunu kolayca
Örneğin, k = 1 ise, dalganın periyodu
360 derece (= 2*¶ radyan) ve frekansı
1 Hz'dir; k = 2 ise, periyot 180° (= ¶ rad) ve
frekansı 2 Hz'dir; ve bu şekilde devam eder.

- v = YAYILMA HIZI: dalganın bir noktasının uzayda hareket ettiği
kinematik hızını
belirtir.
v = DALGA UZUNLUĞU * FREKANS olduğunu unutmayın.

- t = ZAMAN ANI: v * t = s =
= boşluk olduğunu ve s, aynı pertürbasyonun
farklı t değerlerinde alınan iki karşılık gelen nokta arasındaki mesafe olduğunu unutmayın.
Bu nedenle, s'yi ekleyerek/çıkararak
x'e ekleyerek/çıkararak zaman içinde bir yayılma, dalganın uzayda bir hareketi elde edilir.
(x + s) ile dalga eksen boyunca sola, (x - s) ile sağa hareket edecektir.
P.S.: Açıklamaların aceleye getirilmiş olması ve kanıtların eksikliği için özür dilerim, ancak bu konuyla ilgili fazla ayrıntıya girmek için uygun bir fırsat olmadığını düşünüyorum.

P.S.: Açıklamaların aceleci olması
ve kanıtların eksikliği için özür dilerim, ancak
bu, doğrudan assembler ve genel olarak kodlama ile ilgili olmayan
konular üzerinde
fazla durmanın uygun bir fırsat olmadığını düşünüyorum;
 
Bu nedenle, lütfen yukarıdaki açıklamaları olduğu gibi kabul edin ve
dalga fiziğini derinlemesine anlamamışsanız çok endişelenmeyin
: Sonuçta, bir oyuna veya demoya müzik eklemek için buna ihtiyacınız olmayacak
.

Not: x ve y'nin, yayılma olgusunun herhangi iki özelliğini temsil ettiğini unutmayın.
Ses dalgaları durumunda, x ve y'yi
bir düzlem üzerinde dalgayı inceleyerek
bir kesitini tanımlayan iki uzamsal boyut olarak ele alacağız.

· ·
: :
________¦ ¦________
\ | __ | /
__________________\_____ | _\/_ | _____/__________________
\____________________ / | \/\/ | \ ____________________/
\____________ \_|._ _.|_/ ____________/
\ ____ _)| \/ |(_ ____ /
\/ / \__¯`‘¯__/ \ \/
/ / / \ \ \
\/ \ `····’ / \/
\ /
\ /
\ /sYz
\/

Şimdi, gerçek akustikte yayılma olgusunun genel fiziksel özelliklerinden öğrendiklerimizi aktarabiliriz
gerçek akustik yayılma fenomenleri hakkında öğrendiklerimizi aktarabiliriz ve
ARMONİKA kavramını tanımlayabiliriz: bir ses - parantez içinde, doğada mevcut olmayan ve
sadece bilgisayar gibi elektronik aletlerle üretilebilen -
dalga formuna (= tüm süresi boyunca pertürbasyonun (x,y) grafiği) sahip bir sinüzoid.
Harmonik sesin, TEMEL SES modelini oluşturduğunu ve birçok
diğer sesle birleşerek tüm saf olmayan sesleri oluşturduğunu söyleyebiliriz.
Fizik, bir sesi tanımlamak için 3 özelliği ayırır
:

1- YÜKSEKLİK: SAF seslerden (tek bir harmonikten oluşan ve doğada mevcut olmayan) ve DOĞAL seslerden
(aynı zaman aralığında üst üste binen birden fazla harmonikten oluşan ve doğada mevcut olan, bazıları binlerce farklı periyota sahip olan) sesleri ayırır ve frekansını belirler.
(aynı zaman aralığında üst üste binen birden fazla harmonikten oluşur
- doğada bulunanların bazıları
binlerce farklı periyotlu harmonik içerir)
 ve frekansını belirler,
bu frekans değiştirildiğinde çeşitli notalar üretilir.

2- YOĞUNLUK: Sesin bir tür “ses seviyesi” olarak görülebilir
ve harmoniklerde, sinüzoidin amplifikasyonuyla (Y değerlerinin mutlak değeri)
 doğrudan orantılıdır.
3- TON: Ses dalgasının şeklini, önceki iki parametreden bağımsız olarak nitelendirir ve esasen müzik aletini veya daha genel olarak bir sesi ayırt etmemizi sağlar.

3- TON: Ses dalgasının şeklini
önceki iki parametreden bağımsız olarak nitelendirir, dolayısıyla
esas olarak müzik aletini veya
daha genel olarak, bir sesi
diğerinden, yüksekliği ve yoğunluğundan bağımsız olarak
ayırt etmemizi sağlayan şeyi tanımlar.

Ses yoğunluğunu ve
basınç ve yoğunluk seviyelerini [deciBell = dB] hesaplamak için çeşitli formülleri bir kenara bırakalım, bunlar zaten
elektronik müzikle doğrudan ilgisi yoktur, sadece fizik dalı olan akustik ile ilgilidir
ve ortamdaki seslerin yayılması ve sesleri üretme (hoparlörler vb.) veya algılama
(mikrofonlar vb.) (mikrofonlar,
vb.) sesleri algılayabilen cihazların tasarımıyla ilgilidir.

*** Öncelikle, tını, kendi başına var olmayan bir parametredir:
bilgisayar sesleri ayırt edemez ve belleğinde bulunan dijital verileri
analog sinyallere (elektrik yoğunluğunu ve bitleri aktaran)
okuma frekansı ve belirli bir alt amplifikasyon değerine göre
ses ve gürültü arasındaki farkı dikkate almadan dönüştürür - bu iki kavram,
sadece biz insanlar tarafından farklı anlamlarla ve estetik duyuya atfedilerek
***
.
Dolayısıyla, en azından
elektronik düzeyde, tınıdan bir parametre olarak söz edilemez, ancak farklı dalga formlarının tınılarını tanımlamak ve karşılaştırmak için
kullanılabilecek sofistike algoritmalar mevcuttur
; bunlar, örneğin ses tanıma rutinleri programlamak isteyenler için yararlı olabilir
; her halükarda, bu
, ses sentezi ve
işleme dünyasının bu kadar karmaşık uygulamalarını tartışmak için uygun bir yer değildir.

Öyleyse, bizim için en önemli parametreye geçelim:
seslerin yüksekliği, DOĞAL sesler söz konusu olduğunda, onları ayıran
temel harmonik frekans (TEMEL FREKANSI) ile doğrudan bağlantılıdır
ve SAF sesler söz konusu olduğunda, onları oluşturan TEK harmonik frekans ile bağlantılıdır
.
Bir örnek verelim: X periyotlu (=süreli) bir saf (armonik) sesimiz var;
bu ses herhangi bir frekansta üretilebilir, sadece sesin üreticisi tarafından “OKUMA HIZI”na bağlıdır
: örneğin, eğer üretici
armoniyi tüm periyodu boyunca saniyede 2 kez “okursa”, frekans
2 Hz olacaktır; ikinci olarak, belirli bir sesin havada yayılması
sorunu da ortaya çıkar, ancak bu sorun kolayca çözülür: sesin
havada yayılma hızı 380 m/s'dir ve bu nedenle,
HIZ = DALGA UZUNLUĞU * FREKANS olduğunu bilerek, dalga uzunluğunu
bulmak son derece kolaydır ve uzamsal boyutlar açısından periyotla (
saniye cinsinden ifade edilir)ile aynıdır.
Bu noktada, ses üretme araçlarını ele almak için yeni bir parametre devreye girer
: okuma hızı veya HIZ/ÖRNEKLEME FREKANSı
.
Ancak şimdi devam etmek için, elektronik araçların sesi nasıl işlediğini
ve amplifikatöre iletmeden önce nasıl işlediğini açıklamak gerekir.

Bir örnekleyici (ses dijitalleştirici) ve uygun bir yazılım
kullanarak, bir ses kaynağından gelen sesleri
(mikrofon, CD, vb.) sayısal verilere (dijital örnekler) dönüştürebiliriz. Her bir örnek
, dalga formunun eksenleri (x, y) boyunca bir aralığın “payını” (bilimsel terimle “küçük bir dilim”) - bilimsel terimlerle
konuşmak gerekirse -) dalga grafiğinin (x, y) eksenleri boyunca
.
 “Yakaladığımız” örnekler ne kadar fazla olursa, dijital ses o kadar net ve
fiziksel gerçekliğe yakın olur.
Örneğin, 2 saniye uzunluğunda (bunu dönem olarak kabul ediyoruz, çünkü
dalganın döngü süresinin daha kısa bir minimum aralığını belirlemek mümkün değildir)
bir doğal ses (yani harmonik olmayan) varsa ve
temel frekansını elde edebiliyorsak,
hafızaya ÇİFT örnekleme frekansı (Nyquist teoremi,
daha sonra açıklanacaktır) ile örnekleme yapmamız yeterlidir, böylece sesin akustik olarak sadık ve net bir şekilde yeniden üretilmesini sağlayabiliriz
; Örneğin, temel frekans 2 kHz (= 2000 Hz) ise,
saniyede 2000 örnek kaydetmeliyiz, toplamda 4000 örnek
(2000 örnek/s * 2 s = 4000 örnek).
** Her örnek (= sample), Amiga'da 8 bit (= 1 bayt) bellek kaplar
çünkü Amiga 8 bit ses tanımlaması kullanır.
8 bit ile ifade edilen sayı ile -128
(= -(2^8)/2 = -2^(8-1) = -2^7) ile 127 (= (2^8)/2-1 = 2^(8-1)-1 = 2^7-1 (sıfır
, ikili sistemde pozitif işarete sahiptir: aslında pozitif sayılar (0'dan 127'ye kadar)
128 negatif sayılar gibi), uç değerler dahil, her bir örnek için, toplamda
256 (= 2^8) ifade edilebilir değer **.

Not: Dalga formunun I (+) ve II
(-) kadranları arasında salındığını, bunların 0 ekseniyle ayrıldığını unutmayın; -128'i
0 ve +127'yi 255 olarak DÜŞÜNMEYİN: Dalgayı I kadranına kaydırıp
her şeyi pozitif hale getirmek mümkün DEĞİLDİR, * hesaplar ne ses yongesinde,
ne de özel efektler için yazılım aracılığıyla sesin işlenmesinde
* tutmaz.

*** HER ÖRNEĞİ 8 BIT'LİK BİR BYTE OLARAK DÜŞÜNÜN (= MSB = bit 7) ***

8'den fazla bit sayısına sahip dijital sentezin
aynı örnekleme frekansında daha yüksek ses kalitesi sağlayacağını vurgulamak önemlidir
.
Örneğin, CD çalarlar 16 bitlik (= 2 bayt = 1 kelime) örnekleri okur, bu da
aralıkların -32768 (= -(2^16)/2 = -2^(16-1) =
= -2^15) ile 32767 (= (2^16)/2-1 = 2^(16-1)-1 = 2^15-1) arasında değişir ve toplam 65536
(= 2^16) ifade edilebilir değer vardır: *** ancak bu, CD'deki 32767
(pozitif tepe) değerinin, aynı örneğin 8 bit'e dönüştürülmüş 127 değerine göre daha büyük bir paya karşılık geldiği anlamına gelmez
: ses çıkışı
aynı olacaktır, ancak aynı fiziksel aralıkta 16 bit sentezleme
çok daha fazla tanımlama sunar (temel olarak, 8 bit'te bir sesi ifade etmek için 256 sayı vardır,
 fiziksel olarak sabit iki pozitif ve negatif tepe noktası arasında,
ancak 16 bit'te çok daha yüksek bir değer aralığıyla sentezlenir
(65536) ve dolayısıyla DAHA FAZLA HASSASİYETLE, DAHA AZ YAKLAŞIK DEĞERLERLE sentezlenir).
Bir bakıma, ilk örnekteki 8 bitin
ikinci örnekteki 16 bitin üst 8 bitine (15:8) karşılık geldiğini ve alt 8 bitin,
 örnek kelimenin yüksek ve düşük baytı arasında yer alan hayali bir virgülün ardından gelen bir tür yaklaşıma karşılık geldiğini söyleyebiliriz
***.

Şimdi örnekleme frekansına geri dönelim ve ünlü ve
önemli - ancak kanıtlanması açısından karmaşık - bir teoriyi alıntılayalım
: "FREKANS TEPKİSİ, ÖRNEKLEME FREKANSININ YARISINA EŞITTİR
(Nyquist teoremi): temel olarak, bu,
10 kHz'de örnekleme yaparsak, sadece 10/2 = 5 kHz'den
düşük veya eşit frekanslı seslerin sadık bir şekilde yeniden üretileceği anlamına gelir (işte, biraz yukarıda, temel frekansını bilerek veriyi örneklemek için gerekli örnekleme frekansı hakkında yazdığımız gizemli " “ yazısı da açıklanmış oluyor
.
verilen sesi örneklemek için gerekli örnekleme frekansı, temel frekansını bilerek).
ALIASING'i duymamak için sesleri uygun bir frekansta örneklemek çok önemlidir.
 Aliasing, örnekleme frekansının yarısının üzerindeki frekansları keserek
hoş olmayan bir ”bozuk" etki yaratır.
** Paula (Amiga'nın ses çipinin gerçek adı)
sadece 8 bitlik bir dijital hassasiyet kullanmasına rağmen, doğru frekanslarda örnekleme yaparak ve
aliasing'i önleyerek
aynı kalitede sesler üretebilir.
CD'nin kalitesine ulaşılamaz. CD, 16 bit'te 44,1 kHz (44100 Hz) örnekleme yaparak
20 Hz ila 22 kHz arasında değişen bir frekans tepkisi elde eder, bu da yaklaşık olarak
insan kulağının duyabileceği frekans aralığına karşılık gelir (öznel: bazı kişiler
20 kHz'e kadar duyabilir).
* Bu vesileyle, 20 Hz'den düşük frekanslı seslerin (temel,
anlaşılmayan) INFRASOUN, 20-22 kHz'den yüksek frekanslı seslerin ise ULTRASOUN olarak adlandırıldığını belirtmek isterim: her ikisi de insan kulağı tarafından duyulamaz *.
Bununla birlikte, çoğu doğal sesin temel frekansı 15-16 kHz'den yüksek değildir; bu nedenle, neredeyse tüm sesleri sadık bir şekilde yeniden üretmek için en fazla 32 kHz'de örnekleme yapmak yeterlidir.
Bununla birlikte, doğal seslerin çoğu temel frekansı
15-16 kHz'den yüksek değildir; bu nedenle, neredeyse tüm sesleri aslına sadık bir şekilde yeniden üretmek için en fazla 32 kHz'de örnekleme yapmak yeterlidir
.
Hayır! Bunun çok basit bir nedeni vardır: biraz yukarıda, doğal seslerin birçok harmonikten oluştuğu ve bunların arasında
bir temel harmonik tespit edilebileceği açıklanmıştır:
 
temel frekansın (genellikle örnekleme frekansını hesaplamak için kullandığımız
)
 aslında daha kısa periyotlu (yani daha yüksek frekanslı) harmoniğin frekansı
olması da mümkündür; bu durumda, temel frekans olarak kabul ettiğimiz frekanstan daha yüksek frekanslı tüm harmonikler kesilir ve
aliasing ile yeniden üretilir, bu da genel ses kalitesini önemli ölçüde düşürür.
Dahası,
*** BU NEDENLE, DOĞAL SES VERİSİNİ OLUŞTURAN EN YÜKSEK ARMONİK FREKANSIN İKİ KATINA EŞİT FREKANSLA ÖRNEKLEME YAPMAK UYGUN OLACAKTIR ***.
_______ _ _/ /_____\ _ __\ Oo / _ ______\_-_/______ (_/__/ : __\_) ' __/ : \__ _ (_/____:____\_> _ Oo / _ ______\_-_/______ (_/__/ : __
_______
_ _/ /_____\
_ __\ Oo /
_ ______\_-_/______
(_/__/ : __\_) '
__/ : \__
_ (_/____:____\_>
_ O/ _ _O/

Dolayısıyla, yoğunluk sesin “ses seviyesini” belirler ve bu *** frekansla
sabit değildir: çok yüksek veya çok düşük frekanslarda
orta frekanslı seslerle aynı yoğunlukta algılanabilmesi için amplifiye edilmesi gerekir.
 Biyolojik evrim
(alışkanlığın bir sonucu olarak) insan kulağının doğada en yaygın olanları
; peki bir sesin yüksekliğini belirleyen nedir?
Müzik açısından bakıldığında, cevap çok basit: NOTALAR.
Bildiğiniz gibi, müzik notaları OTTAVA için 7 notadan oluşan gamlar oluşturur
ve her biri DO notasıyla başlar (C, İngiliz notasyonunda)
ve SI notasıyla biter (B, İngiliz notasyonunda - LA, A'dır); her
sekstede frekans iki katına çıkar, yani her DO, önceki DO'ya göre iki kat frekanstadır
(bu nedenle frekans artışının doğrusal değil,
 2 tabanında ÜSSEL olduğunu unutmayın).
Sekstede, gamdaki notalar arasındaki ilişkiler şöyledir:

DO RE MI FA SOL LA SI | (DO)
--------+-------+-------+-------+-------+-------+-------+-------|---+---------
1 9/8 5/4 4/3 3/2 5/3 15/8 | 2

Müzik düzenleme programlarında (SoundTracker, NoiseTracker veya
ProTracker gibi) enstrüman olarak kullanılacak sesleri örneklemek gerekirse,
 sesin temel frekansının iki katı frekansta örneklemek yeterlidir.
 Bu, bir müzik enstrümanından örnekleme yapıldığında,
 en azından pratiklik açısından, çalınan notanın frekansına karşılık gelir:
Örneğin, bir modülün bestelenmesi için bir piyanoya ihtiyacımız varsa,
LA3'ü (üçüncü oktavın LA'sı) 880 Hz'de (LA3 = 440 Hz) örnekleyebilir ve
tracker'a örnekleme frekansının LA3'e karşılık geldiğini bildirebiliriz.
O, daha sonra, o enstrümanla partisyona koyduğumuz notalara göre örnekleme frekansına göre doğru frekansları hesaplayacaktır
.
Şimdi, elbette, bir soru soracaksınız: 880 Hz'de örneklemek, aliasing elde etmemek için yeterli mi?
Şimdi, mutlaka şu soruyu soracaksınız: 880 Hz'de örnekleme yapmak
aliasing oluşmaması için yeterli mi?
Cevap hayır. Daha önce de söylediğimiz gibi, piyanonun tınısını
sadık bir şekilde yeniden üretmek için en yüksek harmonik frekansın iki katında
örnekleme yapmak gerekir, ancak bu frekansı elde etmek oldukça karmaşıktır (
imkansız değil).
O zaman ne yapmalı? ** Şey, çeşitli frekanslarda
(dürüst olmak gerekirse, 880 Hz'den çok daha yüksek) örneklemeyi denemeye devam edin,
enstrümanın o notada en iyi şekilde çalınmasını sağlayın ve tracker'a o notanın
örnekleme frekansını
Gördüğünüz gibi, bu konu pratikte teoride olduğundan daha karmaşıktır
!


Bu kaçınılmaz (ve umarım ilginç) dijital ses bilgilerinin ardından,
 Amiga'nın Original ve AA çiplerinin ses donanımının daha ayrıntılı açıklamasına geçiyorum
(Paula, ilk Amiga'nın (1985, kayıtlara geçsin) piyasaya sürülmesinden bu yana hiçbir
).
Donanım, ses çipinin 4 sesine ayrılmış 4 DMA kanalı içerir; bu 4
ses tamamen bağımsızdır ve 2'şerli gruplar halinde kasaya göre gruplandırılır, böylece
1+4 sesleri sol kanal, 2+3 sesleri ise stereo olarak sağ kanaldan çıkar.
Ayrıca, 4 sesin tümü kendi donanım kayıtlarına sahiptir:

AUDxLCH $dff0y0 = Okunacak verilerin konumu (yüksek kelime)
AUDxLCL $dff0y2 = Okunacak verilerin konumu (düşük kelime)
AUDxLEN $dff0y4 = DMA uzunluğu (word cinsinden)
AUDxPER $dff0y6 = Okuma örnekleme süresi
AUDxVOL $dff0y8 = Ses seviyesi
AUDxDAT $dff0ya = Kanal verisi (2 byte = 2 örnekleme)

Not: Her ‘x’ yerine, istenen öğeye karşılık gelen 0 ile 3 arası bir sayı girin
; her ‘y’ yerine, 0 ile 3 arası öğelere karşılık gelen
$a ile $d arası bir onaltılık sayı girin.

AUDxLCH-AUDxLCL: Latch değerini oluşturur, DMA'nın veri işaretçisini oluşturmaz,
 bu nedenle, bir kez ayarlandıktan sonra, düzlemler, sprite'lar veya blitter kanalları için olduğu gibi artmaz,
 ancak
bakır konum kayıtlarına benzer değerleri
gerektiğinde otomatik olarak iç işaretçi kayıtlarına
yeniden girilir.
* Bu iki 16 bit kayıt bitişik olduğundan,
68000'de tek bir MOVE.L ile ayarlamak daha kolaydır:
MOVE.L #miosample,AUDxLCH *.
Not: Bundan sonra, AUDxLC ile iki kayıt çiftini,
bir tür 32 bitlik tek konum kaydını
kastediyorum.

AUDxLEN:    Çalınacak sample'ın kelime uzunluğunu ifade eder.
Örneğin, bellekte 500 baytlık bir sample varsa
bu kayıt (istenen 4 kanaldan birinin)
 250 değerine ayarlanmalıdır.
Not: Blitter'da olduğu gibi, bu kayda 0 yazıldığında
128 kB sample okunur.

AUDxPER:	Bu kayıt,
DMA'nın okuma frekansını biraz garip bir şekilde - görünüşte - ama donanım için
kullanışlı ve hızlı bir şekilde belirtmek için kullanılır: her bir ses örneğinin
ÖRNEKLEME PERİYODU ile ayarlanmalıdır,
bu değer, DMA'nın CLOCK döngülerinde (sistem
= 3546895 Hz (PAL), 3579545 Hz (NTSC)) olarak ifade edilir ve DMA'nın
beklemesi gereken süreyi (azaltıcı olarak çalışır: -1 saat döngüsü başına)
başka bir örnek aktarmadan önce ifade eder.
Bu kayıt defterine girilecek değeri hesaplamak için, örnekleme frekansı (kullanımı çok daha
pratik) verilmişse, aşağıdaki formülü kullanabilirsiniz: PER = CLOCK / freq.
[Hz] [Hz]
Örneğin, bir LA3 harmoniği örneklememiz gerekiyorsa - tabii
ki doğal bir kaynak bulabilirsek... - frekansı 440 Hz,
periyodu 1 saniye, örnekleme frekansı
880 Hz olmalıdır, bu durumda AUDxPER kaydına girilecek örnekleme periyodu,
 bellekteki örneği 1 saniyede doğru frekansta okumak için
şöyle olacaktır:
PER = 3546895 / 880 = 4030 (PAL)
Not: Ses verileri, renk saatinin 4 yuvasından
(16 bit = kanal başına 2 örnek) yatay tarama hattı başına DMA'dan alınır.
PAL tarama hatları 312,5'tir (312=SHF, 313=LOF)
raster için ve saniyede 50 raster vardır; bu nedenle,
maksimum okuma frekansı (mevcut tüm atanan döngülerde okuma
yapıldığında) = 2 BytePerLinea * 312,5 * 50 = 31300 Hz
yaklaşık: ** ANCAK BU HIZ SADECE TEORİK **, çünkü
ses DMA'ya her raster hattına atanan döngülerle
mükemmel bir şekilde çakışan doğru bir örnekleme süresi ayarlamak
imkansızdır: DMA'dan bir süre sayımı
bir tarama hattının ortasında
(veya tam bir şanssızlık durumunda, 
ses verisine atanan yuvadan sonraki döngü) ve donanım, çalınacak verileri almak için bir sonraki
satırı beklemek zorunda kalır, oysa örnekleme süresi 
kısa ise, yeni veri olmadığında sayımın bitişi
aynı satırda gerçekleşebilir.
Esasen, minimum süre donanımın
EN AZ bir raster satırını geçmesine izin vermelidir: ses
DMA tarafından okunduğunda değil, AUDxPER'deki süre değerinden
iç sayım bittiğinde çıkar: ses DMA
verileri yalnızca atanan döngüler sırasında okur (ayrıca
çok yüksek öncelikli - disk sürücülerinin DMA'sı gibi -
“aşırı doluluk” nedeniyle bozulma ve yavaşlamaları önlemek için
- bkz: “her zaman bozulan bit düzlemleri”) ve bunları
AUDxDAT'ta örnekleme süresinin sonuna kadar saklar
* bu herhangi bir zamanda gerçekleşebilir * ve
ses üretilir;
* bu nedenle, minimum örnekleme süresini
123'ten (=28836 Hz) daha aşağıya İNDİREMEZSİNİZ: DMA'nın
ses çıkarmadan önce en az bir veri daha okuyabilmesi için
sonraki satırda *.
Bu noktada şu soru akla geliyor: « Neden
minimum süre olarak 123 belirlenmiştir, oysa hat başına saat döngüleri (yani
azalma sayısı) 226,5'tir (226=LOF, 227=SHF)? ».
İşte cevap: Daha önce, DMA'nın
her ses için “tek seferde” 16 bit (=2 bayt) aktardığı belirtilmişti, bu nedenle
her satırda 2 örnek çalabilir ve ilkini çaldıktan sonra
aynı raster satırında bir sonrakini de çalabilir
çünkü onu henüz okumamıştır; 123 ile
aslında, en fazla
 2 son sayım gerçekleşebilir ve sorun ortaya çıkmaz.
Bu nedenle, teorik minimum süre 227 (geniş tutmak için) / 2 = 114 (yine fazla yuvarlayarak)
olmalıdır ve bu,
süre ile örnekleme frekansı arasındaki karşılık (tek eşlemeli değildir: her zaman
belli bir yaklaşıklık vardır) ile
teorik maksimum frekans olan
31300 Hz ile hemen hemen aynıdır. Ancak, yukarıda belirtildiği gibi, bu
donanımla tam olarak ulaşılamaz.
*** 123, ayarlanabilir minimum periyottur = 28836 Hz ***

AUDxVOL:    Bu kayıtta, ilgili kanaldaki ses çıkışının hacmi
0 ile 64 arasındaki değerlerle belirtilmelidir
(64 girildiğinde dB = maksimum ses
seviyesi azalmaz).
*** ÖNERİ !!! Örnekleme yaparken, her zaman en yüksek hassasiyeti elde etmek için, düşükyoğunluklu sesler için bile -128 ile 127 arasındaki tüm değer aralığını
kullanmaya çalışın ve
en fazla bu kayıtta ses seviyesini düşürün ***.

AUDxDAT:	DMA'nın verileri
D/A (Dijital/Analog) dönüştürücülere gönderilmeden ve
sinyaller Amiga'nın dışına gönderilmeden önce kullandığı geçici tampondur.
2 bayt ses verisi içerir (DMA, RAM'den her seferinde 16 bit
aktarır - bu nedenle
AUDxLEN'in word olarak ifade edilmesi gerektiği !) ve
1'er 1'er DAC'ye (Dijital-Analog Dönüştürücü) gönderilir.
*** ÖNERİLMEZ !!! DMA kapalıyken bu kayıtları CPU ile ayarlamak ve bilgisayarı yine de çalıştırmak da mümkündür
:( ***.
_____
.__/_____\
\ O o /
/\ ____\_\_/___
\\\/___ : _ \
O\ \ / : / /
\\\_ : \/
_ __O\_/___:____\


- 23 kB'lık bir örneği
21056 Hz frekansında, bellekte
$60000 (RAM yongası) konumunda, stereo olarak maksimum ses seviyesinde,
2 ve 3 (üçüncü ve dördüncü kanal) sesleriyle çalmak için kayıtların ayar örneği:

PlaySample:
lea    $dff000,a0    ; a0'da özel çiplerin tabanı
move.l    #$60000,$c0(a0)    ; AUD2LC'yi $60000'a yönlendir
move.l    #$60000,$d0(a0)    ; AUD3LC'yi de $60000'a yönlendir
move.w	#11776,$c4(a0)    ; AUD2LEN = 23 kB = 23*1024 = 23552 B [...]
move.w	#11776,$d4(a0)    ; AUD3LEN = [...] = 23552/2 = 11776 kelime
move.w    #168,$c6(a0)    ; AUD2PER = 3546895/21056 = 168
move.w    #168,$d6(a0)    ; AUD3PER'i AUD2PER olarak ayarla
move.w    #64,$c8(a0)    ; AUD2VOL için maksimum ses seviyesi
move.w    #64,$d8(a0)    ; AUD3VOL için de maksimum ses seviyesi
move.w    #$800c,$96(a0)    ; DMACON'da kanal 2 ve 3'ün DMA'sını açar

Şimdi kanal DMA'ları açıldığında ne olduğunu açıklayalım (
tabii ki sample'ın duyulduğu dışında...):

1 - AUDLC'de bulunan değer iç
işaretleme kayıtlarına girilir ve DMA,
veri kayıtlarına 2 baytlık aktarımlara başlar.
* Bu andan itibaren AUDLC kaydı da değiştirilebilir:
donanım, tüm sample aktarımını tamamladıktan sonra,
başa dönerek (Sonsuza kadar döngüye girer).

2 - AUDLC değeri dahili kayıtlara girilir girilmez
SEVİYE 4 kesme sinyali gönderilir ve bu sinyal
INTENA ve INTREQ kayıtlarında 4 alt kesme sinyaline bölünür, her biri
4 ses kanalından birine atanır:

+--------------+---------------------+---------+
| IRQ SEVİYESİ | INTENA/INTREQ BİTİ | KANAL |
+--------------+---------------------+---------+
| 4 |         10      | 3 |
| 4 |         9     | 2 |
| 4 |         8     | 1 |
| 4 |         7     | 0 |
+--------------+---------------------+---------+

Bu kesintiler sayesinde, örneğin,
mevcut ses çalmayı bitirir bitirmez
kayıt konumunu başka bir ses örneğine yönlendirerek
ve ikisi arasında mükemmel bir bağlantı sağlayarak
(iki dalga formunun
sırasıyla benzer şekilde bitirmesi ve başlaması koşuluyla)

3 - aktarımın sonunda her şey (1) noktasından başlar.
** Kayıtlar asla değiştirilmez **.

.||||||.
\ oO ||
_\_-_/||_
/ {_{_ __ \
\ |____|/_/
/______\_)
___|_| |
/_/______|ck!^desejn

Elbette, tüm bunlar ilginç - diyebilirsiniz -, ama
bilgisayarda 10 dakikalık bir şarkıyı, onlarca
megabaytlık veri örneklemeden nasıl çalabilirsiniz?
İşte bu amaçla Tracker'lar icat edildi: 
müzik yazmak için tasarlanmış programlardır ve sadece temel enstrümanların
örneklemesi gerekir; çeşitli notalar, bunların okuma frekansını değiştirerek elde edilir.
 Ayrıca, partitürü 4 parçaya bölerek bestelemek için bir editör de içerirler
(her ses için bir parça), her biri herhangi bir enstrümanı
herhangi bir anda çalabilir, ancak her zaman tek tek (toplamda
aynı anda en fazla 4 enstrüman çalınabilir).
Burada bir trackerin tüm olanaklarını açıklamak oldukça karmaşık olacaktır,
 bu nedenle bir tane edinmenizi tavsiye ederim (örneğin ProTracker: şu anda
4 kanallı en iyi tracker - evet, daha fazla kanallı olanlar da var, bunlar
birden fazla kanalın notalarını tek bir seste gerçek zamanlı olarak karıştırıyor; ancak
ne yazık ki, bu işlem son derece yavaş ve
bir demo veya video oyununun müziğini çalmak için kullanılamaz, çünkü makine
bu tür durumlarda, tüm zamanını çalmakla harcamak yerine başka işleri vardır...).
Tracker'ların “felsefesi” ise değişmez: hepsi
- sözde - müzik rutinleri sağlarlar. Bunlar, genellikle
seviye 6 kesintilerini (CIAB'ye bağlı) veya elektronik fırça ile senkronize edilmiş bekleme döngülerini
kullanarak, ilgili tracker ile (veya uyumlu, yani
modülün yapısını aynı şekilde kaydeden) oluşturulan modülleri (şarkı + örnekler =
partisyon + enstrümanlar) gerçek zamanlı olarak çalarlar.
Bu rutinleri kendi kaynaklarınıza uyarlamak çok kolaydır: genel olarak
her birinin kendi kuralları vardır: izleyicinizin .doc dosyasını okuyun -
kesintileri ve DMA kanallarını ayarlayan bir başlatma alt rutini başlatmak yeterlidir
- bazıları CIAB zamanlayıcılarını da ayarlar; CIAA, Exec tarafından işlemleri/görevleri zamanlamak için kullanıldığından
değişmeden kalır -
ve her rasterde play alt rutini başlatın (bunu dikey boşluk kesme kodunun başında
yapmanız daha iyidir - işletim sistemi altındaysanız,
 yüksek öncelikli bir kesme sunucusu 5 (VBLANK, seviye 3) ekleyin,
dikey boşluk aralığında her şeyi yapmak için, 
planlar
fetch etmeye ve her şeyi yavaşlatmaya başlamadan önce); demo/oyun - veya
program - bitmeden önce, OS'ye interrupt, DMA ve zamanlayıcıların geri yükleme alt programını başlatmayı UNUTMAYIN.

Amiga'nın ses donanımıyla ilgili bir diğer önemli paragraf, 4 sesli DMA'dan gelen sesin modülasyonuyla ilgilidir.
MODÜLASYON nedir? Birçok şarkıda
SES SOLMA (ses seviyesinin yavaşça ve kademeli olarak azalması) efektini duymuşsunuzdur: işte,
bu basit efekt, özel bir modülasyon türüdür.
*** MODÜLASYON, bir sesin bir veya daha fazla parametresini
süresi boyunca ve sonrasında değiştirmektir ***; söz konusu parametreler elbette
YOĞUNLUK (genlik) ve TİZLİK (frekans)tır.
Ses algısı düzeyinde, genlik modülasyonu ve frekans modülasyonu hangi efektlere karşılık gelir?
İlk olarak, daha önce de belirttiğimiz gibi, genlik modülasyonu genellikle bir müzik parçasının başında ve sonunda bulunan
fade efektlerinde yaygın olarak kullanılır;
gitar (veya bir yaylı enstrüman) tellerinde kayma
hareketi, frekans modülasyonunun tanıdık bir örneğidir:
 temelde, belirli bir frekanstan başlayıp bir diğerine ulaşan ve
aradaki tüm frekansları belirli bir hızla (hatta
belirli bir ivmeyle) geçerek
hem genlik hem de frekansta aynı anda modülasyon yapmak da mümkündür.
Bu, günlük deneyimlerden kaynaklanan garip bir etkiye yol açar
: * Doppler etkisi *.
Kısaca, dinleyiciye göre hareket halindeki bir kaynaktan gelen seslerin yoğunluğunun ve
perdesinin değişmesi (modülasyonu)dır
: sokakta yürürken, size yaklaşan ve sonra sizi geçen arabaların seslerinin
aynı parametreleri korumadığını fark edersiniz
sizin (dinleyici) konumunuza göre aynı kalmadığını fark edersiniz,
 ancak öncelikle, sizinle kaynak arasındaki mesafeyle ters orantılı olarak ses seviyesi yükselir
ve dikkat ederseniz, zamanla değişen tek şey yoğunluk değildir: motorun çıkardığı sesin frekansı da
araba uzaklaştıkça azalır.
Bu fenomeni açıklayan denklemi burada vermenin uygun olmadığını düşünüyorum, çünkü konu “Amiga'da modülasyon” ile yakından ilgili değildir.
Bu fenomeni
iki cismin hızı ve mesafesine bağlı olarak açıklayan denklemi burada vermenin uygun olmadığını düşünüyorum, çünkü
bu konu “Amiga'da modülasyon” konusuyla yakından ilgili değildir; bu denklemi
herhangi bir fizik veya genel akustik kitabında
hatta lise ders kitaplarında bile kolayca bulabilirsiniz.
Amiga'daki modülasyona geçersek, sizi hemen hayal kırıklığına uğratmak zorundayım
: Paula, bir kanaldan gelen sesleri hem genlik hem de frekans açısından modüle etmek için özel çalışma modlarına sahip olsa da,
 bu donanım çözümü hiçbir zaman kullanılmaz
çünkü korkunç bir kısıtlama vardır
kısıtlaması vardır: yoğunluğu ve yüksekliği modüle etmek için DMA, RAM'den
sırasıyla AUDxVOL ve/veya AUDxPER kayıtlarına girilecek değerleri okurken
başka bir DMA çalınacak ve ardından
distorsiyon uygulanacak olan gerçek örnek değerlerini okur; bu işlem, modülasyon değerleri tablosundan okuma yapan DMA'nın
ses kanallarından biri olması gerektiği için,
örneğin kanal 0'dan okunan sesi hem frekans hem de
genişlik açısından modüle etmek için, ilgili tabloları okumak için kanal 1 ve 2'yi kullanmak zorunda kalırız
tabloları okumak zorunda kalırız, bu da tek bir modüle edilmiş ses üretmek için 3 kanalın boşa harcanmasıyla sonuçlanır.
Tracker'lar tarafından kullanılan tüm modülasyon efektleri CPU tarafından yönetilir
ve CPU, istenen sesin ses seviyesi ve periyod kayıtlarını “kötü niyetle” ayarlar
, DMA ise bunun farkında olmadan örneğini okur. Böylelikle, CPU bir süre ses efektlerini gerçek zamanlı olarak hesaplamakla meşgul olsa da, hiçbir kanal
boşa harcanmaz
.
Amiga, aynı dalga formundan farklı tonlar oluşturabilen bir FM (Frequency Modulation) sentezleyicisine bile sahip değildir.
Bunlar, sentezlenen sesin 4 ana aşamasının baş harflerinden oluşan ADSR adlı 4 parametreye göre hem genlik hem de frekans modülasyonları uygular
: Attack, Decay, Sustain, Release.
Bu modülasyonun grafiği aşağıdaki gibidir: b /\ / \ D  / \ S A / \___________d / c \ /         \ R /         \ _ _ _ ______________/
Bu modülasyonun grafiği aşağıdaki gibidir:

b
/\
/ \ D 
/ \ S
A / \___________d
/ c \
/         \ R
/         \
_ _ _ ______________/                \____________________ _ _ _
a                 e

İlk aşama Attack'tır ve dalganın ses seviyesini ve/veya frekansını
‘à'dan 'b'ye (yani 0'dan maksimum tepe değerine) getirmekten oluşur; ardından
grafik Decay aşaması boyunca 'c’ seviyesine kadar düşer ve
Sustain süresi boyunca bu seviyede sabitlenir; son olarak ‘d'den 'è'ye
Release ile
0'a geri döner.
'à,'b’,'c',‘d’ ve 'è noktalarının konumları ve çeşitli aşamaların süreleri ile ustaca “oynayarak”,
sıradan bir armonika örneğinden bile sonsuz sayıda ses üretmek mümkündür.
Ne yazık ki, bu bilgiler Amiga'nın ses yongasının programlanması için size yardımcı olmayacaktır,
 bu nedenle Amiga ve donanımının tarihinde hiçbir zaman ayarlanmamış olan bitlerin açıklamasına geçelim... :)
Söz konusu kayıt, kötü şöhretli ADKCON ($dff09e) olup,
$dff010 adresinde bir okuma kopyası (ADKCONR) da bulunmaktadır:
bit - 7: USE3PN Hiçbir şeyi modüle etmemek için kanal 3'ü kullanın

bit - 7: USE3PN Hiçbir şeyi modüle etmemek için kanal 3'ü kullan
6: USE2P3 3'ün PERİYODUNU modüle etmek için kanal 2'yi kullan
5: USE1P2 2'nin PERİYODUNU modüle etmek için kanal 1'i kullan
4: USE0P1 1'in PERİYODUNU modüle etmek için kanal 0'ı kullan
		 
3: USE3VN Hiçbir şeyi modüle etmemek için kanal 3'ü kullan
2: USE2V3 3'ün SES SEVİYESİNİ modüle etmek için kanal 2'yi kullan
1: USE1V2 2'nin SES SEVİYESİNİ modüle etmek için kanal 1'i kullan
0: USE0V1 1'in SES SEVİYESİNİ modüle etmek için kanal 0'ı kullan
		 

Nasıl çalıştığını kesinlikle anlamışsınızdır: örneğin,
kanal 2'nin genliğini modüle etmek istiyorsanız, bunu sadece 1'i
AUD2VOL kaydına girilecek değerlerin okuyucusu olarak kullanarak yapabilirsiniz, bu nedenle,
kanalları ilgili verilere yöneltmeniz ve onlara bir okuma frekansı vermeniz gerekir.
** Modülasyon, her ne kadar basit bir efekt olsa da,
daha önce de belirtildiği gibi, Amiga'nın zaten az sayıdaki ses kanalını işgal etmemek için CPU aracılığıyla simüle edilmesi gereken önemli bir efekt.
**

O .... o 
o :¦ll¦: 
___( 'øo` )___
/¨¨¨(_ `____)¨¨¨\ 
(__, `----U-' .__)
( ¬\\_>FATAL< _,/¯ )
(__)\ ¯¯“:”¯¯¯ /(__)
(,,) \__ : ___/ (,,)
(_\¯¯¯ /_)
:...( Y ¬) ··:
_\___|____/_
`-----`------'

Son olarak, dijital akustik ve
ses çiplerinin genel olarak nasıl çalıştığına dair bilgi, grafik donanımı veya bir CPU'nun asm'si kadar temel değildir, ancak bunların
ustaca kullanılması, ses meraklıları da dahil olmak üzere herkes için gereklidir; ancak
aynı şekilde
 bu konuda gerçek kültürün, son zamanlarda çok övülen
dijital ses teorisi hakkında derinlemesine bilgi
içermesi gerektiği kadar, çoğu insanın bilgisiz olduğu ve
bu konudaki bilgi kaynaklarını tamamen görmezden gelen - hatta “atlayan” -
‘kodlayıcılar’ gibi düşünenler için de geçerlidir, çünkü "zaten
müzik rutinleri interrupt'tan çağrılmak yeterlidir..."

****************************************************************************
* BÖLÜM 2: GELİŞMİŞ REPLAY ROUTINES (yazar: Fabio Ciucci)     *
****************************************************************************

Bu müzik rutinleri ile ilgili olarak, şimdilik sadece protracker ile birlikte gelen standart
rutini gördük, ancak daha sofistike olanları da var.
Şimdi en iyilerinden biri olan player6.1a'yı göreceğiz. Bu rutin,
dönüştürme programı (bu diskteki p61con) gerektirir ve bu programla normal bir
modülü replay rutini için optimize edilmiş bir modüle dönüştürmemiz gerekir.

NOT: Bu oynatıcı, yazarın telif hakkıdır:

Jarno Paananen / Guru of Sahara Surfers.
­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­

J.Paananen
Puskalantie 6
FIN-37120 Nokia
Finland

İnternet:     Jarno_Paananen@sonata.fipnet.fi
jpaana@freenet.hut.fi


Dolayısıyla, bu oynatıcıyı ticari bir üründe, örneğin bir oyunda kullanacaksanız,
 onun yazılı iznini almanız ve ona
yüzde olarak bir miktar (Finlandiya markası!) ödemeniz gerekir.
Zaten tüm arşivi eklemediğim için bana kızacaktır!!!...

Bu oynatıcı çok sayıda seçeneğe sahiptir, şimdilik en basitini yapalım
: protracker programıyla birlikte sağlanan standart rutinle yaptığımız gibi bir modülü çalmak
.

Yapılması gerekenler şunlardır:

1) “P61CON” yardımcı programını kullanarak modülü P61 formatına dönüştürün. Bu
yardımcı programın çalışması için libs dizininde reqtools.library ve powerpacker.library
dosyaları bulunmalıdır. Programın tercihlerinde hiçbir şeyi
değiştirmeyin, sadece “zaman” seçeneğini ayarlı bırakın.
Kaydederken USECODE'u not edin, bu listeye
“use = ....” eşlemesinde belirtilmelidir. Bu, koddan tasarruf etmek için gereklidir.

2) Bu şekilde, modülü SIKIŞTIRILMAMIŞ olarak dönüştürmüş olduk.
Buna rağmen, modül genellikle otomatik olarak yapılan optimizasyon nedeniyle kısalır
.

3) Şimdi önceki rutinlerde olduğu gibi yapmanız yeterlidir: çalmadan önce P61_Init'i,
 ardından her karede P61_Music'i ve sonunda P61_End'i çağırın.
Tek ek istek, seviye 6 kesintisinin etkinleştirilmesidir.

Ders 14-10a'da pratik bir örnek görelim.

Standarttan daha hızlı olduğunu, ancak CIAB'nin
A zamanlayıcısını ve seviye 6 kesmesini ($78) kullandığını fark edeceksiniz.
Ayrıca, anlamlarını bilmeniz gereken bazı eşdeğerler vardır:

fade = 0    ;0 = Normal, ana ses kontrolü mümkün DEĞİL
;1 = Ana sesi kullan (P61_Master)

Fade yapmak için ses seviyesini kontrol etmek istiyorsanız,
P61_Master etiketine etki ederek bunu 1 olarak ayarlamanız gerekir. Daha sonra bir örnek göreceğiz. Bu seçeneğe ihtiyacınız yoksa,
 koddan tasarruf etmek için 0 olarak ayarlayın, çünkü bu eşdeğerler,
 “ifeq”, ‘ifne’, “endc” gibi
asembler direktiflerini kullanan koşullu birleşimlerden başka bir şey değildir...

jump = 0    ;0 = konum atlama kodunu dahil ETMEYİN (P61_SetPosition)
;1 = Dahil edin

Bu seçenek de, modülün belirli bir konumuna atlama rutini kullanılmıyorsa sıfır olarak bırakılmalıdır.
Bir örnek daha sonra göreceğiz.

system = 0    ;0 = katil
;1 = dost

Bu seçenek, “kötü” kod yazıyorsanız ve startup2.s kullanıyorsanız 0 olarak bırakılmalıdır.
Dos'tan yüklerken dikkatli olun!!! (Ayrıca
sistem kesmesini geri yüklemeden, kesme $78 (seviye 6)
yerinde bırakın, bu replay rutini aktifken yükleme yaparsanız!).

CIA = 0        ;0 = CIA devre dışı
;1 = CIA etkin

Bu seçenek, rutini “standart” şekilde kullanmak için 0 olarak bırakılmalıdır.
1 olarak ayarlanırsa, her karede P61_Music'i çağırmaya gerek kalmaz, çünkü
zamanlama tamamen CIAB ile yapılır. Bir örnek göreceğiz.

exec = 1    ;0 = ExecBase yok
;1 = ExecBase geçerli

Burada 1 olarak bırakılmalıdır, çünkü $4.w'de execbase'i geçerli bırakıyoruz... biz
manyak değiliz!!! Peki, başlangıcı ne yapacağız?

opt020 = 0    ;0 = MC680x0 kodu
;1 = MC68020+ veya daha iyisi

Bu açık: oyun/demo'nuz AGA only ise, bunu
1'e ayarlayabilirsiniz, aksi takdirde sıfırda bırakın. Gereksiz yere 1'e ayarlamamaya dikkat edin
!!!!!! SADECE OYUN/DEMO **SADECE** AGA'DA (yani 68020+) ÇALIŞIYORSA.

use = $2009559    ; Usecode (p61con tarafından kaydedilen değeri girin
; her modül için farklıdır!)

Buradaki yorum her şeyi açıklıyor... usecode'u her zaman bir kağıda not edin
(kağıdı kaybetmeyin tabii ki) ve buraya yazın.
Bu, modülde kullanılan efekt rutinlerini bir araya getirmek için gereklidir
ve yerden tasarruf sağlar. -1 yazmak, her şeyi bir araya getirmek anlamına gelir (puah!).
____ 
/ \
_ |______| _
/(_|/\/\/\|_)\
(______________)
| .. |
| \__/ |
|______|
.--' `--.
| | | |
| |______| |
|_||||||||_|
(^) ____ (^)
| || |
_| _||_ |_
/____\/____\

Dönüştürme programı modülü sıkıştırmaya da izin verir, ancak
bu biraz kalite kaybına neden olur. Bu nedenle modülleri sıkıştırmamanızı tavsiye ederim...
40k'lık bir intro yapmanız gerekmedikçe ve yer açısından sıkışık durumda değilseniz,
 modülü “normal” şekilde dönüştürerek kullanmanız her zaman daha iyidir.
Her neyse, program hangi örneklerin sıkıştırılacağını ve hangilerinin sıkıştırılmayacağını seçmenize
ve kalite kaybının çok fazla olup olmadığını kendi kulaklarınızla dinlemenize olanak tanır!!!

Sıkıştırılmış bir modülü sıkıştırmak ve yeniden çalmak için yapmanız gerekenler şunlardır:

1) Modülü “P61CON” ile sıkıştırılmış P61 formatına dönüştürün.
Programın tercihlerinde “pack samples” seçeneğini etkinleştirin.
Hangi örneklerin sıkıştırılacağını ve hangilerinin sıkıştırılmayacağını seçebileceğinizi unutmayın.
Her örnek için şunu göreceksiniz:

Orijinal     -Orijinal örneği çalar (Sağ fare tuşuyla durdurun)
Sıkıştırılmış     -Örneği sıkıştırılmış haliyle çalar.
Kalitede çok fazla kayıp olduğunu fark ederseniz, tekrar düşünün...!
Sıkıştır         -Bu örneği “sıkıştırılacak” olarak işaretler
Pack rest     -Buradan itibaren tüm diğer örnekleri sıkıştırır
Don't pack     -Bu örneği sıkıştırmayın
Don't pack rest -Diğer tüm örnekleri (buradan itibaren) sıkıştırmayın
Her zamanki gibi, kaydetme sırasında USECODE'u not edin.
Ayrıca, “sample buffer length”ı da not edin!!!!!!

2) Bu şekilde, dönüştürülmüş ve SIKIŞTIRILMIŞ modülü elde ettik.

3) Şimdi yapılacak 2 şey daha var: öncelikle, modülün sıkıştırılmış örnekleri var,
 bunlar bir tampona açılmalıdır. Bunu yapmak için
2 şey yapmanız gerekir: programda “sample buffer
length” olarak belirtilen uzunlukta bir tampon oluşturun ve P61_Init'i çağırmadan önce adresini a2'ye koyun, bu
sıkıştırmayı açacaktır. Geri kalanı (play ve end) aynıdır.
Hepsini pratikte görelim:

movem.l    d0-d7/a0-a6,-(SP)
lea    P61_data,a0    ; Modülün adresi a0'da
lea    $dff000,a6    ; $dff000'ı a6'da hatırlayalım!
sub.l    a1,a1        ; Örnekler ayrı değil, sıfır koyalım
*******************
>>>>>    lea    samples,a2    ; modül sıkıştırıldı! Hedef tampon
*******************        ; belirtilecek örnekler (çip ram'de) için!
bsr.w    P61_Init    ; Not: açmak birkaç saniye sürer!
movem.l    (SP)+,d0-d7/a0-a6

Modül ve tampon için değişiklikler şunlardır:

1) Modülün çip ram'e yüklenmesi artık gerekmez:

Section    modulozzo,data    ; Çip ram'de olması gerekmez, çünkü
; sıkıştırılmıştır ve başka bir yerde açılacaktır!
P61_data:
incbin    “P61.stardust”    ; Sıkıştırılmış, (PACK SAMPLES seçeneği)

2) Tampon, CHIP RAM'e yüklenmeli ve belirtilen uzunlukta olmalıdır:

section    smp,bss_c

samples:
ds.b    132112    ; p61con tarafından bildirilen uzunluk


Gördüğünüz gibi, örneklerde kalite kaybının yanı sıra, daha fazla bellek de kullanılır
çünkü modül daha kısa olmasına rağmen tampon da eklenmiştir.

Ders 14-10b.s'de bir örnek görelim.

Şimdi 2 ana uygulamayı gördük, tüm
varyantları görebiliriz. Öncelikle, eşitleme ile etkinleştirilen CIA seçeneği.
Ders 14-10c.s ve Ders 14-10d.s'de 2 örnek görebilirsiniz.

veya
veya. ______
°O|.____.|
°o.|| .. ||
O|`----‘|
|______|
.--’ `--.
| | | |
| | | |
|_|______|_|
(^) ____ (^)
| || |
_| _||_ |
/____\/___\

Son olarak, 2 isteğe bağlı seçeneğin kullanımını görelim:

Sesin kaybolması: “fade” eşleşmesini etkinleştirin ve 0 ile 64 arasında değişen
“P61_Master” etiketine tıklayın. Örnek için Ders 14-10e.s

Modülün rastgele konumlarına atlama imkanı: “jump” eşleşmesini etkinleştirin ve
d0 kaydındaki konumla “P61_SetPosition” rutinini çağırın.
Örnek: Ders 14-10f.s

Diğer opsiyonel özellikler de vardır, bunları tercihler bölümünde özetleyebiliriz:

İki dosya:		Bu seçenek, örnekleri ve
şarkıyı 2 dosyaya ayrı ayrı kaydeder. Aynı örnekleri içeren birden fazla modül
kullanıyorsanız bu seçenek yararlı olabilir...

P61A işareti:        modülün başına P61A işaretini koyar...
sadece kötü niyetli kişilerin modülü kopyalamasını kolaylaştırmak için
kullanılabilir!!! Asla ayarlamayın!

No samples:        Aynı sample'lara sahip birçok modül kaydedildiğinde kullanılır
: ilk kez “two files” seçeneğini seçin
ve modülleri ve ilk şarkıyı kaydedin. Ardından
bu seçeneği seçin ve diğer tüm şarkıları kaydedin.

Tempo:            Oynatıcıda “Tempo” seçeneğini kullanmak için.

Simge:            Modülle birlikte bir simge kaydetmek istiyorsanız

Delta:            4 bit yerine 8 bit sıkıştırma (neredeyse hiçbir fark olmadığını fark ettim... neyse!)

Örnek paketleme:        Örnekleri 4 bit delta algoritmasıyla sıkıştırmak için ayarlayın (KALİTE KAYBI!!!).

____ ________ ____
\__ \__ / __ \ __/ __/
\____|o o \/ o o|____/
\__|__________|__/
| ___/__\
_|__ \__/ \\_
(_______/U \/
____/\_\___U_/ \_____/_/\____
\ ___/ (_(_______)_) \___ /
\_\/ / | \ \/_/
/ / | \ \
/ /________|_______/\ \
/ / _____ \ \
\ / /
\_______________________/

Herkese iyi dinlemeler!
