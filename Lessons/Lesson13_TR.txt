
DERS 13: ASSEMBLY KODUNUN OPTİMİZASYONU

Yazarlar: Fabio Ciucci, Ugo Erra

Teşekkürler: Michael Glew, 2-Cool/LSD, Subhuman/Epsilon


Assembly dilinde rutinler yazmak, kodunuzun en yüksek hızda çalışacağı anlamına gelmez.
 Aslında, assembly kodu her zaman hız açısından en iyisi olarak sınıflandırılamaz.
 Piyasada bulunan sayısız demoyu ve özellikle 3D grafiklerle ilgili olanları ele alalım.
 Çoğu durumda
(hemen hemen her zaman) rotasyon, zoom, dünya keşfi gibi efektlerin altında yatan rutinler aynıdır, ancak bunların
assembly kodundaki uygulamaları farklıdır, çünkü her programcı bunları
mümkün olan en iyi şekilde, yani en yüksek
hızda çalışacak şekilde uygulamaya çalışır.
 Bu, her
iyi montaj kodlayıcının bilmesi gereken optimizasyon teknikleriyle gerçekleştirilir. Teknikler çoktur ve
tamamen doğal bir şekilde kullanmaya başlamadan önce
biraz zaman alır. Çeşitli optimizasyon türleri vardır ve
teknikler 68000 için geçerlidir, ancak aynı teknikler
68040 veya 68060 gibi mikroişlemcilerde işe yaramaz.
İlk olarak, 68000'in her komutunun makine döngü tablosuna
sahip olmanız gerekir. Bu tabloyu bu derste özet olarak bulabilirsiniz:
Bu tabloya hızlıca baktığınızda, her komutun yürütülmesi için geçen
“süre”ye şaşırmanız muhtemeldir. Belki de
bu noktaya kadar her komutun aynı anda yürütüldüğünü düşünüyordunuz;
ama yanılıyordunuz!!!
Aslında, ilk yaklaşım olarak, bir çarpma komutunun (MULU) bir toplama komutuna (ADD) göre ne kadar zaman aldığını fark edin ve
optimizasyonun neden önemli olduğunu hemen anlayacaksınız:
ADD    ; yürütme süresi: 6 saat

ADD    ; yürütme süresi: 6 ila 12+ saat döngüsü

MULS    ; yürütme süresi: 70+ saat döngüsü

Bu durumda, bu komutu nasıl optimize edeceğinizi kolayca anlayabilirsiniz:

yavaş:        MULU.W    #2,D0    ; 70+ döngü

optimize edilmiş:    ADD.W    d0,d0    ; 6+ döngü

Çarpma ve bölme işlemlerinin en yavaş iki komut olduğunu
önceden belirtelim. Komutları en hızlıdan en yavaşına doğru sıralanmış yaklaşık bir listeye bakalım
: (döngüler en iyi durumda!)

EXT, SWAP, NOP, MOVEQ    ; 4 döngü -> en hızlılar!

TST, BTST, ADDQ, SUBQ, AND, OR, EOR    ; 4 + adresleme, hızlı...

MOVE, ADD, SUB, CMP, LEA    ; 4+ adresleme, ancak genellikle
; adreslemeler “ağır”dır

Ardından 8+ ile BCLR/BCHG/BSET, 6 +2n ile LSR/LSL/ASR/ASL/ROR/ROL gelir, burada
n yapılacak kaydırma sayısıdır, son olarak ise:

MULS/MULU    ; 70+ !
DIVU        ; 140+ !!
DIVS        ; 158+ !!!

Ayrıca şunu da unutmamak gerekir:

BEQ,BNE,BRA...    ; 10
DBRA        ; 10
BSR        ; 18
JMP        ; 12
RTS        ; 16
JSR        ; 16/20

Bu nedenle, alt rutinlere çok fazla çağrı yapmamaya dikkat edin, çünkü geri dönmek için her
BSR+RTS en az 18+16=34 döngü tüketir!
Kısa alt programları her zaman ana döngüye koyun, bir avuç komutu çalıştırmak için 34 BSR+RTS döngüsü kaybetmek israftır!
ÖRNEK:

BSR.S    ROUT1
BSR.S    ROUT2
BSR.S    ROUT3
RTS

ROUT1:
MOVE.W    d0,d1
RTS
ROUT2:
MOVEQ    #0,d2
MOVEQ    #0,d3
RTS
ROUT3:
LEA    label1(PC),A0
RTS

34*3= 96 döngü tasarruf eden versiyon:

ÖRNEK DÜZELTME:
MOVE.W    d0,d1
MOVEQ    #0,d2
MOVEQ    #0,d3
LEA    label1(PC),A0
RTS

Komutun kendisinin yanı sıra, kullanılan adresleme şekli de önemlidir.
Örneğin:

MOVE.L    (a0),d0

şundan daha yavaştır:

MOVE.L    $12
(a0,d1.w),LABEL1

Yine de her ikisi de MOVE komutlarıdır. Ancak, ikinci komutun ilkine göre neden daha yavaş olduğu size çok
mantıklı gelebilir: işlemci, a0'a d1'in değerini
artı $12'yi ekleyerek ofseti hesaplamalı, ardından kopyalamalı ve nereye? Bellekte, bir etikete,
bir kayıt yerine, ki bu çok daha yavaştır çünkü kayıtlar işlemcinin İÇİNDE
bulunurken bellek dışarıdadır ve verinin oraya ulaşması için
ana kartın kablolarından geçmesi gerekir!!!!!

*****************************************************************************
* BİRİNCİ DÜZEY OPTİMİZASYONLAR: KOMUT “DEĞİŞİMİ” VE “SEÇİMİ” *
*****************************************************************************

İşte en hızlıdan en yavaşına doğru sıralanmış adresleme yöntemleri:
NOT: ; işaretinden sonraki sayılar, bayt-kelime/uzun kelime durumlarında komutun kullandığı süreye eklenecek saat döngüleridir
.


Doğrudan veri kaydı                     Dn/An     ; 0

Dolaylı adres kaydı (veya Post-Increment ile)	 (An)/(An)+ ; 4/8
Anında                         #x     ; 4/8

Ön Azaltmalı Dolaylı Adres Kaydı         -(An)     ; 6/10

Ofsetli Dolaylı Adres Kaydı (maks. 32767)     w(An)     ; 8/12
Kısa mutlak                         w     ; 8/12
Ofsetli Program Sayacı (asmone tarafından hesaplanır)     w(PC)     ; 8/12

Ofsetli ve İndeksli Program Sayacı            b(PC,Rx) ; 10/14
Ofsetli ve İndeksli Dolaylı Adres Kaydı    b(An,Rx) ; 10/14

Uzun mutlak                         l     ; 12/16


Görüldüğü gibi, sadece adresleme içeren bir “MOVE.L LABEL1,LABEL2”
16+16 = 32 döngü sürerken, bir “MOVE.L #1234,d0” sadece 8+0 = 8 döngü sürer.
.W komutlarının .L komutlarından daha hızlı olduğu açıktır,
örneğin adresleme (An), .W 4 döngü kullanırken, .L 8 döngü kullanır!

Ancak bu örnekler ÇOK göstergedir, çünkü
tabloları inceleyerek bile
rutinin yürütme süresini gerçekten hesaplamak zordur. Ancak BSR'nin JSR'den daha hızlı,
 ADDQ'nun ADD'den daha hızlı ve her şeyden önce
bir MULU/DIVU/MULS/DIVS'yi başka bir şeyle değiştirebildiğimizde
her şeyi kesinlikle hızlandırdığımızdan emin olabiliriz!

Burada “komut değişikliklerinden” bahsediyoruz, yani yavaş komutları daha hızlı olanlarla değiştirerek yapılan küçük değişikliklerden
yavaş komutları daha hızlı olanlarla değiştirerek yapılan küçük değişikliklerden bahsediyoruz. Ancak
demo sahnesinin gerçek kraliçesi olan optimizasyon sanatı, aynı sonuçları veren devasa bir fonksiyon uygulamak yerine
“önceden hesaplanmış” bir tablo kullanmayı ve daha pek çok şeyi içerir.

Ancak bunun bir de tersi var: tablolar ve diğer hilelerle mega optimize edilmiş kod
genellikle daha az okunabilir ve anlaşılır hale gelir ve
daha az “değiştirilebilir” olur. Bu nedenle, çoğumuzun düştüğü hatayı
yapmamaya dikkat edin, yani rutini bitirmeden
,
 adım adım, ne pahasına olursa olsun. Bu, söz konusu rutinin geliştirilmesini yavaşlatmaktan başka bir işe yaramaz, özellikle de yeni başlayanlar için.
 Aslında, perspektifi hesaplayan mega optimize edilmiş bir rutinin ne faydası var,
 eğer katı cismin çizim ve döndürme rutinini “etrafına” yazamıyorsak
? Hatta neden
çalıştığını bile anlamıyoruz? ---->>>>> ASLA OPTİMİZASYONDAN GEÇMEMELİSİNİZ,
VE ÇALIŞMAYAN BİR RUTİNİ ASLA OPTİMİZE ETMEYİN; AYRICA, OPTİMİZE EDİLMEYE HAZIR OLDUĞUNDA,
 OPTİMİZASYONUN ÇEŞİTLİ AŞAMALARININ LİSTELERİNİN KOPYALARINI SAKLAMAYI UNUTMAYIN,
 ÇÜNKÜ SIK SIK “GERİ DÖNÜP”
VE BİR ŞEYLER DEĞİŞTİRMEK GEREKEBİLİR!!! DAHA SONRA DEĞİŞTİRİLEN VERSİYONU YENİDEN OPTİMİZE EDECEĞİZ!

Bu uyarı size garip gelebilir, çünkü bir liste,
optimize edildikten sonra, yazarı için bile tanınmaz ve anlaşılmaz hale gelir.
 Evet, ÇOK optimize edildiyse, bu olabilir!
Ancak, optimizasyonların,
örneğin,
 başlangıçta
sadece bir kez veya her kare için bir kez gerçekleştirilen bir rutini optimize etmenin bir anlamı yoktur. İlk
, kare başına birçok kez yürütülenler,
yani dbra döngülerinde veya çeşitli döngülerde olanlardır. Örneğin,
şu listeye bakalım:

Bau:
cmp.w    #$ff,$dff006    ; Wblank'ı bekle
bne.s    Bau
bsr.s    routine1
bsr.s    routine2
btst    #6,$bfe001    ; Fareyi bekle
bne.s    Bau
rts

Rutin1:
move.w    #label2,d6
move.w    d0,d1
move.w    d2,d3
and.w    d4,d5
rts

Rutin2:
move.w	#200,d7
lea	label2(PC),a0
lea	label3(PC),a1
loop1:
move.w	(a0)+,d0
move.w	(a0)+,d1
add.w	d0,d5
add.w	d0,d6
move.w	d5,(a1)+
move.w	d5,(a2)+
dbra    d7,loop1
rts

Bu durumda, zamanın %99'unun
200 kez rutin2 döngüsünü çalıştırarak kaybedildiği açıktır. Sonuç olarak, bu
döngü iki kat daha hızlı hale getirilirse, tüm program iki kat daha hızlı çalışır,
 ancak rutin2'yi üç veya dört kat daha hızlı çalıştırırsanız,
 farkı bile fark etmezsiniz!!!!!
Bir rutinin kaç “raster satırı” kapladığını görmek için, rutinin başında rengi değiştiren eski
sistemi kullanın ve rutinin sonunda rengi tekrar değiştirin
. Bu şekilde, değiştirilen rengin “şeridi”
yürütme için kullanılan “video satır” süresini gösterecektir:

Bau:
cmp.w    #$90,$dff006    ; Wblank'ı bekle
bne.s	Bau
bsr.s    routine1
move.w    #$F00,$dff180    ; Renk0: KIRMIZI
bsr.s    routine2
move.w    #$000,$dff180    ; Renk0: SİYAH
btst    #6,$bfe001    ; Fareyi bekle
bne.s    Bau
rts

Bu durumda, ekranın ortasına doğru $90 satırını bekleyin,
önemli olmayan rutin1'i çalıştırın, ardından rengi değiştirin (kırmızı),
rutin2'yi çalıştırın ve rengi geri değiştirin (siyah).
Ekranda kırmızı bir çizgi görünecektir... bu,
. Hızın arttığını veya azaldığını görmek için
çizginin uzayıp uzamadığına bakmak yeterlidir.
Bazı manyağı (arkadaşım hedgehog gibi), monitörün son renkli çizgisinin yüksekliğine bir parça
bant yapıştırırlar, böylece
her değişiklikte en ufak bir iyileşme veya kötüleşmeyi fark edebilirler.
Ben şahsen parmağımı koyuyorum veya gözümle bakıyorum... siz nasıl isterseniz!
Bu sistemi blitter dersinde ve
Ders 11n1.s ve devamında, CIAA/CIAB yongaları aracılığıyla beklenen süreyi “görselleştirmek” için zaten görmüştük. Bu arada, zamanlayıcıları da
süreleri
 “sayısal olarak” hesaplamak için zamanlayıcıları da kullanabilirsiniz, ancak renk değiştirme sistemi daha hızlıdır.

Ama önce, yazarken “canlı” olarak bilmeniz gereken temel optimizasyonlarla başlayalım
.
 En basit şey, belirli bir görevi yapmak istediğinizde,
olası komutlar arasından hangisini seçeceğinizi bilmektir.
 Aslında aynı işlem birden fazla şekilde yapılabilir!
Örneğin, şu listeye bakalım:

lea    LABEL1,a0
move.l    0(a0),d0
move.l    2(a0),d1
ADD.W    #5,d0
SUB.W    #5,d1
MULU.W    #2,d0
MOVE.L    #30,d2
RTS

Aynı şey, şu komutları seçerek de yapılabilir:

lea    LABEL1(PC),a0    ; Daha hızlı adresleme (PC)
move.l    (a0),d0        ; 0 ofseti gerekmiyordu!
move.l    2(a0),d1    ; Bu olduğu gibi bırakılır
ADDQ.W    #5,d0        ; 8'den küçük sayı, ADDQ kullanılabilir!
SUBQ.W    #5,d1        ; aynı, SUBQ için!
ADD.W    d0,d0        ; 60 döngü tasarruf ettik!! D0*2, D0+D0'a eşittir!!!
MOVEQ    #30,d2        ; 127'den küçük sayı, MOVEQ kullanabilirim!
RTS

Rutin çok daha hızlı ve her zaman okunaklı. Dolayısıyla,
öğrenilmesi gereken ilk şey, ADDQ/SUBQ/
gibi Quick komutlarını dikkatli kullanmakMOVEQ gibi özel Quick komutlarını kullanmaya dikkat etmek,
mümkün olduğunda çarpma ve bölme işlemlerini kaldırmak,
(PC) veya kayıt+ofset ile ilgili adreslemeleri, çıplak LABEL yerine kullanmak
vb. Biraz deneyim kazandıkça, en hızlı komutları
seçmek size doğal gelecek ve ilk denemede ikinci gibi listeler yazacaksınız,
ilk sunulan gibi listeler değil, ki umarım bunları yazmıyorsunuzdur!!!!
İşte komut “değişimi” ile optimizasyonun bir başka örneği:

Move.l    #3,d0        ; 12 döngü
Clr.l    d0        ; 6 döngü
Add.l    #3,a0        ; 16 döngü
;
Move.l    #5,Label    ; 28 döngü

“Değişim” ile optimize edilmiş versiyon:

Moveq    #3,d0        ; 4 döngü
Moveq    #0,d0        ; 4 döngü
Addq.w    #3,a0        ; 4 döngü
;
Moveq    #5,d0        ; 4 döngü
Move.l    d0,Label    ; 20 döngü, toplam 24 döngü

Bu tür örneklerle daha uzun süre devam edebilirim, ancak
tüm olası durumları ezbere bilmenize gerek yok elbette!
Daha çok “yöntemi”, optimize edilmiş kodlamanın felsefesini anlamanız gerekir.
Örneğin, kayıtlara 32 bit değerlerin yüklenmesini hızlandırmak için teknikler vardır
:

move.l    #$100000,d0    ; 12 döngü

Optimize edilmiş versiyon:

moveq    #10,d0        ; 4 döngü
Swap    d0        ; 4 döngü, toplam 8 döngü

Bir başka ÖNEMLİ nokta, belleğe (yani etiketlere) erişimin
veri ve adres kayıtlarına erişimden çok daha YAVAŞ olmasıdır. Bu nedenle
tüm kayıtları kullanmaya ve etiketlere mümkün olduğunca az dokunmaya
özen göstermek iyi bir alışkanlıktır. Örneğin, aşağıdaki liste:

MOVE.L    #200,LABEL1
MOVE.L    #10,LABEL2
ADD.L    LABEL1,LABEL2

Aşağıdaki şekilde yazarak ÇOK daha iyi bir sonuç elde edebilirsiniz:

move.l    #200,d0
moveq    #10,d1
add.l    d0,d1

Örneğin aptallığına dikkat etmeyin, ilkinde
çok yavaş RAM'e 4 kez erişim yaptık ve verileri
anakartın karmaşık kablolarından geçirdik, ikinci durumda ise her şey
CPU içinde gerçekleşti ve her şeyi karıştırdı. Veri kayıtları biterse,
etiketlere erişmek yerine adres kayıtlarını da veri saklamak için kullanın!
Ayrıca, mümkünse .L yerine .W komutlarını kullanın, örneğin
önceki listeyi şu şekilde yeniden optimize edebilirsiniz:

move.w    #200,d1
moveq    #10,d0
add.w    d0,d1

Bu durumda komutlar 12 yerine 8 döngü kaplar... ve bu azımsanacak bir şey değildir!
Ancak, yüksek kelimenin sıfırlandığından ve/veya asla gerekli olmadığından emin olun!

Her neyse, en karlı “değişim” optimizasyonları,
çarpma (70 döngü) ve bölme (158 döngü) komutlarını ortadan kaldıranlardır
ve bu konuda bir bilim dalının doğduğunu söyleyebiliriz.
En basit durum, 2'nin kuvvetleri olan sayıları bölmemiz veya çarpmamız gerektiğinde
çünkü tam olarak makine döngüleri olarak kullanan kaydırma komutlarını kullanabiliriz
:

Lsl.w    6+2n        ; n = kaydırma sayısı
Asr.w    6+2n
Lsr.l    8+2n
Asr.l    8+2n

Burada n bit sayısını gösterir ve döngü sayısı
kayıtların kullanıldığı zamana atıfta bulunur.
Genellikle izlenecek kural şudur: (MULS veya MULU için)

Not: Bazen MULS'leri değiştiren ASL'lerden önce bir EXT.L D0 gerekir,
MULU'ları değiştirenlerden önce ise “swap d0, clr.w d0, swap d0” ile yüksek kelimenin temizlenmesi gerekebilir.

MULS.w	#2,d0        | ADD.L d0,d0 ; bana açık görünüyor!

MULS.w    #4,d0        | ADD.L d0,d0 ; bu da!
| ADD.L d0,d0

MULS.w    #8,d0        | ASL.l #3,d0 ; 8'den 256'ya kadar asl kullanmak daha uygun
MULS.w    #16,d0        | ASL.l #4,d0
MULS.w    #32,d0        | ASL.l #5,d0
MULS.w    #64,d0        | ASL.l #6,d0
MULS.w    #128,d0        | ASL.l #7,d0
MULS.w    #256,d0        | ASL.l #8,d0

MULU ile sorun varsa, yüksek kelimeyi temizleyebilirsiniz:

mulu.w #n,dx ->    swap dx        ;n is 2^m, 2..2^8
clr.w dx    ;(2,4,8,16,32,64,128,256)
swap dx
asl.l #m,dx

Muls için asl'den önce bir “ext.l” koymak yeterli olabilir.

muls #n,dx ->    ext.l dx    ;n is 2^m, 2..2^8
asl.l #m,dx

BÖLÜMLER için ise:

DIVS.w    #2,d0		| ASR.L #1,d0    ; dikkat: GERİ KALANINI İGNORE EDİN!!!!!!!
DIVS.w    #4,d0        | ASR.L #2,d0
DIVS.w    #8,d0		| ASR.L #3,d0
DIVS.w    #16,d0        | ASR.L #4,d0
DIVS.w    #32,d0        | ASR.L #5,d0
DIVS.w    #64,d0        | ASR.L #6,d0
DIVS.w    #128,d0		| ASR.L #7,d0
DIVS.w    #256,d0        | ASR.L #8,d0
DIVU.w    #2,d0        | LSR.L #1,d0    ; dikkat: GERİ KALANINI İGNORE ET!!!!!!!!
DIVU.w    #4,d0        | LSR.L #2,d0
DIVU.w    #8,d0        | LSR.L #3,d0
DIVU.w    #16,d0        | LSR.L #4,d0
DIVU.w    #32,d0		| LSR.L #5,d0
DIVU.w    #64,d0        | LSR.L #6,d0
DIVU.w    #128,d0        | LSR.L #7,d0
DIVU.w    #256,d0        | LSR.L #8,d0

Bildiğiniz gibi, bir bölme işleminden sonra düşük kelimede sonuç kalır ve
yüksek kelimede kalan kısım kalır; DIVS/DIVU'yu bir kaydırma ile değiştirirseniz
sonuç düşük kelimede kalır ve yüksek kelime sıfırlanır... bu nedenle AYNI ŞEY DEĞİLDİR,
 dikkatli olun!
En kötü durumda, n=8 olduğunda, tam olarak
6+2*8=22 döngü kelime ve 8+2*8=24 döngü uzun kelime elde edersiniz, bu nedenle
tasarruf garantilidir. Ayrıca, 68020'de
shift komutları için döngü sayısı, kaydırılacak bit sayısından bağımsız olarak aynıdır
.
 Ayrıca, Swap komutunun
4 döngüde yürütüldüğünü de unutmayın, çünkü bu komut, kaydırılacak bit sayısı fazla olan birçok
durumda kullanışlı olabilir. 
Bu konuda bir dizi örnek görelim:

; 9 bit sola kaydırma

Lsl.l    #8,d0
Add.l    d0,d0

; 16 bit sola kaydırma

Swap    d0
Clr.w    d0

; 24 bit sola kaydırma

Swap    d0
Clr.w    d0
Lsl.l    #8,d0

; 16 bit sağa kaydırma

Clr.w    d0
Swap    d0

; 24 bit sağa kaydırma

Clr.w    d0
Swap    d0
Lsr.l    #8,d0

Gördüğünüz gibi, kaydırma teknikleri çoktur ve bunlardan
çok sayıda elde edilebilir. Her zamanki gibi, doğru bakış açısını yakalamak
ve aradığınız optimizasyonu yapmaya çalışmak size kalmıştır. Dolayısıyla, 2'nin kuvvetleri için
çarpma ve bölme işlemlerini makul bir sürede yapmakta büyük bir sorun yaşamazsınız.
Sorun, sayının 2'nin kuvveti olmaması durumunda ortaya çıkabilir
; bu doğru, ancak birçok değer için
bu sorunu yine de aşabiliriz. Örneğin, bir kayıtta bulunan değeri 3 ile çarpmamız gerektiğini düşünelim
bir kayıtta bulunan değeri 3 ile çarpmanız gerektiğini düşünün: peki,
3*x gibi bir ifadeyi gerçekleştirmeniz gerektiğini düşünün, bunu
2*x+x olarak da yazabilirsiniz. Bu noktada sorununuzu çözdünüz çünkü
kodunuz şöyle olacaktır:

Move.l    d0,d1
Add.l     d0,d0 ; d0=d0*2
Add.l     d1,d0 ; d0=(d0*2)+d0

Başka bir örnek olarak n=5'i ele alalım, o zaman 5*x, yani
4*x+x elde ederiz: kod olarak şunu elde ederiz:

Move.l    d0,d1
Asl.l    #2,d0 ; d0=d0*4
Add.l    d1,d0 ; d0=(d0*4)+d0

Son olarak, n=20 olduğu başka bir durum ele alalım, o zaman 20*x elde ederiz, ancak
20*x = 4*(5*x) = 4*(4*x+x)

Move.l    d0,d1
Asl.l    #2,d0 ;d0=d0*4
Add.l    d1,d0 ;d0=(d0*4)+d0
Asl.l    #2,d0 ;d0=4*((d0*4)+d0)

Kısaca,
sayıyı asal çarpanlarına ayırarak çok sayıda 2 olduğunu fark edersek, böyle bir şey yapmayı deneyebiliriz; ancak,
döngü sayısını sayarak bunun size uygun olup olmadığını kontrol edin.
Çoğunuz burada basit bir Mulu veya Divu'yu optimize etmenin yolunu görmekten şaşırmış olabilirsiniz,
 ancak bunların döngülerde bulunduğu durumları düşünün, bu durumda bu teknikler gerçekten çok
yararlıdır, ancak Mulu bir döngüde bulunmasa bile, onu daha iyi bir şeyle değiştirmek size neye mal olur
?
Konumuzla ilgili olarak, Assembly'de ifadelerin uygulanmasından çok kısaca bahsedelim
.
Size söyleyeceğim şey özel bir şey değil, ancak genellikle önemsiz bir gerçeğe dikkat edilmez
.
Bir işlevi uygulamamız gerektiğinde, genellikle yaptığımız şey
değerleri kayıtlara yüklemek ve tüm işlemleri gerçekleştirmektir.
Genel olarak, fonksiyonun değerlendirilmesinde makine zamanından tasarruf etmek için
lise düzeyinde öğrenilen toplama yöntemlerini kullanmak daha uygundur.
Örneğin, basit bir ifadeyi ele alalım:

a*d0+b+d1+a*d3+b*d5 şu şekilde yazılabilir:

a*(d0+d3)+b*(d1+d5)

Bu şekilde iki çarpma işleminden tasarruf ediyoruz.

Doğru komutu seçmek için her
eşdeğer komut çiftinden hangisinin daha hızlı olduğunu bilmek yeterli olduğundan, 68000-2.txt dosyasının sonundaki tabloya benzer, “yavaş” komutlar ve
kullanılacak “hızlı” eşdeğer komutları içeren bir tablo sunuyorum:
EŞDEĞER, AMA DAHA HIZLI ------------------------|-----------------------------------

KOMUT ÖRNEĞİ    | EŞDEĞER, AMA DAHA HIZLI
------------------------|-----------------------------------------------
add.X #6,XXX        | addq.X #6,XXX        (maksimum 8)
sub.X #7,XXX        | subq.X #7,XXX        (maksimum 8)
MOVE.X LABEL,XX        | MOVE.X LABEL(PC),XX    (aynı SECTION içindeyse)
LEA LABEL,AX		| LEA LABEL(PC),AX    (aynı BÖLÜM içindeyse)
MOVE.L #30,d1        | moveq #30,d1        (min #-128, max #+127)
CLR.L d4        | MOVEQ #0,d4        (sadece veri kayıtları için)
ADD.X/SUB.X #12000,a3    | LEA (+/-)12000(a3),A3    (min -32768, max 32767)
MOVE.X #0,XXX		| CLR.X XXX        ; #0'ı taşımak aptalca!
CMP.X #0,XXX		| TST.X XXX        ; TST'yi nereye bırakıyorsun?
Bir Ax kaydını sıfırlamak için    | SUB.L A0,A0        ; “LEA 0,a0”dan daha iyidir.
JMP/JSR    XXX        | BRA/BSR XXX        (XXX yakınsa)
MOVE.X #label,AX	| LEA label,AX        (sadece adres kayıtları!)
MOVE.L 0(a0),d0        | MOVE.L (a0),d0    (0 ise ofseti kaldır!!!)
LEA    (A0),A0        | HAHAHAHA! ; Kaldır, etkisi yok!!
LEA    4(A0),A0	| ADDQ.W #4,A0        ; 8'e kadar
addq.l #3,a0        | addq.w #3,a0        ; Yalnızca adres kayıtları, maks. 8
Bcc.W etiket        | Bcc.S etiket ; Beq,Bne,Bsr... dist. <128

2'nin katları ile çarpma ve bölme işlemleri için ASL/ASR'ye dönüştürün
yukarıdaki tabloya bakın.
MULS/MULU'yu başka bir şeye değiştirmek için özel durumlar aşağıda verilmiştir:

NOT: “MULS” söz konusu olduğunda, genellikle “ext.l dx”
eklemek gerekir.

mul*.w #3,dx -> move.l dx,ds
add.l dx,dx
add.l ds,dx
------------------------------------
mul*.w #5,dx -> move.l dx,ds
asl.l #2,dx
add.l ds,dx
------------------------------------
mul*.w #6,dx -> add.l dx,dx
move.l dx,ds
add.l dx,dx
add.l ds,dx
------------------------------------
mul*.w #7,dx -> move.l dx,ds
asl.l #3,dx
sub.l ds,dx
------------------------------------
mul*.w #9,dx -> move.l dx,ds
asl.l #3,dx
add.l ds,dx
------------------------------------
mul*.w #10,dx -> add.l dx,dx
move.l dx,ds
asl.l #2,dx
add.l ds,dx
------------------------------------
mul*.w #12,dx -> asl.l #2,dx
move.l dx,ds
add.l dx,dx
add.l ds,dx
------------------------------------
mulu.w #12,dx -> swap dx    ; HEI! genellikle kelimeyi sıfırlamak gerekir
clr.w dx    ; MULU için yüksek... bunu da dikkate alın
swap dx    ; mulu #3, #5, #6 için....

asl.l #2,dx    ; normal mulu #12
move.l dx,ds
add.l dx,dx
add.l ds,dx
------------------------------------

Kayıtların yüksek kelimesini birçok kez sıfırlamanız gerekiyorsa, şunu da kullanabilirsiniz:

move.l    #$0000FFFF,ds    ; $FFFF'yi tutmak için 1 kayıt gerekir

and.l    ds,dx        ; bu, takaslamadan daha hızlıdır, ancak
; $0000FFFF'yi içeren bir kayıt gerektirir,
; aksi takdirde “AND.L #$FFFF,dx” artık
; hızlı değildir..

Özetle, MULS durumunda, SIGNED olduğu için
başlangıçta bir “EXT.L” komutu çalıştırmanız gerekebileceğini unutmayın. MULU durumunda ise,
 kaydın üst kelimesini sıfırlamanız gerekebilir.

Şimdi “bileşik” değişimlere geçelim:

asl.x #2,dy -> add.x dy,dy
add.x dy,dy
------------------------------------
asl.l #16,dx -> swap dx
clr.w dx
------------------------------------
asl.w #2,dy -> add.w dy,dy
add.w dy,dy
------------------------------------
asl.x #1,dy -> add.x dy,dy
------------------------------------
asr.l #16,dx -> swap dx
ext.l dx
------------------------------------
bsr label -> bra label
rts
------------------------------------
clr.x n(ax,rx) -> move.x ds,n(ax,rx)    ; ds elbette 0 olmalıdır!
------------------------------------
lsl.l #16,dx -> swap dx
clr.w dx
------------------------------------
move.b #-1,(ax) -> st (ax)
------------------------------------
move.b #-1,dest -> st dest
------------------------------------
move.b #x,mn -> move.w #xy,mn
move.b #y,mn+1
------------------------------------
move.x ax,ay -> lea n(ax),ay        ; -32767 <= n <= 32767
add.x #n,ay
------------------------------------
move.x ax,az -> lea n(ax,ay),az        ; az=n+ax+ay, n<=32767
add.x #n,az
add.x ay,az
------------------------------------
sub.x #n,ax -> lea -n(ax),ax        ; -32767 <= n <= -9, 9 <= n <= 32767
------------------------------------

Bu noktada, çeşitli komutların yürütme süresini kontrol edin.
Komutun yürütme süresine, daha önce gördüğümüz
çeşitli adresleme işlemleri için harcanan süre eklenmelidir.
Bunların normal 68000 işlemcisinin yürütme süreleri olduğuna dikkat edin!
Örneğin, 68040 işlemcisinde MULS/MULU donanımla gerçekleştirilir ve
az sayıda döngü alır!

>>>                MOVE.B ve MOVE.W                 <<<

+-------------+---------------------------------------------------------------+
| | HEDEF |
+ KAYNAK +---------------------------------------------------------------+
| | Dn | An |(An)|(An)+|-(An)|(d16,An)|(d8,An,Xn)*|(xxx.W)|(xxx).L|
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| Dn / An | 4 | 4 | 8 | 8 | 8 | 12 | 14 | 12 | 16 |
| (An) | 8 | 8 | 12 | 12 | 12 | 16 | 18 | 16 | 20 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| (An)+ | 8 | 8 | 12 | 12 | 12 | 16 | 18 | 16 | 20 |
| -(An) | 10 | 10 | 14 | 14 | 14 | 18 | 20 | 18 | 22 |
| (d16,An) | 12 | 12 | 16 | 16 | 16 | 20 | 22 | 20 | 24 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| (d8,An,Xn)* | 14 | 14 | 18 | 18 | 18 | 22 | 24 | 22 | 26 |
| (xxx).W | 12 | 12 | 16 | 16 | 16 | 20 | 22 | 20 | 24 |
| (xxx).L | 16 | 16 | 20 | 20 | 20 | 24 | 26 | 24 | 28 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| (d16,PC) | 12 | 12 | 16 | 16 | 16 | 20 | 22 | 20 | 24 |
| (d8,PC,Xn)* | 14 | 14 | 18 | 18 | 18 | 22 | 24 | 22 | 26 |
| #(data) | 8 | 8 | 12 | 12 | 12 | 16 | 18 | 16 | 20 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
* İndeks kaydının büyüklüğü (Xn) (.w veya .l) hızı değiştirmez.


>>>                 MOVE.L             <<<

+-------------+---------------------------------------------------------------+
| | HEDEF |
+ KAYNAK +---------------------------------------------------------------+
| | Dn | An |(An)|(An)+|-(An)|(d16,An)|(d8,An,Xn)*|(xxx.W)|(xxx).L|
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| Dn veya An | 4 | 4 | 12 | 12 | 12 | 16 | 18 | 16 | 20 |
| (An) | 12 | 12 | 20 | 20 | 20 | 24 | 26 | 24 | 28 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| (An)+ | 12 | 12 | 20 | 20 | 20 | 24 | 26 | 24 | 28 |
| -(An) | 14 | 14 | 22 | 22 | 22 | 26 | 28 | 26 | 30 |
| (d16,An) | 16 | 16 | 24 | 24 | 24 | 28 | 30 | 28 | 32 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| (d8,An,Xn)* | 18 | 18 | 26 | 26 | 26 | 30 | 32 | 30 | 34 |
| (xxx).W | 16 | 16 | 24 | 24 | 24 | 28 | 30 | 28 | 32 |
| (xxx).L | 20 | 20 | 28 | 28 | 28 | 22 | 34 | 32 | 36 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
| (d,PC) | 16 | 16 | 24 | 24 | 24 | 28 | 30 | 28 | 32 |
| (d,PC,Xn)* | 18 | 18 | 26 | 26 | 26 | 30 | 32 | 30 | 34 |
| #(veri) | 12 | 12 | 20 | 20 | 20 | 24 | 26 | 24 | 28 |
+-------------+----+----+----+-----+-----+--------+-----------+-------+-------+
* İndeks kaydının boyutu (Xn) (.w veya .l) hızı değiştirmez.

Şimdi diğer komutlara geçelim.
Notlar:

# - Anlık İşlem
An - Adres Kaydı
Dn - Veri Kaydı
ea - Etkili Adres tarafından belirtilen bir işlem
M - Etkili adres
+ - Adresi hesaplamak için harcanan süreyi ekleyin (adresleme)

+-------------+-----------+------------+-----------+-----------+
| Komut | Boyut | op<ea>,An¹ | op<ea>,Dn | op Dn,<M> |
+-------------+-----------+------------+-----------+-----------+
| | Bayt, Kelime | 8+ | 4+ | 8+ |
| ADD/ADDA +-----------+------------+-----------+-----------+
| | Uzun | 6+ | 6+ | 12+ |
+-------------+-----------+------------+-----------+-----------+
| | Bayt, Kelime | - | 4+ | 8+ |
| AND +-----------+------------+-----------+-----------+
| | Uzun | - | 6+ | 12+ |
+-------------+-----------+------------+-----------+-----------+
| | Bayt, Kelime | 6+ | 4+ | - |
| CMP/CMPA +-----------+------------+-----------+-----------+
| | Uzun | 6+ | 6+ | - |
+-------------+-----------+------------+-----------+-----------+
| DIVS | - | - | 158+ | - |
+-------------+-----------+------------+-----------+-----------+
| DIVU | - | - | 140+ | - |
+-------------+-----------+------------+-----------+-----------+
| | Bayt, Kelime | - | 4 | 8+ |
| EOR +-----------+------------+-----------+-----------+
| | Uzun | - | 8 | 12+ |
+-------------+-----------+------------+-----------+-----------+
| MULS/MULU | - | - | 70+ | - |
+-------------+-----------+------------+-----------+-----------+
| | Bayt, Kelime | - | 4+ | 8+ |
| OR +-----------+------------+-----------+-----------+
| | Uzun | - | 6+ | 12+ |
+-------------+-----------+------------+-----------+-----------+
| | Bayt, Kelime | 8+ | 4+ | 8+ |
| SUB +-----------+------------+-----------+-----------+
| | Uzun | 6+ | 6+ | 12+ |
+-------------+-----------+------------+-----------+-----------+

+-------------+-----------+---------+---------+--------+
| Komut | Boyut | op #,Dn | op #,An | op #,M |
+-------------+-----------+---------+---------+--------+
| | Bayt,Kelime | 8 | - | 12+ |
| ADDI +-----------+---------+---------+--------+
| | Uzun | 16 | - | 20+ |
+-------------+-----------+---------+---------+--------+
| | Bayt, Kelime | 4 | 4 | 8+ |
| ADDQ +-----------+---------+---------+--------+
| | Uzun | 8 | 8 | 12+ |
+-------------+-----------+---------+---------+--------+
| | Bayt, Kelime | 8 | - | 12+ |
| ANDI +-----------+---------+---------+--------+
| | Uzun | 14 | - | 20+ |
+-------------+-----------+---------+---------+--------+
| | Bayt, Kelime | 8 | - | 8+ |
| CMPI +-----------+---------+---------+--------+
| | Uzun | 14 | - | 12+ |
+-------------+-----------+---------+---------+--------+
| | Byte,Word | 8 | - | 12+ |
| EORI/SUBI +-----------+---------+---------+--------+
| | Long | 16 | - | 20+ |
+-------------+-----------+---------+---------+--------+
| MOVEQ | Long | 4 | - | - |
+-------------+-----------+---------+---------+--------+
| | Bayt, Kelime | 8 | - | 12+ |
| ORI +-----------+---------+---------+--------+
| | Uzun | 16 | - | 20+ |
+-------------+-----------+---------+---------+--------+
| | Bayt, Kelime | 4 | 8 | 8+ |
| SUBQ +-----------+---------+---------+--------+
| | Uzun | 8 | 8 | 12+ |
+-------------+-----------+---------+---------+--------+

+-------------+-----------+----------+--------+
| Komut | Boyut | Kayıt | Bellek |
+-------------+-----------+----------+--------+
| NBCD | Bayt | 6 | 8+ |
+-------------+-----------+----------+--------+
| | Bayt, Kelime | 4 | 8+ |
| CLR/NEG +-----------+----------+--------+
| NEGX/NOT | Uzun | 6 | 12+ |
+-------------+-----------+----------+--------+
| | Bayt, Yanlış| 4 | 8+ |
| Scc +-----------+----------+--------+
| | Bayt, True | 6 | 8+ |
+-------------+-----------+----------+--------+
| TAS | Bayt | 4 | 14+ |
+-------------+-----------+----------+--------+
| TST | Bayt, Word, Long | 4 | 4+ |
+-------------+-----------+----------+--------+
| LSR/LSL | Byte,Word | 6 + 2n | 8+ |
| ASR/ASL +-----------+----------+--------+
| ROR/ROL | Long | 8 + 2n | - |
| ROXR/ROXL | | | |
+-------------+-----------+----------+--------+
not: n, kaydırma sayısıdır!

Bit İşleme Komut Yürütme Süreleri
+-------------+-----------+-------------------+-------------------+
| | | Dinamik | Statik |
| Komut | Boyut +----------+--------+----------+--------+
| | | Kayıt | Bellek | Kayıt | Bellek |
+-------------+-----------+----------+--------+----------+--------+
| | Bayt | - | 8+ | - | 12+ |
| BCHG/BSET +-----------+----------+--------+----------+--------+
| | Uzun | 8 | - | 12 | - |
+-------------+-----------+----------+--------+----------+--------+
| | Bayt | - | 8+ | - | 12+ |
| BCLR +-----------+----------+--------+----------+--------+
| | Uzun | 10 | - | 14 | - |
+-------------+-----------+----------+--------+----------+--------+
| | Bayt | - | 4+ | - | 8+ |
| BTST +-----------+----------+--------+----------+--------+
| | Uzun | 6 | - | 10 | - |
+-------------+-----------+----------+--------+----------+--------+

+-------------+-------------------+--------+-----------+
| | | Branch | Branch |
| Komut | Yer Değiştirme | Alındı | Alınmadı |
+-------------+-------------------+--------+-----------+
| | Bayt | 10 | 8 |
| Bcc +-------------------+--------+-----------+
| | Word | 10 | 12 |
+-------------+-------------------+--------+-----------+
| | Bayt | 10 | - |
| BRA +-------------------+--------+-----------+
| | Kelime | 10 | - |
+-------------+-------------------+--------+-----------+
| BSR | Bayt,kelime | 18 | - |
+-------------+-------------------+--------+-----------+
| | cc true | - | 12 |
| +-------------------+--------+-----------+
| | cc false, Count | | _ |
| DBcc | Not Expired | 10 | |
| +-------------------+--------+-----------+
| | cc false, Counter | _ | |
| | Expired | | 14 |
+-------------+-------------------+--------+-----------+

+----+----+---+-----+-----+--------+-----------+------+-------+-------+-------+
|Ins.|Sz|(An)|(An)+|-(An)|(d16,An)|(d8,An,Xn)+|(x).W|(x).L|(d16,PC)|(d8,PC,Xn)*
+----+---+----+-----+-----+-------+-----------+-----+-----+--------+----------+
| JMP| - | 8 | - | - | 10 | 14 | 10 | 12 | 10 | 14 |
+----+----+----+-----+----+-------+-----------+-----+-----+--------+----------+
| JSR| - | 16 | - | - | 18 | 22 | 18 | 20 | 18 | 22 |
+----+----+----+-----+----+-------+-----------+-----+-----+--------+----------+
| LEA| - | 4 | - | - | 8 | 12 | 8 | 12 | 8 | 12 |
+----+----+-----+-----+----+------+-----------+-----+-----+--------+----------+
| PEA| - | 12 | - | - | 16 | 20 | 16 | 20 | 16 | 20 |
+-----+----+-----+-----+----+-----+-----------+-----+-----+--------+----------+
| |Word|12+4n|12+4n| _ |16+4n| 18+4n |16+4n|20+4n| 16+4n | 18+4n |
| | | | | | | | | | | |
|MOVEM+----+-----+-----+----+-----+-----------+-----+-----+--------+----------+
|M->R |Long|12+8n|12+8n| _ |16+8n| 18+8n |16+8n|20+8n| 16+8n | 18+8n |
| | | | | | | | | | | |
+-----+----+-----+-----+----+-----+-----------+-----+-----+--------+----------+
| |Word| 8+4n| _ |8+4n|12+4n| 14+4n |12+4n|16+4n| _ | _ |
| | | | | | | | | | | |
|MOVEM+----+-----+-----+----+-----+-----------+-----+-----+--------+----------+
|R->M |Long| 8+8n| _ |8+8n|12+8n| 14+8n |12+8n|16+8n| _ | _ |
| | | | | | | | | | | |
+-----+----+-----+-----+----+-----+-----------+-----+-----+--------+----------+
not: n, taşınacak kayıtların sayısıdır.


EXT/SWAP/NOP    4
EXG        6
UNLK        12
LINK/RTS    16
RTE        20

Son olarak, istisnaların bir kesinti durumunda 44 döngü, bir TRAP durumunda 34 döngü gerektirdiğini unutmayın.
RTE için 20 döngü daha ekleyin!!!
Optimizasyonları DAİMA yorumlayın. Örneğin, bu rutini optimize etmek istediğinizi varsayalım:

movem.l    label1(PC),d1-d4
mulu.w    #16,d1
mulu.w    #3,d2
muls.w    #5,d3
divu.w    #8,d4
rts

Optimize edildiğinde sonuç şöyle olur:

movem.l    label1(PC),d1-d4
asl.l    #4,d1        ; mulu.w #16,d1
move.l    d2,d5        ; \
add.l    d2,d2        ; > mulu.w #3,d2
add.l    d5,d2        ; /
move.l    d3,d5        ; \
asl.l    #2,d3        ; > muls.w #5,d3
add.l    d5,d3        ; /
asr.l	#3,d4        ; divu.w #8,d4
rts

d5 kaydını kullanmanın yanı sıra, listeyi okumayı da zorlaştırdık.
 İlk bakışta, yorumları eklememiş olsaydık,
d1, d2, d3 ve d4 kayıtlarında ne olduğunu anlayabilir miydiniz? Ve MULU'lardan önce yüksek kelimeyi de temizlememiz ve MULS'lardan önce uzatmamız gerektiğini düşünün:
movem.l    label1(PC),d1-d4 swap    d1 clr.w    d1 swap    d1 asl.l    #4,d1

movem.l    label1(PC),d1-d4
swap    d1
clr.w    d1
swap    d1
asl.l    #4,d1
swap    d2
clr.w    d2
swap    d2
move.l    d2,d5
add.l    d2,d2
add.l    d5,d2
ext.l    d3
move.l    d3,d5
asl.l    #2,d3
add.l    d5,d3
asr.l    #3,d4
rts

Veya, yüksek kelimeyi en hızlı şekilde sıfırlayabilirsiniz:

move.l    #$FFFF,d6
...
movem.l    label1(PC),d1-d4
and.l    d6,d1
asl.l    #4,d1
and.l    d6,d2
move.l    d2,d5
add.l    d2,d2
add.l    d5,d2
ext.l    d3
move.l    d3,d5
asl.l    #2,d3
add.l    d5,d3
asr.l    #3,d4
rts

Yazdıktan 1 ay sonra listelemeye geri dönerseniz, 
tüm bu anlaşılmaz talimatların
3 çarpma ve bir bölme işleminden başka bir şey olmadığını anlamak ne kadar sürer? ÇOK ZAMAN ALIR, hatta değişiklik yaparsanız listeyi silip baştan başlamanız gerekir.
Bu son versiyona, önceki listede olduğu gibi, optimizasyonlara yorum eklemenin ne kadar ÖNEMLİ olduğunu anlamanız için yorum eklemedim.
Yani: OPTİMİZASYONLARA HER ZAMAN YORUM EKLEYİN!!!!!!!!!!!!son versiyona yorum eklemedim, çünkü önceki listede olduğu gibi, optimizasyonlara yorum eklemenin
ne kadar ÖNEMLİ olduğunu anlamanızı istedim
.
 Öyleyse: OPTİMİZASYONLARA DAİMA YORUM EKLEYİN!!!!!!!!!!!!

Başka bir örnek: şu 3 komuta bakın:

move.l    a1,a0
add.w    #80,a0
add.l    d0,a0

Aynı şey şu şekilde de yapılabilir:

lea    80(a1,d0.l),a0    ; veya d0.w, d0'un düşük kelimesi yeterliyse.

*****************************************************************************
* İKİNCİ DÜZEY OPTİMİZASYONLAR: “TABELLAMA” -> ÖN HESAPLAMA! *
*****************************************************************************

Şimdi tablolardan bahsedelim, bu konu
Optimizasyonun en önemli konularından biridir ve büyük O ile yazılır, herhangi bir C, BASIC vb. derleyiciden daha hızlı çalışmayı sağlar.
Optimizasyon için kullanılan tablolar,
önceki derslerde gördüğümüz
sprite'ların dalgalanma koordinatlarını veya başka şeyleri içeren tablolara “benzer”dir.
önceki derslerde gördüğümüz tablolara “benzer”. O durumda, nesnelerin alacağı çeşitli konumları “önceden hesapladığımız”
söylenebilir, ancak burada tablo
 sonuçlarını “önceden hesaplamak” için kullanılır, bu nedenle durum biraz farklıdır.
Somut bir örnek verelim.
0 ile 100 arasında bir dizi değeri işleyen bir rutinimiz olduğunu varsayalım
ve bir noktada bir sabit c ile bir çarpma işlemi yapmamız gerekiyor.
 Şimdi, bu rutin birçok kez çalıştırılmak zorunda ise,
bu çarpmaişlem bize oldukça fazla zaman kaybettirecektir.
Bu sorunu nasıl çözebiliriz? 0 ile 100 arasındaki
“aralık” (dizi) değerlerinin tümünü c ile çarpılmış olarak içeren bir tablo oluştururuz, yani
şöyle bir şey:

Tablo:
dc.w    0*c
dc.w    1*c
dc.w	2*c
dc.w    3*c
.
dc.w    n*c
.
dc.w    100*c

Bu noktada tabloya erişmek kolaydır, çünkü d0'da c ile çarpılacak değer verildiğinde, şunu elde ederiz:
Lea    Table,a0    ; Tablonun adresi

Add.w    d0,d0        ;
d0 ile çarpılacak değer, d0 * 2, tablodaki ofseti bulmak için,
; her değeri 1 kelime uzunluğunda olduğu için.
Move.w    (a0,d0.w),d0    ; Doğru değeri tablodan d0'a kopyalar

Kolay, değil mi? Tek dezavantajı, tabloyu içermek için 100 kelime daha uzun bir listeye sahip olmamızdır.
 Eğer bu tablo 256 bayttan daha uzak değilse,
 şöyle yazabiliriz:

Add.w    d0,d0            ; d0*2, her değer 1 kelime, yani 2 bayt
Move.w    Table(pc,d0.w),d0	; tablodan doğru değeri kopyala

Listeleme 68020+ için olsaydı, tek bir komut yeterli olurdu:

Move.w    Table(pc,d0.w*2),d0    ; 68020 veya üstü komut

Ancak bu sonuncusu bir ön bilgi, çünkü 68020 için özel optimizasyonları
daha sonra ele alacağız.
Her neyse, “kısa” tablolar için en çok kullanılan çözüm,
bir rutin aracılığıyla bir BSS bölümünde oluşturmaktır. Bu şekilde,
yürütülebilir dosya daha uzun olmaz, ancak sadece biraz daha fazla
bellek (500Kb uzunluğunda bir tablo oluşturmadığınız sürece, bu durumda
ÇOK daha fazla bellek kaplar, heheheeh!)

Dikkatli olduysanız, önceki derslerde zaten bir
kaç listeyi “tablolaştırmıştık: biri ”MULU.W #40"u kaldırmak için, bu çok sık görülür çünkü
40, düşük çözünürlüklü bir ekran satırının uzunluğudur.
örneği dikkatlice gözden geçirin, bu Lezione8n2.s'de yer almaktadır ve burada hem
optimize edilmiş hem de normal versiyon karşılaştırmalı olarak bulunmaktadır. Önceki listeleri
da gözden geçirerek normal ve optimize edilmiş rutinleri tek başına inceleyin.
Sorun şuydu:

mulu.w    #largschermo,d1        ; Yani mulu.w #40,d1

Bunu “çözmek” için şu hileyi kullanın:

; HER ÇİZİM İÇİN ÇARPMA İŞLEMİ YAPMAMAK İÇİN, EKRAN GENİŞLİĞİ OLAN 40'IN KATLARINI İÇEREN BİR TABLO ÖNCEDEN HESAPLAYALIM.
;

-.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-

lea    MulTab,a0    ; 40'ın katlarını yazmak için 256 kelimelik alan adresi
; ...
moveq    #0,d0        ; 0'dan başlayalım...
move.w    #256-1,d7	; Gerekli 40'ın katlarının sayısı
PreCalcLoop
move.w    d0,(a0)+    ; Mevcut katı kaydedelim
add.w    #LargSchermo,d0    ; larghschermo ekleyelim, bir sonraki kat
dbra    d7,PreCalcLoop    ; Tüm MulTab'ı oluşturalım
....

BÖLÜM	Precalc,bss

MulTab:
ds.w    256    ; bss bölümünün, sıfırlardan oluştuğu ve
; yürütülebilir dosyanın gerçek uzunluğunu uzatmadığına dikkat edin.

-.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-

Tablo hesaplaması bu kadar. Ardından, mulu yerine:

-.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-

lea    MulTab,a1    ; a1'de önceden hesaplanan ekran genişliğinin katları ile tablonun adresi
;
add.w    d1,d1        ; d1*2, tablodaki ofseti bulmak için
add.w    (a1,d1.w),d0    ; doğru katı tablodan d0'a kopyalar

-.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -

Kısaca, bu bir çarpımı tablolama yöntemidir.
Tabii ki burada d1'in sadece 0 ile 255 arasında olabileceğini biliyorduk,
bu nedenle sadece 256 katı önceden hesapladık. Eğer d1
0 ile 65000 arasında bir aralığa sahip olsaydı, 128Kb uzunluğunda bir tablo yapmamız gerekirdi
ve bu da uygun olmayabilirdi!
Tablodaki maksimum sonuç $FFFF, yani 65535'i geçmezse,
.Word değerleriyle bir tablo yapmanız yeterlidir. Bunun yerine, en yüksek değerler
bu değeri aşarsa, tablo longword ile yapılmalıdır. Bu durumda,
ofseti bulma yöntemini değiştirmeliyiz: artık *2 değil, *4!

lea    MulTab,a1    ; Ekran genişliği için önceden hesaplanmış katların bulunduğu tablonun adresi
; önceden hesaplanmış ekran genişliklerinin katları a1
add.w    d1,d1        ; d1*4, tablodaki ofseti bulmak için
add.w    d1,d1        ;
move.l    (a1,d1.w),d0    ; doğru katı tab'dan d0'a kopyalar


Bölünmelerin tablolaması ile ilgili olarak, işlem benzerdir,
her döngüyü artan bir sayıya bölen bir döngü içeren bir rutin oluşturmak
ve sonuçları tabloya kaydetmek yeterlidir. Bu durumda
sadece düşük kelimeyi sonuçla birlikte kaydetmeyi veya
yüksek kelimeyi de geri kalanla birlikte kaydetmeyi seçebilirsiniz, eğer amacınıza uygunsa.

Önemli bir nokta, “yerinde” tablo oluşturmaktır, ASLA
TABLO EKLEYİN, ÖZELLİKLE DE KB'LERCE UZUN VE ZATEN HESAPLANMIŞSA.
Örneğin, 20 KB'lik bir multab önceden hesaplarsak, bunu başlangıçta hesaplayan bir yürütülebilir dosya ile
incbin veya include ile önceden hesaplanmış olarak dahil eden bir dosya arasındaki farkı düşünün: (örnek)
->

file1	->    uzunluk = 40K        ; başlangıçta tabloyu hesaplar
file1    ->    uzunluk = 60K        ; incbin ile tablo dahil edilmiştir

Bellek tüketimi açısından eşitler, ancak
40K'lık bir intro veya 64K'lık bir intro yapmanız gerekirse, başlangıçta 1 veya 2 saniyelik ön hesaplama pahasına ne kadar büyük bir alan tasarrufu sağlayacağınızı düşünün.
Ancak bir oyun veya program yapmış olsanız bile, 20k (veya daha fazla) daha pahalı olması, diske daha fazla şey eklemenize ve bbs'lerde daha fazla yayılmanıza olanak tanır.
Ancak bir oyun veya program yapmış olsanız bile, 20k (veya daha fazla) daha pahalı olması,
 diske daha fazla şey eklemenizi ve
kısa olması nedeniyle bbs'lerde daha fazla yayılmasını sağlar.
Ayrıca, tabloları yerinde önceden hesaplamanın bir avantajı daha vardır:
listeyi kolayca değiştirebilirsiniz, örneğin 40 yerine 80 ile çarpmak isterseniz.
INCBIN ile 40'ın katları tablosunu ekleyen FESSO, 80 ile çarpma rutinini yeniden yazmalı,
 dosyayı kaydetmeli, FURBO ise listede oluşturma rutini olan
yürütmeli, ikili dosyayı kaydetmeli, oysa listede oluşturma rutinine sahip olan Kurnaz,
 sadece 40'ı 80 ile değiştirmeli ve her şeyi kendisi yapmalıdır.
Son olarak, özellikle karmaşık rutin ön hesaplamalar için, tabloyu oluşturan orijinal rutini göz önünde bulundurursanız
işleyiş çok daha net anlaşılır. Bu nedenle, HER ZAMAN “YERİNDE” ÖN HESAPLAMA YAPIN
"
SIFIRLANMIŞ ALANLARA, ÖZELLİKLE BÜYÜK TABLOLARSA BSS BÖLÜMÜNE.

Size verebileceğim tavsiye, her zaman HER ŞEYİ tablolamaya çalışmanızdır.

Çok dikkatli olduysanız, ders 11'de bir
listelemenin, şimdi gördüğümüzden çok daha riskli bir tablolama optimizasyonuna
uğradığını da hatırlayacaksınız. Aslında, tek bir çarpma yerine tüm rutin tablolamaya tabi tutulmuştur.
Bunu ders 8'e değil, ders 11'e koymamın bir nedeni var!
“Normal” listeleme Lezione11l5.s, “tablolaştırılmış” olan ise Ders 11l5b.s
Güçlü optimizasyonun nasıl gerçekleştiğini tekrar gözden geçirin.

Bu “normal” rutin:

-.-    -.-    -.-    -.-    -.-	-.-    -.-    -.-    -.-    -.-

Animloop:
moveq    #0,d0
move.b    (A0)+,d0    ; d0'daki sonraki bayt
MOVEQ    #8-1,D1        ; Kontrol edilecek ve genişletilecek 8 bit.
BYTELOOP:
BTST.l    D1,d0		; Mevcut döngünün bitini kontrol et
BEQ.S    bitclear    ; sıfırlanmış mı?
ST.B    (A1)+        ; Değilse, baytı (=$FF) ayarla
BRA.S    bitset
bitclear:
clr.B	(A1)+        ; Sıfırlanmışsa, baytı sıfırla
bitset:
DBRA    D1,BYTELOOP    ; Baytın tüm bitlerini kontrol et ve genişlet
DBRA    D7,Animloop    ; Tüm kareyi dönüştür

-.-    -.-    -.-	-.-    -.-    -.-    -.-    -.-    -.-    -.-

Tek yapılan, tüm olasılıkları önceden hesaplamaktır:

-.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-

****************************************************************************
; Olası 8 bit ile eşleşen tüm olası 8 baytları önceden hesaplayan rutin
; 8 bit. Tüm demek $FF, yani 255 anlamına gelir.
****************************************************************************

PrecalcoTabba:
lea    Precalctabba,a1    ; Hedef
moveq    #0,d0        ; Sıfır değerinden başla
FaiTabba:
MOVEQ    #8-1,D1        ; Kontrol edilecek ve genişletilecek 8 bit.
BYTELOOP:
BTST.l    D1,d0        ; Mevcut döngünün bitini kontrol et
BEQ.S    bitclear    ; sıfırlanmış mı?
ST.B    (A1)+        ; Değilse, baytı (=$FF) ayarla
BRA.S    bitset
bitclear:
clr.B    (A1)+        ; Sıfırlanmışsa, baytı sıfırla
bitset:
DBRA    D1,BYTELOOP    ; Baytın tüm bitlerini kontrol et ve genişlet:
; D1 her seferinde btst'yi
; tüm bitler için yapar.
ADDQ.W    #1,D0        ; Sonraki değer
CMP.W    #256,d0        ; Hepsini yaptık mı? (maks. $FF)
bne.s    FaiTabba
rts

-.-    -.-    -.-    -.-    -.-    -.-    -.-	-.-    -.-    -.-

Ve “yürütme” rutinini değiştirin:

-.-    -.-    -.-    -.-    -.-    -.-    -.-	-.-    -.-    -.-

Animloop:
moveq    #0,d0
move.b    (A0)+,d0    ; d0'daki bir sonraki bayt
lsl.w    #3,d0        ; d0*8, tablodaki değeri bulmak için
; (yani başlangıcından itibaren ofset)
lea    Precalctabba,a2
lea    0(a2,d0.w),a2    ; A2'de, 8 bitlik “genişletme” için doğru 8 baytlık tablodaki adres
; .
move.l    (a2)+,(a1)+	; 4 bayt genişletilmiş
move.l    (a2),(a1)+    ; 4 bayt genişletilmiş (toplam 8 bayt!!)

DBRA    D7,Animloop    ; Tüm kareyi dönüştür

-.-	-.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-    -.-

Gördüğünüz gibi, burada belirli bir deneyim ve sezgi gerektiren bir tür optimizasyona giriyoruz
.
Mekanik olarak söylemesi kolay: "Tüm çarpımları
ve bölmeleri tablolaştırmaya çalışacağım ve tüm olası addq ve moveq'leri koyacağım“
.
 Ancak, daha önce gördüğümüz gibi ”garip" rutinlerle karşılaştığımızda,
 bir baytı btst yapıp 8 bayta genişleten,
optimize etmek için keskin bir göz
Bu keskin göz, 10 noktayı döndürürken takılan bir 3d rutini ile
50 saniyede 8192 noktayı döndüren bir rutin arasındaki farkı yaratır.
Ve elbette, tüm olası rutinleri ve bunların yanında tüm olası optimizasyonları içeren bir liste yapmak mümkün değildir.
Sunulan birkaç örneği inceleyerek keskin bir göz geliştirmek gerekir.

*********************
*********************************************************
*        ÇEŞİTLİ OPTİMİZASYONLAR - KARIŞIK GRUP             *
******************************************************************************

Her
d0 değerinde belirli bir rutin gerçekleştirmemiz gerektiğini ve ayrıca bu olası değerlerin
0 ile 10 arasında olduğunu varsayalım. Bu durumda, şöyle bir şey yapmak cazip gelebilir:

Cmp.b    #1,d0
Beq.s    Rout1
Cmpi.b    #2,d0
Beq.s    Rout2
...
Cmp.b    #10,d0
Beq.s    Rout10

Bu çok kötü bir fikir, en azından şöyle yapabilirdik:

Subq.b    #1,d0    ; 1'i çıkaralım. Eğer d0=0 ise, Z bayrağı ayarlanır
Beq.s    Rout1    ; Sonuç olarak d0 1 idi ve Rout1'e atlıyoruz
Subq.b    #1,d0    ; vb...
Beq.s    Rout2
...
Subq.b    #1,d0
Beq.s    Rout10

Aslında bu şekilde daha iyi, ama biz mükemmeliyetçiyiz ve
bir tablonun yardımıyla şöyle yapıyoruz:

Add.w    d0,d0         ;\ d0*4, tablodaki ofseti bulmak için,
Add.w    d0,d0		 ;/ uzun kelimelerden (4 bayt!) oluşur
Move.l    Table(pc,d0.w),a0 ; A0'da doğru rutinin adresi
Jmp    (a0)

Table:
dc.l    Rout1    ; 0 (rutini çağırmak için d0'daki değer)
dc.l    Rout2    ; 1
dc.l    Rout3	; 2
dc.l    Rout4    ; 3
dc.l    Rout5    ; 4
dc.l    Rout6    ; 5
dc.l    Rout7    ; 6
dc.l    Rout8    ; 7
dc.l    Rout9    ; 8
dc.l    Rout10    ; 9

Bu şekilde karşılaştırma yapmıyoruz ve karşılaştırılacak değerleri biliyorsak ve bunlar ardışık ise
bu teknik çok iyi bir teknik olduğu açıktır.
Ayrıca, tabloları yoğun bir şekilde kullanırsak
yoğun olarak kullanırsak, ikinin kuvvetleriyle çalışabilir ve böylece
iki Add.w'den tasarruf edebiliriz. Dolayısıyla, rutin 1'i istediğimizde d0=0,
Rout2'yi istediğimizde d0=4, Rout3'ü istediğimizde d0=8 vb. gerekir.

Bu sistemin bazı varyasyonları da vardır, örneğin:

move.b	Table(pc,d0.w),d0    ; Tablodan doğru ofseti al
jmp    Table(pc,d0)        ; Table'a ekle ve atla!

Table:    
dc.b    Rout1-Table    ; 0
dc.b    Rout2-Table    ; 1
dc.b    Rout3-Table    ; 2
...
even

Bu sistemde d0'ı çarpmamız gerekmez, çünkü
rutinlerin ofset tablosunu tablonun kendisinden oluşturduk.
Burada ofsetler .byte'dir, çünkü rutinlerin küçük ve
yakın olduğu varsayılır. Aksi takdirde ofsetler .word olabilir:

add.w    d0,d0			; d0*2
move.w    Table(pc,d0.w),d0    ; Tablodan doğru ofseti al
jmp    Table(pc,d0)        ; Table'a ekle ve atla!

Table:
dc.w    Rout1-Table    ; 0
dc.w    Rout2-Table	; 1
dc.w    Rout3-Table    ; 2
...

Bu sistemin avantajı, d0
kayıt defterini 4 ile çarpmaya gerek olmaması, sadece 2 ile çarpmak yeterlidir.
Tabloyu yeterince yakına yerleştiremezseniz, şöyle yapabilirsiniz:

add.w    d0,d0            ; d0*2
lea    Table(pc),a0
move.w    (a0,d0.w),d0
jmp    (a0,d0.w)

Table:    
dc.w    Rout1-Table    ; 0
dc.w    Rout2-Table    ; 1
dc.w    Rout3-Table    ; 2
...

Subq.b #1,d0
'u BEQ'den sonra, CMP veya TST olmadan kullanarak rutine atlamayı uyguladığımıza göre, Condition Codes (68000-2.txt'de iyice gözden geçirin) ile ilgili bu özelliğin kullanımlarını ele alalım.
Biz assembler programcıları, üç koşulu aynı anda test etme lüksüne sahibiz. Örneği ele alalım: Add.w    #x,d0        ; cc'ler bir şekilde ayarlanmıştır Beq.
Assembly programcıları olarak, aynı anda üç
koşulu test etme lüksüne sahibiz. Örneğin:

Add.w    #x,d0        ; cc'ler bir şekilde ayarlanmıştır
Beq.s    Zero        ; sonuç sıfırdır
Blt.s    Negativo    ; sonuç sıfırdan küçüktür
...			; Aksi takdirde sonuç pozitiftir...

Dolayısıyla, bir sonucu test etmeniz gerekiyorsa, bunu her zaman
son matematik işleminden sonra yapmaya çalışın, cc'lerin tamamen farklı bir şey gösterdiğinde
başka bir şey gösterdiği zaman değil. Çeşitli komutları etkileyen cc'leri bilmeniz iyi olur.
Ayrıca, Bcc'leri ilk olarak
yürütülme olasılıklarına göre yerleştirmenizi tavsiye ederim, yani pratik olarak kontrolü
en yüksek olasılıkla aktaranları.
Örneğin, başka bir ilginç durum şudur:
 belirli sayıda
değerimiz var, kaç tane olduğunu bilmiyoruz, ancak sıfırla bittiğini biliyoruz...
Bunları bir bellek alanından başka bir bellek alanına kopyalamamız gerektiğini varsayalım.
Şöyle bir şey yapabiliriz:

Lea    Source,a0
Lea    Dest,a1
CpLoop:
Move.b    (a0)+,d0    ; kaynak -> d0
Move.b    d0,(a1)+    ; d0 -> hedef
Tst.b    d0        ; d0=0?
Bne.s    CpLoop        ; Henüz değilse, devam et

Ancak aşağıdaki şekilde daha iyisini yapabiliriz:

Lea    Source,a0
Lea    Dest,a1
CpLoop:
Move.b    (a0)+,(a1)+    ; kaynak -> hedef
Bne.s    CpLoop        ; bayrak 0 ayarlandı mı? Henüz değilse, devam et!

Gördüğünüz gibi, bu durumda 68000 her şeyi kendi başına yapıyor.

Şimdi alt rutin çağrıları ve dolayısıyla Movem'lerden bahsedelim.
Alt rutinlerin kullanımı, program yazarken çok yararlıdır,
 ancak kodunuzu optimize ederken, BSR label/RTS komut çiftini kullanmak yerine
BRA label kullanabileceğinizi
ve souvrutinin sonunda başka bir
BRA ile devam ederek JMP label komutundan hemen sonraki komuta geri dönmek mümkündür, ancak
bu optimizasyon sizin takdirinize kalmıştır.
Her halükarda, mümkünse JSR yerine BSR ve benzer şekilde JMP yerine BRA
kullanın.
Rutinlerin kullanımına geri dönersek, sık sık kayıtların içeriğini sıfırlamak zorunda kalırız
kayıtların içeriğini sıfırlamak zorunda kalırız,
ancak her seferinde bir dizi “Moveq #0,Dx” ve
“Sub.l Ax,Ax” komutundan kurtulabiliriz, aslında bu işlemi ana programın başında yapıyoruz
ve alt rutinlerimizi çağırdığımızda ne olduğunu görelim,
örnek:

Moveq    #0,d0    ;
Moveq    #0,d1
...
Moveq    #0,d7
Move.l    d0,a0
..
Move.l    d0,a6
Main:
Bsr.s    Pippo
Bsr.s    Pluto
Bsr.s    Paperino
...
Bra.s    Main

Peki, her çağrıda kullanılan kayıtların içeriğini kaydedersek,
 bir rutin bittiğinde bir sonrakine
“temiz” kayıtlarla geçilecektir, ancak yine de
kendi kodunuzu iyi organize etmeniz gerektiği açıktır. Aksi takdirde, tek bir komutla
tüm kayıtları temizleyebilirsiniz, yani:

movem.l    TantiZeri(PC),d0-d7/a0-a6

TantiZeri:
dcb.b    15,0

ŞimdiMovem komutuna gelelim ve avantajlarını ve dezavantajlarını inceleyelim.
Öncelikle Movem'in makine döngü sayısına bakalım, özellikle
longword aktarımlarında: kayıtlardan belleğe aktarımlarda
8+8n kullanır, burada n kayıt sayısını gösterir, ayrıca
basit bir Move.l Dx,(Ax) komutunun kullandığı döngü sayısına da bakalım: 12 döngü.
 
Sıradan bir mühendis şu soruyu sorabilir:
Tüm kayıtlarda bulunan birden fazla uzun kelimeyi aktarmam gerekiyorsa,
klasik Move.l Dx,(Ax) komutunu ne kadar kullanmam gerekir?
Bu durumda da mühendis doğru bir gözlemde bulunmuştur.
D0..D7 ve A0 kayıtlarının içeriğini aktarmamız gereken bir sınır durumu ele alalım.
.A6: tam olarak 8+7=15 Move.l
ihtiyacımız olacaktır, toplamda 15*12=180 döngü.
Bunun yerine, Movem kullanırsak, 8+8*15=128 döngüye, yani 52 döngü
tasarruf ederiz!
Bu noktada, büyük miktarda veri aktarılması gerektiğinde devasa Movem'in kullanılması gerektiği açıktır,
 ancak sadece iki kayıt söz konusu olduğunda
normal Move.l yine kullanılabilir.
Şimdi, optimize edilmemiş bir koddan başlayarak optimize edilmiş bir koda ulaşan bir dizi pratik uygulamaya bakalım
kodundan başlayıp optimize edilmiş bir koda kadar uzanan bir dizi pratik uygulamaya bakalım.
Örneğin, Table konumundan 1200 baytı sıfırlamamız gerektiğini varsayalım
; yeni başlayanlar bunu şu şekilde yaparlardı:

Lea    Table,a0    ; 12 döngü
Move.w    #1200-1,d7    ; 8 döngü
CleaLoop:
Clr.b    (a0)+        ; 8 döngü
Dbne    d7,CleaLoop

Bu tür kodlar korkunç! Ne kadar sürdüğüne bir bakalım... ilk
iki komut 20 döngü sürerken, Clr.b
1200 kez çalıştırılmalıdır, yani 1200*8=9600 döngü, ayrıca Dbne
komutunun 10*1199=11990 döngü ve sonunda 14 döngü daha çalıştırılması gerekir, yani
Özetle 20+9600+11990+14=21624 döngü!!! Peki, tüm bunlar yorum yapmaya bile değmez.
 En azından şöyle bir şey yapabilirdik:

Lea    Table,a0
Move.w	#(1200/4)-1,d7    ; clr.L için 4'e bölünmüş bayt sayısı!
Clr:
Clr.l    (a0)+        ; 4 baytı bir seferde sıfırlıyoruz...
Dbra    d7,Clr        ; ve 1/4 döngü yapıyoruz.

Aslında, bir Clr.l ile en azından bir seferde 4 baytı sileriz ve
1200 bayt silmemiz gerektiğinden, 1200/4=300 döngü yaparız, böylece öncekine göre epey tasarruf ederiz
(hesaplamayı lütfen kendiniz yapın).
Daha da optimize etmek için şunu yapabiliriz:

Lea	Table,a0
Move.w	#(1200/16)-1,d7    ; clr.L için 16'ya bölünmüş bayt sayısı!!
Clr:
Clr.l    (a0)+        ; 4 baytı sıfırlarız
Clr.l    (a0)+        ; 4 baytı sıfırlarız
Clr.l    (a0)+        ; 4 baytı sıfırlarız
Clr.l    (a0)+        ; 4 baytı sıfırlayalım
Dbra    d7,Clr        ; ve 1/16 döngü yapalım.

Ancak bu tür kodlar da kötü olarak sınıflandırılabilir,
bir veri kaydı kullanarak daha fazla optimize etmeye çalışalım:

Lea    Table,a0
moveq    #0,d0        ; “CLR”den daha hızlı “move.l d0”!
Move.w    #(1200/32)-1,d7    ; bayt sayısı 32'ye bölünür
Clr:
move.l    d0,(a0)+		; 4 baytı sıfırlayalım
move.l    d0,(a0)+
move.l    d0,(a0)+
move.l    d0,(a0)+
move.l    d0,(a0)+
move.l    d0,(a0)+
move.l    d0,(a0)+
move.l    d0,(a0)+
Dbra	d7,Clr        ; ve 1/32 döngü yapalım.

Bu sürümde,
dbra sayısının azalmasıyla optimizasyonu artırdık ve kayıtları kullanmanın
“CLR”den bile daha hızlı olduğunu

Şimdi Movem'i kullanarak ne olduğunu görelim:

movem.l    TantiZeri(PC),d0-d6/a0-a6    ; tüm kayıtları sıfırlıyoruz
; tabii ki d7 ve a7 hariç,
; bunlar yığın. Bunları
; bu şekilde veya
; birçok moveq #0,Dx...

; Şimdi 7+7=14 sıfırlanmış kayıt var, toplamda 14*4=56 bayt.
; 1200 bayt/56byte = 21 transfer yapmalıyız, ancak 21*56 = 1176 bayt ve
; 1200-1176 = 24 bayt daha kalıyor, bunları ayrı olarak yapacağız.

Move.l    a7,SalvaStack    ; Yığını bir etikete kaydediyoruz
Lea    Table+1200,a7    ; A7'ye (veya SP, aynı kayıttır)
; temizlenecek alanın son adresini koyalım.
Moveq    #21-1,d7    ; Yapılacak movem sayısı (2100/56=21)
CleaLoop:
Movem.l    d0-d6/a0-a6,-(a7) ; 56 baytı “geriye doğru” sıfırlayalım.
; Hatırlayacağınız gibi, yazma movem
; yığın için “geriye doğru” çalışır.
Dbra    d7,CleaLoop
Movem.l    d0-d5,(a7)+     ; Üstteki 24 baytı sıfırlayalım
Move.l    SalvaStack(PC),a7 ; Yığını SP'ye geri koyalım
rts

SalvaStack:
dc.l    0

Biraz hesap yapalım, iç Movem tam olarak 8+8*14=120
döngü kaplayacak, 21 kez çalıştırılması gerekecek, yani 21*120=2520 döngü, buna
tüm başlatma ve kapatma aşamalarını da eklememiz gerekecek, ancak
endişelenmeyin, asla yukarıdaki örnekleri geçmeyecektir. Kodu genişleterek daha da
mükemmeliyetçi olabiliriz, yani döngüleri kaldırıp 
ihtiyacımız olan kadar Movem yerleştirebiliriz; korkmayın,
kod genişletme çok kullanılan bir tekniktir, özellikle
ne optimize edileceğini bilmediğimiz durumlarda, daha sonra bir dizi örnek göreceğiz.
İlk durumda ise şunlar olur:

Move.l    a7,SalvaStack    ; Yığını bir etikete kaydediyoruz
Lea    Table+1200,a7    ; A7'ye (veya SP'ye, aynı kayıttır)
; temizlenecek alanın son adresi.
CleaLoop:

rept    20         ; 20 movem'i tekrarla...
Movem.l    d0-d7/a0-a6,-(a7) ; 60 baytı “geriye doğru” sıfırlayalım.
endr

Move.l	SalvaStack(PC),a7 ; Yığını SP'ye geri koyalım
rts

dbra'yı sildiğimiz için, d7 kaydını da kullanabileceğimizi unutmayın.
Bu sayede her movem için 4 bayt daha sıfırlayabiliriz. Böylece 1200/60
tam olarak 20 eder. Demolar genellikle bu sistemi kullanır, en hızlısı budur!

Kod genişletme tekniğini daha yakından inceleyelim. Şu rutini inceleyin:

ROUTINE2:
MOVEQ    #64-1,D0    ; 64 döngü
SLOWLOOP2:
MOVE.W    (a2),(a1)
ADDQ.w    #4,a1
ADDQ.w    #8,a2
DBRA    D0,SLOWLOOP2

Ve işte çok hızlandırılmış rutin:

ROUTINE2:
MOVE.W    (a2),(a1)
MOVE.W    8(a2),4(a1)
MOVE.W	8*2(a2),4*2(a1)
MOVE.W	8*3(a2),4*3(a1)
MOVE.W	8*4(a2),4*4(a1)
MOVE.W	8*5(a2),4*5(a1)
MOVE.W	8*6(a2),4*6(a1)
MOVE.W	8*7(a2),4*7(a1)
.....
MOVE.W	8*63(a2),4*63(a1)

DBRA ve 2 addq için kullanılan zamanı çıkardık!
Ancak, 68020 ve üstü işlemcilerde
256 bayt'tan kısa döngüleri hızlandıran komut önbelleği bulunduğunu belirtmek gerekir.
Bu nedenle, 68000 için optimizasyon yaparken
68020'de hız düşüşü yaşanabilir. Sonuç olarak, aşağıdaki gibi bir ortalama almak iyi olacaktır:

ROUTINE2:
MOVEQ    #4-1,D0        ; sadece 4 döngü (64/16)
FASTLOOP2:
MOVE.W    (a2),(a1)        ; 1
MOVE.W    8(a2),4(a1)        ; 2
MOVE.W	8*2(a2),4*2(a1)        ; 3
MOVE.W    8*3(a2),4*3(a1)        ; 4
MOVE.W    8*4(a2),4*4(a1)        ; 5
MOVE.W    8*5(a2),4*5(a1)        ; ...
MOVE.W	8*6(a2),4*6(a1)
MOVE.W	8*7(a2),4*7(a1)
MOVE.W	8*8(a2),4*8(a1)
MOVE.W	9*9(a2),4*9(a1)
MOVE.W	8*10(a2),4*10(a1)
MOVE.W	8*11(a2),4*11(a1)
MOVE.W	8*12(a2),4*12(a1)
MOVE.W	8*13(a2),4*13(a1)
MOVE.W    8*14(a2),4*14(a1)
MOVE.W    8*15(a2),4*15(a1)    ; 16
ADD.w    #4*16,a1
ADD.w    #8*16,a2
DBRA    D0,FASTLOOP2

Bu, movem ve diğer rutinlerdeki temizleme için de geçerlidir.
tappeto.

Şimdi birkaç yararlı gözlem yapalım:
otomatik artışlı dolaylı adresleme yöntemi her zaman
dikkate alınması gereken bir şeydir. Aslında dolaylı adresleme, artışlı
olsa da olmasa da, aynı sayıda döngü kullanır; bunun en iyi örneği
Blitter'ın kullanımıdır ve bunun bir örneğini
daha sonra göreceğiz.
1200 baytı kopyalamak için kullandığımız ikinci yöntem ise
tamamen çöpe atılacak bir yöntem değildir: bir kopya yapmamız gerektiğinde
çok daha iyisini yapabiliriz,
 ancak 1200 baytı maskelememiz gerektiğini düşünün: Dbcc döngüsünü kullanmak zorundayız.
Bu gibi durumlarda Dbcc komutunu mümkün olduğunca kullanın ve
680xx cache'li işlemcilerde bu tür döngülerin TURBO hızında çalıştırıldığını unutmayın.
Ayrıca DBcc komutları karşılaştırma için de mükemmeldir, işte bir örnek:

Move.w    Len(PC),d0    ; Arama yapılacak maksimum uzunluk <> 0
Move.l    String(PC),a0    
Moveq    #Char,d1    ; Aranacak karakter
FdLoop:
Cmp.b    (a0)+,d1
Dbne.s    d0,FdLoop

Aşağıdaki döngü iki şeyi aynı anda kontrol eder, aslında cc EQ,
 tüm Len (karakter sayısı) incelenmişse veya
karakter bulunmuşsa ayarlanır, bu durumda karakterin
bulunduğu konumu da söyleyebiliriz.
Şimdi Movem ile ilgili son örnekleri ve tam olarak
bellek alanlarının kopyalanmasını ele almak istiyorum: sıfırlamadan farklı olarak, burada
verileri alıp sonra boşaltmamız gerekiyor, ancak hemen bir örneğe bakalım:

Lea    Start,a0
Lea    Dest,a1
FASTCOPY:                ; 13 kayıt kullanılır
Movem.l    (a0)+,d0-d7/a2-a6
Movem.l    d0-d7/a2-a6,(a1)
Movem.l    (a0)+,d0-d7/a2-a6
Movem.l    d0-d7/a2-a6,$34(a1)    ; $34
Movem.l    (a0)+,d0-d7/a2-a6
Movem.l    d0-d7/a2-a6,$34*2(a1)    ; $34*2
Movem.l    (a0)+,d0-d7/a2-a6
Movem.l    d0-d7/a2-a6,$34*3(a1)
Movem.l    (a0)+,d0-d7/a2-a6
Movem.l    d0-d7/a2-a6,$34*4(a1)
Movem.l	(a0)+,d0-d7/a2-a6
Movem.l	d0-d7/a2-a6,$34*5(a1)
Movem.l	(a0)+,d0-d7/a2-a6
Movem.l	d0-d7/a2-a6,$34*6(a1)
Movem.l    (a0)+,d0-d7/a2-a6

Öncelikle burada (eğer böyle adlandırılabilirse)
kod genişletme tekniğini kullandık: abartılı görünebilir, ancak çok etkilidir.
Peki, ne yaptık? a0 adresindeki bellek konumundan 13*4 bayt alıyoruz
ve bunları a1 adresindeki bellek konumuna kopyalıyoruz, 
her kopyalama işleminden sonra a1'in ofsetini artırmaya dikkat ediyoruz.
 Kodu genişletmek istiyorsanız, ancak tüm bu komutları görmek sizi rahatsız ediyorsa, rept komutunu kullanabilirsiniz: REPT        100 And.l        (a0)+,(a1)+     ENDR
, rept yönergesini kullanabilirsiniz:

REPT        100
And.l        (a0)+,(a1)+
ENDR

Bunlar sizin için derleyici tarafından oluşturulacaktır. Son olarak, renk kayıtlarıyla ilgili bir örnek görelim
:

Lea    $dff180,a6
Movem.l    Colours(pc),d0-a5    ; 14 uzun kelime veya 28 kelime yükleyin
Movem.l    d0-a5,(a6)        ; tek seferde 28 renk ayarlayın!

Colours:    dc.w    ...


Ya da bir rutinin başında birçok kayıt yüklemeniz gerektiğinde:


MOVE.L    #$4232,D0
MOVE.W    #$F20,D1
MOVE.W    #$7FFF,D2
MOVEQ    #0,D3
MOVE.L    #123456,D4
LEA    $DFF000,A0
LEA    $BFE001,A1
LEA    $BFD100,A2
LEA    Ekran,A3
LEA    BUFFER,A4
...

Tüm bunlar tek bir rutinle özetlenebilir:


MOVEM.L    VariaRoba(PC),D0-D4/A0-A4
...

VariaRoba:
dc.l    $4243        ; d0
dc.l    $f20        ; d1
dc.l    $7fff        ; d2
dc.l    0        ; d3
dc.l    $123456        ; d4
dc.l    $dff000        ; a0
dc.l    $bfe001        ; a1
dc.l    $bfd100        ; a2
dc.l    Ekran        ; a3
dc.l    Tampon        ; a4

Movem komutuyla birçok başka örnek verebiliriz, ancak
bazı durumlarda bunun yararını anladığınızı düşünüyorum.

Program Sayacı (PC) ile ilgili çağrılar,
normal etiketlere göre daha hızlıdır çünkü daha “küçüktürler”. Aslında normal çağrılar
etiketlerin 32 bit uzunluğundaki adresini içermelidir, oysa (PC)
çağrıları sadece PC kaydından 16 bitlik ofseti içerir, bu da 2
bayt ve zaman tasarrufu sağlar. Ne yazık ki, ofsetin 16
bit olması, 32k
ileri veya geriye doğru PC etiketlerine göre göreceli hale getirilmesini engeller.
Şimdi, tüm programı (PC) ile ilişkili hale getirmek için bir püf noktasına gelelim.
Bu, yürütmeyi de hızlandırır. Bildiğiniz gibi, şunu yapabilirsiniz:

move.l    label1(PC),d0

Ancak bu komutu PC ile ilişkili hale getirmek imkansızdır:

move.l    d0,label1


Nasıl yapabiliriz? Bu çok önemli bir sorun değil, ancak
bu komutu birçok kez çalıştıran bir döngü olduğunu varsayalım.
Etiketi PC'ye göre göreceli hale getiremezsek, onu
ortak bir adres kaydına göre göreceli hale getirebiliriz!
En açık yöntem şudur:

move.x    XXXX,label    ->    lea    label(PC),a0
move.x XXXX,(a0)

tst.x    label        ->    lea    label(PC),a0
tst.x    label

Dikkat edin, #anlık değerleri veri kayıtlarına yüklenen değerlerle değiştirmek de zaman kazandırır, tabii değerler -80 ile +7f
arasında ise
 
move.l    #xx,dest    ->    moveq    #xx,d0
move.l    d0,dest


ori.l    #xx,dest    ->    moveq    #xx,d0
or.l    d0,dest


addi.l    #xx,dest    ->    moveq    #xx,d0
add.l    d0,dest

Özellikle, bir döngüden önce tüm kayıtları yüklemek mümkünse
ve böylece yükleme işleminden tasarruf etmek mümkünse, “MOVE.L #xx,Dx”
komutunu rahatlıkla kullanabilirsiniz, #immediati içermeyen döngü bize bunun karşılığını verecektir!

Örnek:

RoutineSchifosa:
move.w    #1024-1,d7        ; döngü sayısı
LoopSquallido:
add.l    #$567,label2
sub.l    #$23,label3
move.l    label2(PC),(a0)+
move.l    label3(PC),(a0)+
add.l    #30,(a0)+
sub.l    #20,(a0)+
dbra    d7,LoopSquallido
rts

Bu şekilde optimize edilebilir:

RoutineDecente:
moveq    #30,d0        ; gerekli kayıtları yükleyelim...
moveq    #20,d1
move.l    #$567,d2
moveq    #$23,d3
lea    label2(PC),a1
lea    label3(PC),a2
move.w    #1024-1,d7        ; döngü sayısı
LoopNormale:
add.l    d2,(a1)
sub.l    d3,(a2)
move.l    (a1),(a0)+
move.l    (a2),(a0)+
add.l    d0,(a0)+
sub.l    d1,(a0)+
dbra    d7,LoopNormale
rts

Abartmak için, son olarak yürütülecek dbra sayısından tasarruf edebiliriz:

RoutineOK:
moveq    #30,d0
moveq    #20,d1
move.l    #$567,d2
moveq    #$23,d3
lea    label2(PC),a1
lea    label3(PC),a2
move.w    #(1024/8)-1,d7        ; döngü sayısı = 128
LoopOK:

rept    8        ; parçayı 8 kez kopyalayın...

add.l    d2,(a1)
sub.l    d3,(a2)
move.l    (a1),(a0)+
move.l    (a2),(a0)+
add.l    d0,(a0)+
sub.l    d1,(a0)+

endr

dbra    d7,LoopNormale
rts

Her neyse, her şeyi hızlı bir şekilde PC ile ilgili hale getirmek için bir sistem var.
Örneğin a5 gibi belirlenmiş bir adres kaydına, programın başlangıç adresini
veya programımızda bilinen bir adresi koyarsak,
 söz konusu etiketi bulmak için etiketimizi a5+offset olarak belirtmemiz yeterlidir.
 Ama bunu “ELLE” mi yapmalıyız????
Hayır! Bunu yapmak için çok hızlı bir sistem var:

S:                ; Referans etiket
MYPROGGY:
LEA    $dff002,A6    ; A6'da özel kayıt
LEA    S(PC),A5    ; A5'te etiketlerin ofset kaydı

MOVE.L    #$123,LABEL2-S(A5)    ; label2-s = ofset! Örneğin: “$364(a5)”

MOVE.L	LABEL2(PC),d0        ; Burada normal şekilde hareket ediyoruz

MOVE.L    d0,LABEL3-S(A5)        ; aynı şey.

move.l    #$400,$96-2(a6)        ; Dmacon (a6'da $dff002 var!!!)

...

; A5 kaydını “kirletmiş” olduğumuzu varsayalım... yeniden yüklemek yeterli olacaktır!

LEA    S(PC),A5
move.l    $64(a1),OLDINT1-S(A5)
CLR.L    LABEL1-S(A5)

Anlaşıldı değil mi? Etiketi S: yerine BAU olarak da adlandırabilirdiniz, ancak
S:, E:, I: olarak adlandırmanın daha kısa ve kullanışlı olduğunu düşünüyorum.
Tek sınırlama, etiketin referans etiketinden 32K'dan daha uzak olması
durumunda, adresleme sınırlarının dışına çıkılmasıdır. Bu
aşılmaz bir sorun değildir, aslında her 30K'da bir referans etiket
koymak ve en yakınına başvurmak yeterlidir, örneğin:

B:
...
LEA    B(PC),A5
MOVE.L    D0,LABEL1-B(A5)
...

; 30K geçer

C:

LEA    C(PC),A5
MOVE.L    (a0),LABEL40-C(A5)
...

Bu sistem ayrıca, birisi bir disassembler kullanarak rutinlerinizi “çalmak” isterse, kodunuzu disassemblemek zorlaştırır.
Başka bir şey de, bitleri bayrak olarak kullanmak olabilir. Örneğin, programımızda VERO veya FALSO, yani AÇIK veya KAPALI olması gereken değişkenler varsa, bitleri bayrak olarak kullanmak gereksiz bit israfıdır.

Yararlı olabilecek başka bir şey de bitleri bayrak olarak kullanmaktır. Örneğin,
programımızda DOĞRU veya YANLIŞ, yani AÇIK veya KAPALI olması gereken değişkenler varsa,
 her biri için bir bayt harcamak gereksizdir.
Bir bit yeterlidir ve yerden tasarruf ederiz. Örneğin:

Seçenek1    =    0
Sağ    =    1    ; Sağa mı, sola mı?
Yaklaşma    =    2    ; Yaklaşma mı, uzaklaşma mı?
Müzik        =    3    ; Müzik açık mı, kapalı mı?
Mumlar        =    4    ; Mumlar açık mı, kapalı mı?
FirePremuto    =    5    ; biri ateş düğmesine bastı mı?
Acqua        =    6    ; aşağıdaki gölet?
Cavallette    =    7    ; çekirgeler var mı?

Kontrol:
move.w    MieiFlags(PC),d0
btst.l    #Seçenek1,d0
...


Bayrakları Değiştir:
lea    MieiFlags(PC),a0
bclr.b    #Seçenek1,(a0)
...

MieiFlags:
dc.b    0
even

Her neyse, btst ve bclr/bset/bchg'yi sevmiyorsanız şöyle yapabilirsiniz:

bset.l	#Seçenek1,d0    ->    or.b    #1<<Seçenek1,d0

bclr.l    #Seçenek1,d0    ->    and.b    #~(1<<Seçenek1),d0

bchg.l    #Seçenek1,d0    ->	eor.b    #1<<Seçenek1,d0

Shift “>>” ve “<<” asmone işlevlerinin yanı sıra
eor “~” işlevinin yararlılığına dikkat edin.

CPU optimizasyonları bölümünü bitirmek için,
sadece 68020 ve üstü işlemcilerde hız artışı sağlayan bazı püf noktalarına değineceğim, ancak
bunları yapmak hiçbir maliyeti olmadığı için, daha hızlı bilgisayarlarda
rutinlerimizin daha hızlı çalışmasını sağlamak için yararlı olabilir.
Öncelikle, 256 bayta kadar uzun döngüleri yüklemeye izin veren önbellekler vardır,
 böylece ikinci döngüden itibaren bunlar
CPU'nun dahili belleğinden okunacaktır!!!!!!!!!!!!!! Ve yavaş bellekten değil (özellikle
chip-ram!). Sonuç olarak,
gördüğümüz gibi, çeşitli döngülerde işlemleri 100-150 bayt büyüklüğünde olacak şekilde tekrarlamak iyidir.
Bu şekilde, 68020+ üzerinde,
yapılacak döngü sayısı kadar komutun sıraya konulduğu rutinlerden çok daha hızlı çalışacaklardır.
Anlaşılması için, şunu ele alalım:

Rutin1:
move.w    #2048-1,d7
loop1:
< komut bloğu >
dbra    d7,loop1

Bunu şu şekilde optimize edebiliriz:

Rutin1:
rept    2048
< komut bloğu >
endr

Bu, temel bir 68000'de çok daha hızlıdır, ancak 68020'de daha yavaştır!
Her durumda en hızlı optimizasyonu yapmak için:

Rutin1:
move.w    #(2048/16)-1,d7
loop1:
rept    16
< komut bloğu >
endr

dbra    d7,loop1

Komut bloğunun 12 bayt uzunluğunda olduğunu varsayalım, o zaman 12*16
192 eder, bu da önbelleğe sığar ve 68020'de çok hızlı çalışır, oysa 68000'de
2048 rept içeren sürümle farkı hissedilmez ve
yürütülebilir dosyanın uzunluğu da azalır. Sadece 250 veya 256 bayt uzunluğunda döngüler yapmamaya dikkat edin, çünkü önbellek
belirli “blok” ve “hizalama” koşullarına göre dolabilir. Bu nedenle, güvenlik için her zaman 180-200 baytın altında kalın.
“blok” ve “hizalama” koşullarına göre doldurulabilir. Bu nedenle, güvenlik için her zaman
180-200 baytın altında kalın.

Dikkat edilmesi gereken bir diğer nokta, mümkünse belleğe art arda
erişmekten kaçınılmasıdır. Örneğin:

move.l    d0,(a0)
move.l    d1,(a1)
move.l    d2,(a2)
sub.l    d2,d0
eor.l    d0,d1
add.l    d1,d2

Şu şekilde “yeniden formüle edilmelidir”:

move.l    d0,(a0)
sub.l    d2,d0
move.l    d1,(a1)
eor.l    d0,d1
move.l    d2,(a2)
add.l    d1,d2

Aslında, belleğe erişildiğinde (özellikle çip belleklerde), yeniden yazılmadan önce bekleme süresi olan
WAIT STATE vardır. İlk
örnekte, bir yazma işlemi ile diğer yazma işlemi arasında, işlemcinin
RAM'e yeniden yazılmasını beklediği bir bekleme süresi vardır. İkinci örnekte ise,
RAM'e yazıldıktan sonra, CPU içinde kayıtlar arasında bir işlem gerçekleştirilir
ve ardından erişim süresi geçtikten sonra çip RAM'e yeniden erişilir.
32 bit FAST RAM'e erişilirse sorun çok daha azdır, ancak yine de mevcuttur.

Son olarak, 68020+ işlemcileri, 32'nin katları olan adreslere, yani longword'lere hizalanmış rutinleri ve etiketleri çok sever.
32 bit hizalamak için şunu yeterlidir: CNOP
32 bit'e hizalamak için şunu yeterlidir:

CNOP    0,4

Rutin veya etiketten önce. 68000'de iyileştirme yoktur, ancak
68020+'da vardır, özellikle hizalanmış kod hızlı RAM'e veya
önbelleğe gidiyorsa. İşte bir örnek:

Rutin1:
bsr.s    dönüş
bsr.s    projeksiyon
bsr.s    çizim
rts

cnop    0,4
dönüş:
...
rts

cnop    0,4
projeksiyon:
...
rts

cnop    0,4
çizim:
...
rts

Etiketler için, yavaşlatıcı olan tek adreslere erişmemeye dikkat edin,
 bunun yerine bunları da long ile hizalayın:

Orijinal sürüm:

Etiket1:
dc.b    0
Etiket2:
dc.b    0    ; tek adres! “move.b xx,label1” yavaş olacaktır!
Etiket3:
dc.w	0
Etiket4:
dc.w    0
Etiket5:
dc.l    0
Etiket6:
dc.l    0
Etiket7:
dc.l    0

Hizalanmış sürüm:

cnop    0,4
Etiket1:
dc.b    0
cnop    0,4
Etiket2:
dc.b    0
cnop    0,4
Label3:
dc.w    0
cnop    0,4
Label4:
dc.w    0
cnop    0,4
Label5:
dc.l    0
Label6:
dc.l    0 ; bu ikisi kesinlikle hizalıdır, cnop gerekmez
Label7:
dc.l    0

Bir etiketin 32 bit ile hizalı olup olmadığını kontrol etmek için, derleyin, ve
“M” komutuyla bu etiketin adresini kontrol edin, ardından adresi
4'e bölün ve sonucu tekrar 4 ile çarpın.
Orijinal adres geri gelirse, bu 4'ün katı olduğu anlamına gelir ve her şey
tamamdır, farklı bir sonuç gelirse, bir kalan vardır ve 4'ün katı değildir.
O zaman adresin üzerine “dc.w 0” yazın ve “elle” hizalamayı deneyin
ve biraz bozuk olan derleyiciyi boşverin.
Her neyse, eğer rutininiz 50. turda, a500'de takılmadan çalışıyorsa,
 listelemeyi karıştırmak için tüm o “cnop 0,4”leri koymaktan vazgeçin.
 Sadece bir çerçeveye sığmayan çok ağır rutinleri olan listeleri cnoplayın,
 örneğin fraktal rutinler veya “abartılı” 3d rutinler vb.

******************************************************************************
*            BLITTER OPTİMİZASYONLARI             *
******************************************************************************

Sonunda Blitter ile ilgili başka bir örnek daha vereceğiz.
Şimdiye kadar ele aldığımız bu tür optimizasyonlar
sadece 68000 ile ilgiliydi, yani
 şimdi Amiga'nın donanımı
, daha doğrusu Blitter ile ilgili optimizasyonları ele alacağız.
Bildiğiniz gibi, blitter, temel 68000'den çok daha hızlı veri aktarımı için
güçlü bir yardımcı işlemcidir (ancak 68020+'dan daha yavaş olduğunu unutmayın
!). Blitter'dan en iyi şekilde yararlanmak iyidir.
Genellikle blitter için benimsenen bir felsefe, veri aktarımına ne kadar erken başlarsam
o kadar erken bitiririm şeklindedir. Ancak, blitter'a CPU'dan daha fazla öncelik verebilen
blit nasty adlı biti her zaman göz önünde bulundurmalısınız.
Pratikte, veri aktarım bus'ı çoğu zaman blitter'a ait olacaktır. Bir örnek verelim:
a6=$dff000 ; Tüm Move kayıtlarını başlattığımızı varsayalım.

a6=$dff000
; Tüm kayıtları başlattığımızı varsayalım

Move.w    d0,$58(a6)    ; BLTSIZE - Blitter başlar
Wblit:
Move.w    #$8400,$96(a6)    ; Blit nasty'yi etkinleştiriyoruz
Wblit1:
Btst    #6,2(a6)    ; Blitter'ın bitirmesini bekliyoruz
Bne.s    Wblit1
Move.w    #$400,$96(a6)    ; Blit nasty'yi devre dışı bırakıyoruz
....

Bu basit bir durumdur, çünkü blitter çalışırken CPU başka bir şey yapabilir,
 bu nedenle bu bekleme döngüsü verimsizdir.
Aslında, sadece CHIP RAM bulunan bilgisayarlarda bu işlev işlemciyi tamamen bloke eder
ve muhtemelen hiç kullanılmamalıdır.
Ancak blit nasty'yi etkinleştirebileceğimiz ve etkinleştirmemiz gereken durumlar,
bit düzlemlerini bit düzlemleri olarak ekrana kopyalamamız gereken durumlardır, çünkü
genellikle CPU bir blit işlemi ile diğerinin arasında beklemek zorunda olduğundan
blit nasty'yi rahatlıkla etkinleştirebiliriz. Bir örnek görelim:

BLITZ:                ; Kayıtlar zaten etkinleştirilmiştir
Move.w    #$8400,$96(a6)    ; Nasty'yi etkinleştiriyoruz
Move.l    Plane0,$50(a6)    ; Kanal A işaretçisi
Move.l    a1,$54(a6)    ; D kanalına işaretçi
Move.w    d0,$58(a6)    ; Go Blitter!!!
WBL1:
Btst    #6,2(a6)    ; Burada CPU bitmesini beklemeli...
Bne.s    WBL1        ; sonra blitter maksimum hıza çıkmalı!
Move.l    Plane1,$50(a6)    ; A kanalına işaretçi
Move.l    a2,$54(a6)    ; D kanalına işaretçi
Move.w    d0,$58(a6)    ; Blitter çalıştır!!!
WBL2:
Btst    #6,2(a6)    ; Yukarıdaki gibi
Bne.s    WBL2
Move.l    Plane2,$50(a6)    ; Aynı
Move.l    a3,$54(a6)
Move.w    d0,$58(a6)
WBL3:
Btst    #6,2(a6)
Bne.s    WBL3
Move.w    #$400,$96(a6)    ; Bu noktada nasty de
Rts            ; devre dışı bırakılabilir.


Bu örnek, blitter'ın bazı kayıt değerlerini değiştirmeyen bir özelliğini
gösterme fırsatı veriyor.
Örneğin, modül kayıtlarında (BltAMod, BltBMod, vb.). Blitter işleminin sonunda
aynı değerleri bulacağız, bu nedenle
bir sonraki blitter işlemi için modül aynı olacaksa bunları başlatmaya gerek yoktur.
Aynı şey BltCon0, BltCon1, BltFWM, BltLWM gibi kayıtlar için de geçerlidir, ancak
bu, artımlı adresleme ile çalışan işaretçi kayıtları için geçerli değildir.
Bu, bize şu şeyi düşündürür: 5 bit düzleminden oluşan bir bob olduğunu ve bunları birer birer bir “video” bit düzlemine yerleştirmek istediğimizi varsayalım.
Bu bize şunu gösterir: 5 bit düzlemli bir bobumuz olduğunu varsayalım,
 bunları tek tek bir “video” bit düzlemine yerleştirelim, ardından her
seferinde “video” bit düzlemine işaretçiyi D kaydına ve
bob işaretçisini A'ya yükleyelim: İlk bliçlemeden sonra D kaydı
aynı değer artı bir miktar daha yüklenerek bir sonraki bit düzlemine
işaret eder, ancak bunu A kanalıyla yapmak gereksizdir, çünkü
bobumuz bellekte ardışık bit düzlemleri olarak depolanmışsa,
 ilk bliçlemeden sonra A kanalı otomatik olarak bobun
ikinci bit düzlemine işaret eder.
Aşağıdaki şekilde de geçerli sonuçlar elde edebiliriz.
Blitter kayıtlarına aktarılacak tüm değerleri içeren bir bellek alanı ayırıyoruz
(bizim durumumuzda alan DataBlit'ten başlıyor).
Ardından, bazı adres kayıtlarına blitter kayıtlarının adreslerini
daha hızlı erişebilmek için yüklüyoruz ve blitter'ı başlatmak için önceden hazırlanmış verileri kopyalıyoruz,
 doğrudan CPU kayıtlarına erişerek.
CPU kayıtlarına erişerek. Bir örnek görelim:

Lea    $dff002,a6    ; a6 = DMAConR
Move.l    DataBlit(pc),a5    ; ardından a5 önceden hesaplanmış değerlerin bulunduğu bir tabloya işaret eder
;

; Şimdi adres kayıtlarını yükleyelim

Lea    $40-2(a6),a0	; a0 = BltCon0
Lea    $62-2(a6),a1    ; a1 = BltBMod
Lea    $50-2(a6),a2    ; a2 = BltApt
Lea    $54-2(a6),a3    ; a3 = BltDpt
Lea    $58-2(a6),a4	; a4 = BltSize
Moveq    #6,D0        ; d0 blitter durumunu kontrol etmek için sabit
; .
Move.w    (a5)+,D7    ; Blitter sayısı
Move.w    #$8400,$96-2(a6) ; Nasty'yi etkinleştiriyoruz
BLITLOOP:
Btst    d0,(a6)        ; Her zamanki gibi bir işlemin bitmesini bekliyoruz
Bne.s    BLITLOOP    ; .
; Aşağıya bakmadan önce bir
; gözlem yapalım, eğer a0'da $40000 değeri varsa
; ve komutları üç farklı durumda çalıştırırsam
; a)Move.b #“1”,(a0)
; b)Move.w #“12”,(a0)
; c)Move.l #“1234”,(a0)
; aşağıdaki sonucu elde ederim:
; (a)    (b)    (c)
; $40000    “1”    ‘1’    “1”
; $40001    “0”    “2”    “2”
; $40002    “0”    “0”    “3”
; $40003    “0”    ‘0’    “4”
; Şimdi şöyle bir şey yapacağız...
Move.l    (a5)+,(a0)    ; $dff040-42 yani Bltcon0-Bltcon1
Move.l    (a5)+,(a1)    ; $dff062-64 yani BltBMod-BltAMod
Move.l    (a5)+,(a2)    ; $dff050 - Kanal A
Move.l    (a5)+,(a3)    ; $dff054 - Kanal D
Move.l    (a5)+,(a4)    ; $dff058 - BLTSIZE... BAŞLAT!!
Dbra    d7,BLITLOOP    ; Bu d7 kez tekrarlanır.


Bu örnekte, daha önce bahsettiğimiz çeşitli optimizasyon teknikleri kullandık,
 bunlardan bazılarına bir göz atalım.
Öncelikle, bir döngüyü çok sayıda kez gerçekleştirmemiz gerektiğinde ve
içinde bir sabit (yani bir anlık veri) içeren bir işlem varsa,
 bu değeri döngüde kullanılmayacak bir kayıt defterine koymak
döngüde daha sonra bu değeri içeren kayıtla
doğrudan işlemi gerçekleştirerek belleğe erişimi önlemek daha iyidir.
Bizim durumumuzda, blitterin görevini tamamlayıp tamamlamadığını kontrol etmek için
test edilecek bitin değerini
d0 kaydına yükleyerek bu stratejiyi kullandık.
Pratikte, başlangıçta bahsettiğim ilk kurallardan birini uyguladık,
 yani değerleri her zaman kayıtlarda tutmaya çalıştık.
Ayrıca, $dff000 yerine $dff002'yi temel olarak yükledik. Bu,
waitblit'in ofseti hesaplamak için harcadığı zamanı ortadan kaldırmak için sıklıkla yapılır:

Btst    #6,2(a6)    ; a6 = $dff000

şundan daha yavaştır:

btst    d0,(a6)        ; a6 = $dff002, d0 = 6

Doğru ofseti elde etmek için (a6) öncesine -2 eklemeyi unutmayın:

$54-2(a6)    ; BltDpt
$58-2(a6)	; BltSize
$96-2(a6)    ; DmaCon
...

waitblit'in hızlı olması önemlidir, çünkü
blit işlemi bittiğini ne kadar çabuk “fark eder”se, bir sonraki o kadar çabuk başlar!
Bu nedenle, waitblit'i BSR ile çağırmayın, her zaman yerine koyun,
 gerekirse her seferinde tekrarlayın.

Aynı şeyi blitter kayıtları için de uyguladık,
 bunları CPU kayıtlarına yükleyerek belleğe erişimi önledik
(pratikte blitter'ı başlatmak için belleğe yine de erişiyoruz
, ancak her seferinde adresi bellekten almaktan kaçınıyoruz)
Ayrıca, oyun veya demo programlayan herkesin kullandığı bir hile kullandık,
 yani bob boyutunu bellekte tutarak bltsize değerini hesaplamak yerine,
 bltsize değerini doğrudan tutuyoruz, bunu
DataBlit tablosu aracılığıyla yaptık.
Ancak, yukarıda da belirttiğim gibi, blitter çalışırken 68000 başka bir şey yapabilir,
 örneğin blitter bir bellek alanını siliyorsa,
 68000 iyi bir vatandaş olarak ona yardım edebilir, örneğin:


btst    #6,2(a6)
WaitBlit:
btst    #6,2(a6)
bne.s    WaitBlit
Moveq    #-1,d0
Move.l    d0,$44(a6)        ; -1 = $ffffffff
Move.l    #$9f00000,$40(a6)
Moveq    #0,d1
Move.l    d1,$64(a6)
Move.l    a0,$50(a6)
Move.l    a1,$54(a6)
Move.w    #$4414,$58(a6)        ; Blitter temizlemeye başlar...
Move.l    a7,OldSp
Movem.l    CLREG(pc),d0-d7/a0-a6    ; Kayıtları temizliyoruz
Move.l    Screen(pc),a7        ; Silinecek alanın adresi
Add.w    #$a8c0,a7        ; sonuna gidiyoruz (+$a8c0)

Rept        1024        ; 68000 temizlemeye başlar
Movem.l    d0-d7/a0-a6,-(a7)    ; 1024 kez 60 bayt temizle
EndR

Lea    $dff000,a6
Movea.l    OLDSP(pc),a7
Rts

CLREG:
ds.l    15


Gördüğünüz gibi, burada blitter ve cpu “aynı anda” yarım
ekranı temizliyor. Tabii ki bu durumda nasty bit ayarlanmamalı,
 aksi takdirde cpu rahatça temizlik yapamaz.

Programınızın performansını artırmanın en iyi yöntemi,
 algoritmalarınızı sık sık iyileştirmektir.
Örneğin, kötü bir sıralama algoritması olan Buble Sort'u
assembly ile uygulamak, C ile uygulanan en iyi sıralama algoritması olan Quick Sort'tan
daha hızlı olacağını düşünmeyin.
En iyi optimizasyon tekniklerini kullandıktan sonra bile algoritmanız daha hızlı çalışmıyorsa,
 onu silin
ve baştan daha iyi bir algoritma ile yeniden yazın.
En iyi algoritmaya sahip olsanız bile, her zaman
yavaş makinelerde de çalışacak şekilde optimize etmeye çalışın,
 486'lı bir programcının kodunun kendi konfigürasyonunda hızlı çalıştığı için
memnun olduğu PC dünyasında olduğu gibi değil.
Hızlı rutinler yapmak neye yarar ki, oyun veya programın ambalajında
ŞU yazıyorsa: MINIMUM KONFIGÜRASYON: PENTIUM 60Mhz ile 8MB RAM.
