
;    68000 PROGRAMMING REFERENCE TABLE - LEVEL 2

! !
_..'/\ |\___/| /\-.._
./||||||\\. ||||||| .//||||||\.
./||||||||||\\|.. ||||||| ..|//||||||||||\.
./||||||||||||||\||||||||||||||||||||/|||||||||||||\.
./|||||||||||||||||||||||||||||||||||||||||||||||||||||\.
/|||||||||||||||||||||||||||||||||||||||||||||||||||||||||\
“|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||`
”||||“ `|||||/” ``\|||||||||||||/“” `\||||||“ `|||
|/” `\|/ \!|||||||!/ \|/“ `\|
V V \|||||/ V V
` ` \|||/ ” '
\./
Author: Fabio Ciucci         V

Addressing in brief:

*******************************************************************************
move.l #123,xxxx     ; Immediate: the value after the # is copied to the
; destination.
*******************************************************************************
move.l xxxx,$50000     ; Long absolute (a longword, up to where
; the memory addresses in the computer reach!).
*******************************************************************************
move.l xxxx,$500.w     ; Short absolute (address less than $7FFF)
; Example: ‘move.l 4.w,a6’
*******************************************************************************
move.l    xxxx,D0         ; Direct data register (can be accessed with .b
; .w and .l to a Dx data register)
*******************************************************************************
move.l    xxxx,A0         ; Direct address register (can only be accessed
; with .w and .l to an Ax address register, in fact
; a ‘move.b d0,a0’, for example, would give an error,
; similarly, move.b a0,d0 is not assembled!)
*******************************************************************************
move.l    xxxx,(a0)     ; Indirect address register (i.e. it is not written
; in the Ax register, but in the address present in
; that register; you can operate with .b, .w and .l).
*******************************************************************************
move.l    xxxx,(a0)+     ; Indirect address register with post-increment
; (after copying, a0 is incremented by 1 if
; the instruction was .b, by 2 if .w and by 4 if .w)
*******************************************************************************
move.l    xxxx,-(a0)     ; Indirect address register with pre-decrement
; (first the register is decremented by 1 if
; the instruction was .b, by 2 if .w and by 4 if .w, then
; the indirect copy takes place, i.e. to the address
; contained in the register
*******************************************************************************
move.l    xxxx,$123(a0)     ; Indirect address register with OFFSET (addressing distance
; ) - the copy is made to the
; address resulting from the sum of the contents of the
; ax address register plus the offset, which can
; vary between -32768 and 32767 ($8000-$7fff)
*******************************************************************************
move.l    xxxx,$12(a0,d0.w) ; Indirect address register with OFFSET and INDEX
; In this case, the index is added
; the offset and the contents of the Ax register.
; The offset can vary between -128 and +127 ($80-$7f)
; The index is a data or address register of which
; only its lower 16 bits
; or all 32 bits can be considered. Examples:

move.l	$12(a1,d2.w),d0
move.l	$12(a1,d2.l),d0
move.l	$12(a1,a2.w),d0
move.l	$12(a1,a2.l),d0

*******************************************************************************
move.l offset(PC),xxxx ; Relative to the PC with OFFSET; normally
; the offset is calculated by the assembler, placing
; a label where we want to write, e.g.:

move.l	label(pc),d0

; The label must not be further than $7fff
; because the maximum offset is -32768 and 32767
; note: usually you can only put (PC)
; in the source operand, and not in the destination one,
; for example, ‘move.l d0,label(PC)’ does not exist.
; The only instruction that allows this is BTST:

btst.l    d0,label(pc)

; Similarly, three instructions that have only one
; operand allow this addressing

jmp    label(pc)
jsr    label(pc)
pea    label(pc)

*******************************************************************************
move.l offset(PC,d0.w),xxxx ; Relative to the PC with OFFSET and INDEX; also in
; this case, the offset is calculated
; by the assembler using labels. Remember
; that the label cannot be more than 127 bytes
; away from the instruction, as the maximum offset is -127,+127

move.l    LabCanez(pc,d2.w),d0
move.l	LabGatto(pc,d2.l),d0
move.l    LabTopol(pc,a2.w),d0
move.l    Labella1(pc,a2.l),d0

; As we have seen for addressing without
; index, this addressing can only be used
; for the source operand, not for the
; destination. For example:
; ‘move.l d0,Labella1(pc,a2.l)’ does not exist!
; Only BTST allows this for the second operand:

btst.l    d0,label(pc,a2.w)

; And 3 instructions with a single operand:

jmp    label(pc,d2.l)
jsr    label(pc,d2.w)
pea    label(pc,d2.w)

*******************************************************************************
move.w d1,SR         ; Status Register
*******************************************************************************
move.w    d1,ccr         ; Condition Code Register
*******************************************************************************

Even more concisely:

Addressing modes                    Syntax
----------------------                    --------

Direct data register                     Dn
Direct address register                 An
Indirect address register                 (An)
Indirect address register with post-increment     (An)+
Indirect address register with pre-decrement         -(An)
Indirect address register with offset (max 32767)     w(An)
Indirect address register with offset and index    b(An,Rx)
Short absolute                         w
Long absolute                         l
Program Counter with Offset (calculated by the asm name)     w(PC)
Program Counter with Offset and Index            b(PC,Rx)
Immediate                         #x
Status Register                         SR
Condition Code Register                     CCR


******************************************************************************

THE STATUS REGISTER: SR

SR - Status Register: the 16 bits of this register are only used
when the processor is in supervisor mode; otherwise, the 8 least significant bits, called the Status Condition Register (CCR), are available
to the programmer. Let's take a closer look at the functions of SR: bit 0 - Carry (C): set to 1 when the result of an addition generates a carry, or when a subtraction generates a carry, or when a division generates a remainder.
Condition (CCR). Let's take a closer look at the functions of SR:

bit 0 - Carry (C): set to 1 when the result of an addition generates a
carry, or when a subtrahend is greater than the minuend, i.e.
when a subtraction has required a ‘borrow’. The Carry bit also contains
the most significant or least significant bit of an operand subjected to a
shift or rotation. It is set to zero when the last operation
performed has no carries or “borrowings”.

bit 1 - Overflow (V): this is set if the result of the last operation
between signed numbers is too large to be
contained in the destination operand, for example if the result exceeds the
limits -128..+127 in the byte field. For example, the sum .b 80+80 generates an
oVerflow, having exceeded +127. In the .w field, the limits are -32768..+32767, and
in the .l field they are -/+ 2 billion. Note that the sum 80+80 in the byte field
does not set the Carry and eXtend flags, but only the oVerflow flag, since
160 does not exceed 255, the maximum that can be contained in a byte for normal numbers.

bit 2 - Zero (Z): set when the operation generates a result of zero (also useful
for checking the decrement of a counter), as well as when
comparing two equal operands.

bit 3 - Negative (N): set to 1 if, in an operation, the high bit of the
number, in two's complement format, is set. In practice, if the result
is a negative number, this bit is set, otherwise it is reset.
The two's complement is obtained by taking the one's complement of the operand
(i.e. inverting all the bits) and then adding 1; for example, +26 in
binary is %000110010; its one's complement is %11100101 (inversion of bits
0 to bits 1 and vice versa); adding 1 gives %11100110.
Bit 7, known as the sign bit, is copied to bit 3 of the Status Register;
In the case of -26, for example, N is set, indicating a negative number.

bit 4 - Extend (X): this is a repetition of the Carry bit and is used in
operations performed in BCD notation (Binary Coded Decimal: the decimal number
20, for example, is not represented by 00010100, but in the form
two tens, zero units 0010 0000) and in binary operations “extended” as ADDX
and SUBX, special versions of the addition and subtraction instructions ADD and
SUB.

Terminology:

Nibble:
Half a byte. Not directly addressable, but extractable from the byte
by means of shifts and rotations. In a byte, a distinction is made between the right nibble (called
“low” or “least significant”) and the left nibble (called “high” or “most
significant”).

Stack:
Literally ‘stack’. It is an area of memory used to store
register values according to the LIFO principle, last in first out (the last
value entered, being at the top of the stack, is also the first to be
extracted). When, during the program, a branch to a
subroutine is executed, the value of the PC (Program Counter) is saved on the stack, which
is ‘retrieved’ as the return address when the subroutine is finished.


ASSEMBLER DIRECTIVES AND FEATURES:

The assembler used in our case, ASMONE, transforms the listing from
ASCII text format into the binary corresponding to the instructions and data
contained in the listing itself. It has certain conventions and special directives
that must be known, in addition to knowledge of the actual 68000 instructions
listed in this text.

First of all, if .b, .w or .l is not specified in the operation,
.w is always assumed; an example:

move	d0,d1

It is assembled as ‘MOVE.W d0,d1’. Similarly, a:

move    d0,12(a0,d0)

It is assembled as

MOVE.W    D0,$0C(A0,D0.W)

Therefore, even the register used as an index, d0, is considered as d0.w.
For this reason, it is ALWAYS advisable to specify the various .b, .w and .l in the instructions, or
we will never be sure how everything will be assembled, especially by
different assemblers.

There are also other peculiarities, for example for instructions such as ASL, ASR,
LSR, ROL, ROR, ROXL, ROXR, which when SHIFTING by a single bit, can be
written in these two forms:

(form1)
ROL.w    #1,d3
ROL.w    #1,(a0)
(form2)
ROL.w    d3
ROL.w    (a0)

Of course, when the shift is greater than 1, it must be specified!

E.g.:
ROL.W    #3,d3

Another IMPORTANT operation performed by the assembler is to automatically recognise
when to use MOVEA or MOVE. In fact, there are
two specific instructions: MOVE for generic copies, except for
copies to An ADDRESS registers, which are performed by MOVEA.

In fact:
MOVE.W    #10,d0
MOVE.W    d1,d2

These are operations performed by MOVE, while:

movea.w    d1,a0
movea.l    a1,a0
movea.w    (a1),a0

These are operations towards Address Registers, therefore they are MOVEA!!! In reality,
there is no need to pay attention every time we do a MOVE whether it is a MOVE
or a MOVEA, because ASMONE does it for us. Just always specify MOVE:

move.w    a1,a0
move.l    d0,d1
move.l    (a1),a4

These 3 instructions will be assembled correctly, the first and third as
MOVEA and the second as MOVE. You can even specify MOVEA when
it is not correct, and the correct MOVE will be assembled:

movea.l    d0,d1

It will be assembled as MOVE.L d0,d1.

The same applies to ADD, ADDI, ADDA; SUB, SUBI, SUBA; AND, ANDI ; CMP, CMPA, CMPI
EOR, EORI ; OR, ORI: let's take ADD as an example for all these
groups of instructions: there are 3 types of ADD, which perform the same
addition operation, but on different operands. So, if you need to perform a
sum of this type:

ADD.W    d0,d1

That is, between registers, for example, a simple ADD is sufficient, while if you need to perform
an addition to an address register, there is a specific ADDA:

ADDA.L    d0,a1

If you need to add a constant, with immediate addressing,
there is a specific ADDI:

ADDI.W    #10,d0

Well, we should always write ADD, paying attention to the case:

add.l    (a1),d0
addi.b    #$12,(a1)
add.b    label(pc,d2.w),d0
adda.l    (a1),a0
add.w    $12(a1,d2.l),d0
adda.w    (a1)+,a0
add.b    $12(a1,d2.w),d0
adda.w    label(pc),a0
addi.w    #$1234,$1234.w

Of course, almost all assemblers always accept ADD during compilation
and assemble ADDI/ADDA/ADD correctly depending on the case:

add.l    (a1),d0
add.b    #$12,(a1)
add.b    label(pc,d2.w),d0
add.l    (a1),a0
add.w    $12(a1,d2.l),d0
add.w    (a1)+,a0
add.b    $12(a1,d2.w),d0
add.w    label(pc),a0
add.w    #$1234,$1234.w

So always write ADD, saving yourself from dividing the instruction into three different cases,
 since it is still an ADD.
The same applies to other instructions that have a ‘little brother’ ending
in “A” for address registers and one ending in ‘I’ for constants.
So always write:

MOVE    - for MOVE, MOVEA instructions
ADD    - for ADD, ADDI, ADDA instructions
SUB    - for SUB, SUBI, SUBA instructions
AND    - for AND, ANDI instructions
CMP    - for CMP, CMPA, CMPI instructions
EOR    - for EOR, EORI instructions
OR    - for OR,ORI instructions

The inventors of assemblers have thus saved us 10 instructions
by ‘merging’ 17 into only 7. However, if you are a stickler for aesthetics
in your listings, you can specify all 17 (well, why not?).

A tip: when acting on an address register, for example:

MOVEA.L    xxxx,Ax
CMPA.L    Ax,Ax
ADDA.L    xxxx,Ax
SUBA.L    xxxx,Ax

Always use the .L extension, never .W, because the addresses are one
longword long, and above all because these register instructions do not act
like the others for .W addressing, especially since they do not allow
.B addressing: in fact, a MOVEA.W or ADDA.W does not act on the lower word
of the address register, but on the entire address, obtaining the “missing” upper word
by filling it with a replica of bit 15 of the lower word. Therefore
something similar to the EXT instruction (see) occurs, and this can be FATAL
for some routines, because this ‘extension’ means that, for example,
an ADD.W #$5000,a0 adds the value $00005000, because bit 15 of $5000 is
set to zero, while an ADD.W #$B000,A0 causes an increase of $FFFFB000, which
is VERY dangerous.

Another convention is that the A7 register can also be indicated as SP:

movem.l    d0-d7/a0-a6,-(SP) <-> movem.l d0-d7/a0-a6,-(a7)

Let's continue with the conventions: we know that to define a comment area,
 the comment text must be preceded by a ;, but it can also be preceded
by an asterisk ‘*’:

move.l    4.w,a6    * comment!

But, in reality, after the instruction, you could put the
comment directly without preceding it with ‘*’ or ‘;’

move.l    4.w,a6    comment!

However, not all assemblers allow this, and it also depends on the
preference settings of the various assemblers, so always put ‘;’
before your comments.

There are also EQUATES, which are symbols that we can define and use
instead of numbers in the listing:

NumeroPlanes    EQU    5

move.w    #NumeroPlanes,d0    ; assembled as MOVE.W #5,d0

Equates are defined in a similar way to labels, they can have any name and
do not need to be spaced from the beginning, but unlike labels they do not need to
end with ‘:’. The symbol ‘=’ can also be used instead of EQU.

-    -    -    -    -    -    -    -    -	-

Of course, if there are operations or expressions in the listing
,
 they are resolved during assembly, as happens when typing
the expression with the ‘?’ command in the ASMONE command line:

MOVE.W    #(10*3)+2,D0    ; Will be assembled as MOVE.W #32,d0
MOVE.W    #(30/3)+2,d0    ; This will be assembled as MOVE.W #12,d0

Similarly, Equates defined for calculations can also be used:

move.w    #NumeroPlanes*2,d0

Or Offsets can be specified from certain labels:

MOVE.b    d0,SPRITE+1
MOVE.b    d1,SPRITE+2
MOVE.b    d2,SPRITE+3

We have already seen that this is equivalent to making 3 labels for each byte
after the SPRITE label. For example, to write 100 bytes after a label:

MOVE.B    d0,label+100

And so on. The Offset in memory will be calculated as if there were a label at
that point, 100 bytes after the label (the number always counts as 1 byte!!!).

Finally, you can even specify a LABEL-EQUATE, for example:

HSTART:    EQU    *+1
VSTOP:    EQU    *+2

MIOSPRITE:        ; length 13 lines
dc.b $50    ; VSTART
dc.b $90    ; HSTART
dc.b $5d    ; VSTOP
dc.b $00
...

In this case, the ‘*’ after EQU is used, which indicates ‘THIS ADDRESS’,
so we can translate it as: "HSTART: this address+1‘, etc.
Instead of placing the labels between one byte and another, we have defined them at a certain
distance from that byte, but we have written the ’offset" from that point.
Referring to HSTART and VSTOP, we will refer precisely to the bytes indicated, as
if the labels were placed at that point. (E.g.: ‘M HSTART’: 90 5c 00 ....)
This trick of using ‘*’ after EQU can also be used for Bcc:

move.l    d1,d2
;*-6
move.b    (a1),d0
;*-2
cmp.b    (a1),d0
beq.s    *-2
dbra    d2,*-6

In this case, we can calculate the offset of the
Bcc and DBcc ourselves instead of the assembler. (I have added ; to indicate the offsets as if they were labels to
make it clearer). However, using labels is certainly more convenient.

This could be useful when using the ‘REPT’ directive, which repeats a given piece
of data or code:

REPT    100    ; 100 times

dc.b    “hello”

ENDR    ; end of the part to be repeated

With this directive, we write ‘HELLO’ 100 times in memory. Of course, if
LABELS were used, the ‘label already exists’ error would occur,
so you could use the previous trick:


REPT    100    ; 100 times

move.l    d1,d2
;*-6
move.b    (a1),d0
;*-2
cmp.b    (a1),d0
beq.s    *-2
dbra    d2,*-6

ENDR

There is a command called ‘SET’, which ‘defines a variable’ so that you can use
REPT to create tables or sequential instructions. For example, to create
a table with multiples of 2:

TABLE:
dc.b    0,2,4,6,8,10,12,14,16,18

We can also write:


TABLE:

A set 0        ; A is equal to 0

Rept    10    ; do the piece from here to ENDR 10 times

Dc.b    A*2    ; put (with dc.b) A*2 in memory
A set A+1        ; At the next ‘loop’ A is equal to A+1

Endr

However, the REPT command does not exist in all assemblers, and often makes
the listing less clear. It is best not to use it, unless it saves a lot of
‘manual’ writing.

To finish this part, here are the operations that can be inserted
into the “expressions” resolved during assembly, which can also be used
when using the ‘?’ command to calculate from the command line:


()    Parentheses    ; E.g.: (10*2)*(3+5)
*    Multiplication
+    Addition
-    Subtraction
/    Division
^    Power     (e.g.: ‘moveq #2^4,d0’, assembled ‘moveq #16,d0’)

There are also LOGICAL operators on bits:

&    AND    (E.g.: %01010101 & %00001111 = %00000101
!    OR    (E.g.: %00110011 ! %11000011 = %11110011
~    EOR    (e.g.: %00110011 ~ %11000011 = %11110000
>>    Right shift (e.g.: $50>>2 = $14) (%01010000>>2 = 00010100)
<<    Left shift (like LSL) (e.g.: $14<<2 = $50)

These can be very useful, for example to ‘break’ values.l in
two words, etc. Let's say you want to divide a value along
a word, putting the lower 8 bits in one destination and the upper 8 bits
in another. We can define an Equate and let ASMONE ‘break’ the value,
 so we can simply change that equate each time:


MICS    equ    2000


move.b #(MICS&$FF),$400(a4)    ; put the low byte of the time
move.b #(MICS>>8),$500(a4)	; put the high byte of the time

So, (MICS&$FF) means MICS AND $00FF, and as we know, AND clears the
bits that are zero in the second operand and leaves unchanged, in this case,
the first 8, i.e. $FF (%11111111). Since MICS = 2000, i.e. $07d0, in
this case the operation is $07d0 AND $00FF, so the result is $00d0,
i.e. the LOWER BYTE of the word. The instruction is assembled as follows:

MOVE.B    #$D0,$400(A4)

As for MICS>>8, it is equivalent to $07d0 LSR 8, so the result is
the high byte ‘moved’ to the place of the low byte: $0007:

MOVE.B    #$07,$500(A4)

Longword addresses can also be split into two words, to be placed, for example, in pointers to bitplanes:
INDIRIZZO    EQU    $75000

Copperlist: dc.w    $e0,INDIRIZZO&$FFFF    ; high word of the address in BPL0PTH dc.w    $e2,INDIRIZZO&$FFFF    ; low word of the address in BPL0PTH

Copperlist:
dc.w    $e0,ADDRESS>>16    ; high word of the address in BPL0PTH
dc.w    $e2,ADDRESS&$FFFF    ; low word of the address in BPL0PTL

Everything will be assembled as follows:

dc.w    $e0,$0007
dc.w    $e2,$5000

However, it is better to point the bitplanes with a routine and not use absolute
(FIXED) addresses. These operators are very useful, always keep them in mind.

Let's continue with the directives:

END    ; indicates the end of the listing; whatever appears after END
; is not assembled

Then there are directives concerning alignment to even or odd addresses:

EVEN    ; aligns to an EVEN address (word alignment, 16 bits)
ODD    ; aligns to an ODD address

Even should be used when the error ‘Word at odd address’ occurs
Otherwise, you can align to LongWord (32 bits) or 64 bits. For example, in
CHIPSET AGA, certain graphics resolutions require that the bitplanes be
at addresses that are multiples of 64 bits, and this directive is essential.
To align, use CNOP:

CNOP    Size[,Offset]

cnop    0,2    ; align to word (16 bits) equivalent to EVEN
cnop    0,4    ; align to longword (32 bits)
cnop    0,8    ; align to addresses divisible by 8 (64 bits)
cnop    0,16    ;...

Regarding alignment, REMEMBER THAT on an odd address
you can only operate in .b, otherwise a MOVE.W or MOVE.L #xxx,address causes
a total crash with reset and GURU MEDITATION/SOFTWARE FAILURE.

Another very important directive is DC.x, which allows you to store
bytes, words and longwords, especially from Copperlist or Tables:

dc.w    $1234,$4567,$8901,$2345...

Or for labels used as variables with a single word/long:

GfxBase:
dc.l    0

If you are writing text, use dc.b and place the text between ‘’ or “”

dc.b    ‘ASCII text’,$10,$11

You can also insert decimal/hexadecimal/binary values on the
same line, just separate them with commas. Remember that after a text
or a dc.b, you must put EVEN to even out any odd addresses
that may have been formed!

A variant is DCB.x, which stores various bytes, words or longwords
all the same, e.g.:

dcb.b    100,$55        ; store 100 consecutive bytes $55 in memory
dcb.b    50,$00        ; 50 bytes reset to zero

This directive can also be called BLK, for compatibility with the old
(but legendary) SEKA, however DCB is universally used.

For BSS SECTIONS, which are made up of only zeroed spaces, the
directive ‘DS.x [number]’ is used to specify how much space to occupy:

ds.b    100	; 100 bytes cleared

Speaking of SECTION, SECTIONS are an assembler directive, which
has the function of allocating parts of the code in CHIP or FAST RAM according to
their nature. In crappy or ancient computers, such as MSDOS or other
archaeological finds, there is no multitasking or relocation of programs
in memory. In fact, programs are designed to go to specific memory addresses,
 while on Amiga, each program can be ‘relocated’,
i.e. copied to any free area of memory, so that several
programs can be in memory at the same time, at different addresses.
Oh well, on Windows they managed to make it possible to load more than one program into
memory, but each one works on its own, without multitasking HAHAHAHAHAHAH!
Anyway, the effect of these directives can be seen when
the executable is saved with ‘WO’. In fact, in the Amiga executable format there are
Hunks, i.e. pieces of memory decided with SECTION, which are allocated
by the legendary Amiga operating system.
However, when we assemble and jump from ASMONE, if the AutoAlloc option is not
enabled, all sections are assembled in CHIP (if we answered C to the initial question
asked by ASMONE!). ASMONE has this option disabled by
default. You can enable it from the Project/Preferences../AutoAlloc menu.
However, AutoAlloc takes up more memory, since in addition to the memory allocated
at the beginning, it allocates MORE each time for the sections.
SECTIONS can be CODE, DATA or BSS, and go to CHIP or PUBLIC, i.e.
to any memory. To indicate that it goes to chip, add a _C:

Section    Graphics,DATA_C    ; Data, in CHIP!!!

Another VERY USEFUL directive is INCBIN, which loads data from the disk and places it
in memory at the point where the incbin itself is located:

INCBIN    ‘filename’

A similar directive is INCLUDE ‘filename’, which instead includes ASCII text,
i.e. a piece of source code, which is assembled together with the rest of the code.
This can be useful for including ‘universally used’ routines, such as the
initial startup or music routine. However, I do not recommend using
INCLUDE too much, because you will end up not knowing what is in the
listing, and if you lose one of the files to be included, you can kiss your assembly goodbye!

The directive associated with INCBIN and INCLUDE is INCDIR, which determines from which
directory to load the files from. Be careful, though, because the last INCDIR also applies
to all the listings loaded afterwards, so if the files to be included are
elsewhere, you will have to reset the INCDIR. Examples:

INCDIR    ‘dh0:sorgentozzi/mieifiles’    ; decides a dir

INCDIR    ‘’    ; Resets the incdir, the directory becomes the current one

I do not recommend filling your sources with INCDIR and INCLUDE, because then
if, for example, you need to show one of your listings to
a friend, you will have to copy your poor source, divided into
about fifty small files, onto a floppy disk, and it will be difficult to find them all in the various
directories on your hard disk. Finally, once you get to your friend's place, you will have to
change all the INCDIR paths, and you may find that a file is missing
and you have to give up showing the program in operation.
A clever use of INCBIN/INCLUDE can be this: as far as
INCBIN, you can include all the smallest data
files, under 5Kb, such as sprites or small tables, in the DC.x format listing, while for
figures or music, larger than 5K, it is better to load them with INCBIN: in
this way, the “loose” files‘ are kept to a minimum and the listing is short.
The same applies to INCLUDE: at most, you can use include for the music routine
or for startup, but there is no reason not to use INCLUDE at all.
 In the course, it was used to include ’Startup1.s", mainly
to save space, which is not huge on a diskette.
Would you want to deny yourself the satisfaction of pressing ‘A’ and ‘J’ and seeing
a dozen 3D solids with about fifty balls and
equalizers start up immediately without a 30-minute INCLUDE load??

There are also conditional assemblies (IF, ENDIF, ELSE), but they are not
the end of the world. If they are needed, they will be explained later.

MACROs (MACRO, END) will also be explained later, if necessary, since
they are just a kind of EQUATE for various instructions, and you can
easily do without them.

As for Local Labels (those preceded by .), I think they are a
stupid frivolity for those who have no imagination and cannot come up with names
for their labels. Okay, maybe I've exaggerated, but I don't think
they have any particular use. So, please, don't give me sources with
labels preceded by a dot, or you will stray from my current coding ideology
.
 

-    -    -    -    -    -    -    -    -

A couple of directives that are no longer in fashion nowadays, but which
could be useful are ORG and LOAD, which are used to allocate
FIXED, ABSOLUTE, NON-RELocatable addresses to the instructions in our listing.
Obviously, these instructions were used at the time when
those demos were made, which in fact do not work on modern computers, since
IF YOU MAKE A DEMO/GAME IN EXECUTABLE FILE FORMAT, THERE MUST BE NO
ABSOLUTE ADDRESSES, ONLY SECTIONS!
The use of ORG and LOAD has remained for making an autoboot demo/game, i.e.
a TRACKMO (demo on tracks with non-DOS loading) or an old-style game.
 On the other hand, the latest demos and games are increasingly
installable on hard disks, especially the BEST demos and the BEST games
(see BANSHEE and BRIAN THE LION for games).
I really believe that autoboot discs will disappear in the next few years, because they
cannot be installed on HDs, nor easily converted for CD32 or CD-ROM, and
the only thing that is certain is that HDs and CD-ROMs will become increasingly widespread.
It is also the fact that EVERYTHING is installed on HDs that has made
MSDOS PCs so popular (as well as bribes, as we all know).
In this course, I had thought of including a large section on how to make a
hardware disk loader, and maybe a XCOPY/DCOPY copier, since
I started programming one years ago. But in light of reality, I
have decided not to cover MFM loading via hardware or
autoboot at all, because I would be teaching you to do something that would penalise your
production!!!! The best option is to load files with the operating system,
 i.e. DOS.LIBRARY, as the latest and best productions do.
So I urge you to program only executable files, to be saved with ‘WO’,
and to be wary of obsolete autoboot and, worse, of starting the listing like this:

ORG    $30000    ; organise the code with absolute addresses from $30000
LOAD    $30000    ; assemble at address $30000

Also because if you have 1MB or 2MB of chip without FAST, such as A500+/a600 and a1200
as standard, ASMONE itself is loaded at $30000, which will be overwritten and
everything will go into GURU MEDITATION. (I still remember at Smau in 1991 or 1992,
the stupid kids who loaded ASMONE onto A600s and wondered why
the stolen or copied sources they wanted to pass off as their own work didn't work,
 HAHAHAHA! Well, they were sources they had found on floppy disks from
way back in 1987-1988, and they were full of ORG and LOAD HAHAHAHAH!).

-    -    -    -    -    -    -    -

There are other peculiarities in terms of assembly that depend on the
ASMONE settings, namely:

From the menu: Assembler/assemble../Ucase=Lcase

This option means Upper case = Lower case, and refers to the
upper or lower case letters that make up the LABELS. Normally this option is
set, so the assembler treats upper and lower case letters the same, and you can write:
LaBel1: btst

LaBel1:
btst    #6,$bfe001
bne.s    labEL1

In other words, the ‘word’ that makes up the label must be the same, even if
the upper and lower case letters are different. With Ucase=Lcase disabled,
however, the two labels would be considered different, and there would be an
error message. You would have to write:

Label1:
btst    #6,$bfe001
bne.s    Label1

In any case, each label should be the same, even with regard to
the arrangement of upper and lower case letters. Since we usually forget
which characters we have capitalised and which we have left lower case, it is better to leave it
set, long live freedom!

A note on labels: the command ‘=S’ from the command line shows the SIMBOLTABLE,
 which is the list of all labels with offsets.

Final note: if you compile a source with a million labels, when you
save the executable with ‘WO’, everything will go into GURU MEDITATION, unless
you run a nice ‘stack 20000’ before running ASMONE.

******************************************************************************

Legend:
------
Dn    Data Register        (n between 0-7)
An    Address Register    (n between 0-7 - A7 is also called SP)
b    8-bit constant    ( from -128 ($80) to +127 ($7f) )
w    16-bit constant    ( from -32768 ($8000) to +32767 ($7fff) )
l    32-bit constant	(maximum $FFFFFFFF)
x    8-, 16-, 32-bit constant
Rx    Index Register; these may include:

Dn.W    Lower 16 bits of a Data Register
Dn.L    All 32 bits of a Data Register
An.W    Lower 16 bits of an Address Register
An.L	All 32 bits of an Address Register

--------------------------


\==================================| _=_
\_________________________________/ ___/==+++==\___
‘’‘\__ \’“” |======================================/
\__ \_ / .. . _/--===+_____+===--‘’
 
\__ \ _/. .. _/ `+“
USS ENTERPRISE     \__ \ __/_______/ \ /
NCC-1701     ___-\_\-”---==+____| ---==O=-
__--+‘ . . . ’==_ / \
/ |. . .. -------- | \ 
‘==+_ . . -------- | /
’‘\___ . .. __==’
‘’“”--=--‘’



_____
_.-“ `-._
.-” ` || || “ `-.
_______________ _ ,” \\ // `.
/ || \ /' \ _,-----._ / \
|_______________||_/ / \\ ,' \ | | / `. // \
| | _] \ / \ ,---. / \ // \
| \__,--------/\ ` | \ / \ / |/ - |
) ,-“ _,-” |- |\-._ | .---, | -| == |
|| /_____,---“ || |_|= || `-”,--. \| -| - ==|
|:(==========o=====_|- || ( O )|| -| - --|
|| \~~~~~`---._|| | |= || _,-.`--“ /| -| - ==|
)
 `-.__ `-. |- |/-” | `---' | -| == |
| / `--------\/ , | / \ / \ | |
__|____|_______ _ ] / \ / `---“ \ / \\ /
| || \ \ // `._/ | | \_.” \\ /
\_______________||_/ \ / `-----“ \ /
`. // \\ ,”
`-._ || || _,-“
`-._____,-”


--------------------------

;    LIST OF ALL 68000 INSTRUCTIONS:

NOTE: instructions that are rarely used, such as ABCD, SBCD, SBCD,
LINK, UNLK, the TAS instruction is not described, as it should not be used on
Amiga, nor are ILLEGAL or RESET, which only generate an exception and a
reset of the peripherals.


Key:

Condition codes:

C    Carry

V    Overflow

Z    Zero

N    Negative

X    Extend

Condition code states:

Symbol Meaning
------- -----------

* Set according to the result of the operation
- Unchanged
0 Cleared
1 Set
U State after the operation UNDEFINED
I Set by the immediate data

Other symbols for addressing:

<ea> Effective addressing operand
<data> Immediate data
<label> Assembler label (ASMONE)
<vector> TRAP instruction exception vector (0-15)
<rg.lst> MOVEM instruction register list

Condition Codes
---------------
Assembler Data
Instruction Description         Syntax Size X N Z V C
----------------------- --------- ---- ---------
***************************************************************** X N Z V C ***
ADD Binary addition Dn,<ea> BWL * * * * *
<ea>,Dn

NOTE: there are 3 types of dedicated ADD: for data registers (ADD), for
address registers (ADDA) and for constants (ADDI). However, the assembler
accepts the simple ADD to specify ADDA and ADDI, so
you can always write ADD even when ‘adding’ address registers
or constants; the assembler will assemble it as ADDA or
ADDI as appropriate.

Sum of two binary values, result saved in the destination operand.
FLAG: Carry and eXtend = 1 if a carry occurs, otherwise = 0
Negative = 1 if the result is negative, Negative = 0 if it is positive.
oVerflow = 1 if the result exceeds the .b, .w or .l size of the ADD
Zero = 1 if the result is zero

E.g.:

Dn,<ea>
add.b    d0,d1
add.w    d0,(a1)
add.l	d0,(a1)+
add.b	d0,-(a1)
add.w	d0,$1234(a1)
add.l	d0,$12(a1,d2.w)
add.b	d0,$12(a1,d2.l)
add.b	d0,$12(a1,a2.w)
add.w	d0,$12(a1,a2.l)
add.l	d0,$1234.w
add.w	d0,$12345678

<ea>,Dn
add.b    d1,d0
add.w    a1,d0        ; note: only add.w and add.l from reg. Ax
add.l    (a1),d0
add.w	(a1)+,d0
add.b	-(a1),d0
add.l	$1234(a1),d0
add.b	$12(a1,d2.w),d0
add.w	$12(a1,d2.l),d0
add.w	$12(a1,a2.w),d0
add.b	$12(a1,a2.l),d0
add.l	$1234.w,d0
add.w	$12345678,d0

add.w	label(pc),d0
add.b	label(pc,d2.w),d0
add.l	label(pc,d2.l),d0
add.w	label(pc,a2.w),d0
add.b	label(pc,a2.l),d0

***************************************************************** X N Z V C ***
ADDA Binary register addition An <ea>,An -WL - - - - -

Like ADD, but dedicated to additions on address registers, therefore
only adda.w and adda.l are possible, not adda.b.
Note that the arithmetic FLAGS are not affected by this
operation, unlike ADD.

Tip: ALWAYS use the .L extension

E.g.:

<ea>,An
adda.l    d1,a0
adda.l    a1,a0
adda.l    (a1),a0
adda.l    (a1)+,a0
adda.l    -(a1),a0
adda.l    $1234(a1),a0
adda.l    $12(a1,d2.w),a0
adda.l    $12(a1,d2.l),a0
adda.l    $12(a1,a2.w),a0
adda.l    $12(a1,a2.l),a0
adda.l    $1234.w,a0
adda.l    $12345678,a0
adda.l    label(pc),a0
adda.l    label(pc,d2.w),a0
adda.l    label(pc,d2.l),a0
adda.l    label(pc,a2.w),a0
adda.l    label(pc,a2.l),a0

adda.l    #$1234,a1	; note: when you need to ‘ADD’ a
; constant to an address register,
; the instruction is not addi, but adda,
; and it cannot be .b.

; Furthermore, the function of .w and .l is different from the usual one:
; when operating on ADDRESS registers, each time you operate on the entire
; address, i.e. on the entire LONGWORD. Therefore, if we do
; ADD.W #$12,a0 or ADD.L #$12,a0 there is no difference, because in
; both cases we have added $12, which is a positive number
; that can be contained in a word. However, you must pay attention to the fact
; that if the .w number you want to add is greater than $7fff,
; the value of the sign bit will be copied to
; bits 16 to 31. Let's take an example:

lea    $1000,a0
ADDA.W	#$9200,a0    ; add $FFFF9200 to a0

; In this case, the result is $FFFFA200, a very ugly address!
; Therefore, be careful to use ADDA.L almost always, because this
; feature of the 32-bit sign extension is common to
; all ADDA addressing. (as well as SUBA, CMPA, MOVEA)

***************************************************************** X N Z V C ***
ADDI Addition with immediate data #x,<ea> BWL * * * * *

Addition of immediate data, i.e. a constant, to the destination.
The flags behave as in the ADD instruction:
FLAG: Carry and eXtend = 1 if a carry occurs, otherwise = 0
Negative = 1 if the result is negative, Negative = 0 if it is positive.
oVerflow = 1 if the result exceeds the .b, .w or .l size of the ADD
Zero = 1 if the result is zero

Ex:

#x,<ea>
addi.w    #$1234,        d1    ; the destinations have been
addi.b    #$12,        (a1)	; spaced for greater
addi.l    #$12345678,    (a1)+    ; readability
addi.w    #$1234,        -(a1)
addi.b    #$12,        $1234(a1)
addi.w    #$1234,		$12(a1,d2.w)
addi.l    #$12345678,    $12(a1,d2.l)
addi.w    #$1234,        $12(a1,a2.w)
addi.b    #$12,        $12(a1,a2.l)
addi.w    #$1234,        $1234.w
addi.l    #$12345678,    $12345678

adda.l    #$1234,a1    ; note: when you need to ‘ADD’ a
; constant to an address register,
; the instruction is not addi, but adda,
; and cannot be .b

***************************************************************** X N Z V C ***
ADDQ Addition of #Immediate to 3-bit #<1-8>,<ea> BWL * * * * *

This means ADD Quick, i.e. fast addition of a number from 1 to 8,
which works exactly like ADDI, so it is always better to use
ADDQ instead of ADDI for the sum of numbers from 1 to 8, since
this dedicated instruction exists. The flags behave like ADD:
FLAG: Carry and eXtend = 1 if a carry occurs, otherwise = 0
Negative = 1 if the result is negative, Negative = 0 if it is positive.
oVerflow = 1 if the result exceeds the .b, .w or .l size of the ADD
Zero = 1 if the result is Zero

Ex:

#<1-8>,<ea>
addq.w    #1,d1
addq.w    #1,a1    ; NOTE: addq.b is not possible on Ax registers
addq.w    #1,(a1)
addq.l    #1,(a1)+
addq.l	#1,-(a1)
addq.w	#1,$1234(a1)
addq.b	#1,$12(a1,d2.w)
addq.w    #1,$12(a1,d2.l)
addq.w    #1,$12(a1,a2.w)
addq.l    #1,$12(a1,a2.l)
addq.w    #1,$1234.w
addq.l    #1,$12345678

***************************************************************** X N Z V C ***
ADDX ADD with eXtend flag Dy,Dx BWL * * * * *
-(Ay),-(Ax)

This addition is used to perform binary sums in multiple precision,
i.e. 64 bits. It differs from ADD in that the X FLAG
is added to the result of the operation.
The flags are affected as follows:
FLAG: Carry and eXtend= 1 if a carry occurs, otherwise = 0
Zero = 1 if the result is zero, otherwise it remains UNCHANGED

E.g.:

Dy,Dx
addx.b    d0,d1        ; possible addx.b, addx.w, addx.l

-(Ay),-(Ax)
addx.b	-(a0),-(a1)    ; possible addx.b, addx.w, addx.l

Let's take an example of a 64-bit addition: we want to add the 64-bit hexadecimal value
$002e305a9cde0920 to the value $00001437a9204883.
We can do this as follows:

move.l    #$002e305a,d0    ;\ first value in d0 and d1
move.l    #$9cde0920,d1    ;/
move.l    #$00001437,d2    ;\second value in d2 and d3
move.l    #$a9204883,d3	;/
add.l    d1,d3        ; sum of the low longs of the 2 64-bit numbers
; now any carry is in the X flag
addx.l    d0,d2        ; Sum of the high longs, with addition of the
; X flag, which is the possible carry from the
; sum of the low longs.

We have the 64-bit sum in reg. d3 (32 low bits) and d2 (high bits).
If the sum exceeds the possible 64 bits (but what would you ever want to add up?)
then the Carry FLAG will be set.

***************************************************************** X N Z V C ***
AND Logical AND between bits Dn,<ea> BWL - * * 0 0
<ea>,Dn

The logical AND operation is performed between the individual bits of the
source and those of the destination, and the result is stored
in the destination. Here is a bit-by-bit AND table:

0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1

Therefore, the main use is to “mask” bits, for
example an AND.B #%00001111,d0 has the effect of clearing the 4 high bits
and leaving the 4 low bits unchanged, so we can say that
only the 4 low bits of the value in d0 have been ‘selected’.
FLAG: eXtend unchanged, oVerflow and Carry always 0
Negative and Zero set or cleared depending on the outcome of the AND

E.g.:

Dn,<ea>
and.w    d0,d1        ; it is not possible to perform an AND using
and.b    d0,(a1)        ; a direct address register, for
and.w    d0,(a1)+    ; example ‘and.w a0,d0’ does not exist.
and.l	d0,-(a1)
and.w	d0,$1234(a1)
and.b	d0,$12(a1,d2.w)
and.b	d0,$12(a1,d2.l)
and.w    d0,$12(a1,a2.w)
and.l    d0,$12(a1,a2.l)
and.w    d0,$1234.w
and.b    d0,$12345678

<ea>,Dn
and.b    d1,d0        ; as above, ‘and.w d0,a0’ does not exist
and.w    (a1),d0
and.b    (a1)+,d0
and.w	-(a1),d0
and.b	$1234(a1),d0
and.l	$12(a1,d2.w),d0
and.b	$12(a1,d2.l),d0
and.w    $12(a1,a2.w),d0
and.b    $12(a1,a2.l),d0
and.b    $1234.w,d0
and.l    $12345678,d0
and.l    label(pc),d0
and.b    label(pc,d2.w),d0
and.w    label(pc,d2.l),d0
and.b    label(pc,a2.w),d0
and.l    label(pc,a2.l),d0

***************************************************************** X N Z V C ***
ANDI AND bit by bit with Immediate #<data>,<ea> BWL - * * 0 0

Like the AND instruction, but specific for #Immediate values.
FLAG: eXtend unchanged, oVerflow and Carry always 0
Negative and Zero set or reset depending on the outcome of the AND

Ex:

#<data>,<ea>
andi.b    #$12,        d1    ; the destinations have been
andi.l    #$12345678,    (a1)    ; spaced for greater
andi.b    #$12,		(a1)+    ; readability
andi.w    #$1234,        -(a1)
andi.l    #$12345678,    $1234(a1)
andi.w	#$1234,        $12(a1,d2.w)
andi.b    #$12,        $12(a1,d2.l)
andi.w    #$1234,        $12(a1,a2.w)
andi.l	#$12345678,    $12(a1,a2.l)
andi.l    #$12345678,    $1234.w
andi.b    #$12,        $12345678

andi.b    #$12,ccr
andi.w    #$1234,sr    ; *** PRIVILEGED INSTRUCTION ***

***************************************************************** X N Z V C ***
ASL Arithmetic Shift Left #<1-8>,Dy BWL * * * * *
Dx,Dy
<ea>

Arithmetic shift left. Shift means a ‘sliding’
of bits, in this case to the left, e.g.: %0001 shifted by 2: %0100
i.e. the bits that make up the number are slid, ‘shifted’
to the left; in the case of ASL, the low bits are ‘filled’ with
zeros, while the bits ‘exiting’ from the left are copied
to the Carry and Extend FLAGS. With #immediate addressing, the maximum shift
is #8, while in the Dx,Dy format the first 6 bits
of the Dx register are used, so the shift can go from 0 to 63 ($3f)
The FLAGS are all modified depending on the operation; in Carry
and eXtend, the high bit ‘exiting’ is copied

value that shifts
to the left
------------
Flag X/C <-- |<- <- <- <- | <--- 0 - A zero enters from the right
------------

; Addressing such as ASR, LSL, LSR, ROL, ROR, ROXL, ROXR

Ex:

#<1-8>,Dy
asl.b    #2,d1    ; possible .b, .w and .l, maximum asl.x #8,Dy

Dx,Dy
asl.b    d0,d1    ; possible .b, .w and .l, the maximum shift in
; this case is 63 (the first 6 bits
; of the data register are used)
<ea>
asl.w    (a1)        ; note: ‘asl <ea>’ can only be
asl.w    (a1)+        ; .w, it is not possible to use .b or .l
asl.w    -(a1)        ; note 2: you can also write
asl.w    $1234(a1)    ; in the form ‘asl.w #1,(a1)’,‘asl.w #1,xxx’,
asl.w    $12(a1,d2.w)    ; but it is usually written simply as
asl.w    $12(a1,d2.l)    ; ‘asl.w <ea>’ for 1-bit shifts.
asl.w    $12(a1,a2.w)
asl.w    $12(a1,a2.l)
asl.w    $1234.w
asl.w	$12345678

***************************************************************** X N Z V C ***
ASR Arithmetic Shift Right #<1-8>,Dy BWL * * * * *
Dx,Dy
<ea>

Arithmetic shift right. Shift means a ‘sliding’
of bits, in this case to the right, e.g.: %0100 shifted by 2: %0001
i.e. the bits that make up the number are slid, ‘shifted’
to the right. In each shift, the least significant bit of the destination register
is copied to the Carry and eXtend bits, while the most significant
bit is left UNCHANGED. (Unlike the LSR, i.e. the LOGICAL SHIFT
to the right, where the most significant bit is set to zero).
Therefore, unlike the LSR, the ASR retains the sign bit.
With #immediate addressing, the maximum shift is #8,
i.e. 3 bits, while in the Dx,Dy format, the first 6 bits
of the Dx register are used, so the shift can range from 0 to 63 ($3f).
The FLAGS are all modified depending on the operation; in Carry
and eXtend, the low bit is copied ‘output’

value that shifts
to the right
------------
/-->|-> -> -> ->| ---> Flag X/C
| ------------
|_____|
The high bit is replicated to maintain the sign

; Addresses such as ASL, LSL, LSR, ROL, ROR, ROXL, ROXR

Ex:

#<1-8>,Dy
asr.b    #2,d1    ; possible .b, .w and .l, maximum asr.x #8,Dy

Dx,Dy
asr.b    d0,d1    ; possible .b, .w and .l, the maximum shift in
; this case is 63 (the first 6 bits
; of the data register are used)

<ea>
asr.w    (a1)    ; only .w possible. Equivalent to asr.w #1,<ea>
asr.w    (a1)+	; read the note at the ASL instruction
asr.w    -(a1)
asr.w    $1234(a1)
asr.w    $12(a1,d2.w)
asr.w    $12(a1,d2.l)
asr.w    $12(a1,a2.w)
asr.w    $12(a1,a2.l)
asr.w    $1234.w
asr.w    $12345678

***************************************************************** X N Z V C ***
Bcc Conditional Branch Bcc.S <label> BW- - - - - -
Bcc.W <label>

Test of condition and branch codes. Bcc refers to one
of the following: hi, ls, cc, cs, ne, eq, vc, vs, pl, mi,ge, lt, gt, le, ra.
They can only be .s (i.e. .b) or .w, not .l.
FLAG: no flag is modified
They can be used after a CMP, a TST, or even after an ADD, etc.
In practice, this instruction is used to jump to certain labels
if and only if the flags are in a certain position. TheThe only one is
BRA, which means Branch Always, i.e. ALWAYS JUMP, which jumps every
time. In other cases, it depends on the Condition Codes. Let's look at
the possible Bcc:

Ex:    (Consider the situation after a CMP.x OP1,OP2)

bhi.s    label    ; > (If OP2 is greater than OP1) (OP=Operand)
; (Higher) - OP2 > OP1, without sign
; * If Carry=0 and Z=0

bgt.w    label    ; > (If OP2 is greater than OP1) with sign
; (Greater Than) OP2 > OP1, with sign
; * (N and V or not N and not V) and not Z

bcc.s    label    ; >= (also called BHS) - * If Carry = 0
; (Carry bit Clear) - OP2 >= OP1, without sign

bge.s    label    ; >= (If OP2 is greater than or equal to OP1)
; (Greater than or Equal) OP2>=OP1, with sign
; * If N=1 and V=1, or N=0 and V=0

beq.s    label    ; = (If Z = 1), (zero or equal operands)
; (Equal) OP2 = OP1, for numbers with or without sign

bne.w    label    ; >< (If Z = 0), (If OP1 is different from OP2)
; (Not Equal), for numbers with or without sign

bls.w    label    ; <= (If OP2 is less than or equal to OP1)
; for unsigned numbers (Low or Same)
; * If Carry = 1 or Z = 1

ble.w    label    ; < (If OP2 is less than or equal to OP1) for
; signed numbers
; * N and not V or not N and V or Z

bcs.w    label    ; < (also called BLO) - * If Carry = 1
; (Carry bit Set) - OP2 < OP1, unsigned

blt.w    label    ; < (If OP2 is less than OP1)
; (Less Than), for signed numbers

bpl.w    label    ; + (If Negative = 0), i.e. if the result is
; positive (PLus)

bmi.s    label	; - (If Negative = 1), i.e. if the result is
; negative (Minus)

bvc.w    label    ; If the Overflow bit is V=0 (for signed numbers
; with sign) - NO OVERFLOW (V-bit Clear)

bvs.s    label    ; If the Overflow bit is V=1 (for signed numbers
; with sign) - OVERFLOW (V-bit Set)

bra.s    label    ; always, always jump! Like JMP


The uses of these conditional jumps are endless, for example,
with a:

TST.B    d0
BEQ.S    Label

If d0=0, then the Z (zero) flag is set, so
the beq (Z=1, zero equal operands) jumps to Label. Or:

CMP.W    d0,d1
bhi.s    label	; > (If OP2 is greater than OP1)        

In this case, if d1 is greater than d0, the BEQ jumps to Label.
Note that the CMP compares the destination (d1) with the source,
and not vice versa!

Let's look at some cases with an ADD:

ADD.W    d0,d1
BCS.s    label    ; if there is a carry, go to the label (meaning that
; we have exceeded the value that can be contained in the word)

ADD.L    d3,d4
BEQ.s    label    ; If the result is zero, jump to the label

ADD.B    d1,d2
BVS.s    Label    ; Overflow! The sum of two numbers with the same
; sign, whether positive or negative, is greater
; than the range of numbers in 2's complement possible
; in a byte (-127..+128).

Now let's see how to use Bcc after CMP.x OP1,OP2

beq.s    label	; OP2 = OP1 - for all numbers
bne.w    label    ; OP2 >< OP1 - for all numbers
bhi.s    label    ; OP2 > OP1 - without sign
bgt.w    label    ; OP2 > OP1 - with SIGN
bcc.s    label    ; OP2 >= OP1 - without sign, also known as *‘BHS’*
bge.s    label    ; OP2 >= OP1 - with SIGN
bls.w    label    ; OP2 <= OP1 - without sign
ble.w    label    ; OP2 <= OP1 - with SIGN
bcs.w    label    ; OP2 < OP1 - without sign, also known as *‘BLO’*
blt.w    label    ; OP2 < OP1 - with SIGN

And now how to use them after a TST.x OP1

beq.s    label    ; OP1 = 0 - for all numbers
bne.w    label    ; OP1 >< 0 - for all numbers
bgt.w    label    ; OP1 > 0 - with SIGN
bpl.s    label    ; OP1 >= 0 - with SIGN (or BGE)
ble.w    label	; OP1 <= 0 - with SIGN
bmi.w    label    ; OP1 < 0 - with SIGN (or BLT)

The latter also apply after an ADD.x or SUB.x, for example:

ADD.W	d1,d2
beq.s    ResultZero
bpl.s    ResultGreaterThanZero
bmi.s    ResultLessThanZero

This saves a possible TST.w d2 after the ADD.

***************************************************************** X N Z V C ***
BCHG Bit and CHanGe Test Dn,<ea> B-L - - * - -
#<data>,<ea>

This operation changes a single specified bit. By ‘change’ we mean
that if it was 0, it is set to 1, and if it was 1, it is set to 0.
To do this, it first tests it by setting the Z flag, then
‘changes’ it with a NOT.
FLAG: Only the Z is modified
If the destination operand is a data register, then the instruction
is always .L, and it is possible to specify with the source operand
a bit from 0 to 31.
If the destination operand is a memory byte, then the instruction
is always .B, and it is possible to specify with the source operand
a bit from 0 to 7.

; Addressing such as BSET, BCLR; BTST has a few more (PC)

Ex:

Dn,<ea>
bchg.l    d1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

bchg.b    d1,(a1)        ; only .B when operating on other
bchg.b    d1,(a1)+    ; addresses. In this case, it is
bchg.b    d1,-(a1)    ; possible to specify a bit
bchg.b    d1,$1234(a1)    ; between 0 and 7
bchg.b    d1,$12(a1,d2.w)
bchg.b    d1,$12(a1,d2.l)
bchg.b    d1,$12(a1,a2.w)
bchg.b    d1,$12(a1,a2.l)
bchg.b    d1,$1234.w
bchg.b    d1,$12345678

#<data>,<ea>
bchg.l    #1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

bchg.b    #1,(a1)        ; only .B when operating on other
bchg.b	#1,(a1)+    ; addresses. In this case, it is
bchg.b    #1,-(a1)    ; possible to specify a bit
bchg.b    #1,$1234(a1)    ; between 0 and 7. However, be careful
bchg.b    #1,$12(a1,d2.w)	; that ASMONE incorrectly assembles
bchg.b    #1,$12(a1,d2.l)    ; even values greater than 7, in this
bchg.b    #1,$12(a1,a2.w)	; case the bit to be operated on is, at
bchg.b    #1,$12(a1,a2.l)    ; example, if #13, #13-8=5.
bchg.b    #1,$1234.w
bchg.b    #1,$12345678

NOTE:
Unfortunately, ASMONE also assembles bchg with values greater than
7, (for example, DevPac would give an error).
NEVER give values greater than 7 for bchg.b!
If, however, some listings have it, the instruction is
executed anyway, and the bit is ‘calculated’ by subtracting 8,
or if the number is greater than 16, by subtracting 2*8, 3*8
etc. Here is a list of equivalents
for bchg.b #1,xxx, obviously for information purposes only:

bchg.b    #1,<ea>
bchg.b    #1+8,<ea>	; i.e. #9
bchg.b    #1+8*2,<ea>    ; i.e. #17
bchg.b    #1+8*3,<ea>    ; i.e. #25
bchg.b    #1+8*4,<ea>    ; i.e. #33
bchg.b    #1+8*5,<ea>    ; i.e. #41
...
bchg.b    #1+8*30,<ea>    ; i.e. #241
bchg.b	#1+8*31,<ea>    ; i.e. #249 (maximum 255)

This ASMONE (and 68000?) error occurs for
BCHG, BSET, BCLR, BTST

***************************************************************** X N Z V C ***
BCLR Test a Bit and CLeaR Dn,<ea> B-L - - * - -
#<data>,<ea>

This instruction RESETS the specified bit.
If the destination operand is a data register, then the instruction
is always .L, and it is possible to specify with the source operand
a bit from 0 to 31.
If the destination operand is a memory byte, then the instruction
is always .B, and it is possible to specify with the source operand
a bit from 0 to 7.

; Addressing such as BCHG,BSET; BTST has a few more (PC)

Ex:

Dn,<ea>
bclr.l    d1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

bclr.b    d1,(a1)        ; only .B when operating on other
bclr.b    d1,(a1)+    ; addresses. In this case, it is
bclr.b    d1,-(a1)    ; possible to specify a bit
bclr.b    d1,$1234(a1)    ; between 0 and 7
bclr.b    d1,$12(a1,d2.w)
bclr.b    d1,$12(a1,d2.l)
bclr.b    d1,$12(a1,a2.w)
bclr.b    d1,$12(a1,a2.l)
bclr.b    d1,$1234.w
bclr.b    d1,$12345678

#<data>,<ea>
bclr.l    #1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

bclr.b    #1,(a1)        ; only .B when operating on other
bclr.b    #1,(a1)+    ; addresses. In this case, it is
bclr.b    #1,-(a1)	; possible to specify a bit
bclr.b    #1,$1234(a1)    ; between 0 and 7
bclr.b    #1,$12(a1,d2.w)
bclr.b    #1,$12(a1,d2.l)
bclr.b	#1,$12(a1,a2.w)
bclr.b	#1,$12(a1,a2.l)
bclr.b	#1,$1234.w
bclr.b	#1,$12345678

NOTE:
Unfortunately, ASMONE also assembles bclr with values greater than
7 (for example, DevPac would give an error).
NEVER give values greater than 7 for bclr.b!
See the note on BCHG for more information.

***************************************************************** X N Z V C ***
BSET Test a Bit and SET Dn,<ea> B-L - - * - -
#<data>,<ea>

This instruction SETS the specified bit to 1.
If the destination operand is a data register, then the instruction
is always .L, and it is possible to specify with the source operand
a bit from 0 to 31.
If the destination operand is a memory byte, then the instruction
is always .B, and it is possible to specify a bit from 0 to 7 with the source operand
.


; Addressing such as BCHG, BCLR; BTST has a few more (PC)

Ex:

Dn,<ea>
bset.l    d1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

bset.b    d1,(a1)        ; only .B when operating on other
bset.b    d1,(a1)+    ; addresses. In this case, it is
bset.b    d1,-(a1)    ; possible to specify a bit
bset.b    d1,$1234(a1)    ; between 0 and 7
bset.b    d1,$12(a1,d2.w)
bset.b    d1,$12(a1,d2.l)
bset.b    d1,$12(a1,a2.w)
bset.b    d1,$12(a1,a2.l)
bset.b	d1,$1234.w
bset.b	d1,$12345678

#<data>,<ea>
bset.l    #1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

bset.b    #1,(a1)        ; only .B when operating on other
bset.b    #1,(a1)+    ; addresses. In this case, it is
bset.b    #1,-(a1)    ; possible to specify a bit
bset.b    #1,$1234(a1)    ; between 0 and 7
bset.b    #1,$12(a1,d2.w)
bset.b    #1,$12(a1,d2.l)
bset.b    #1,$12(a1,a2.w)
bset.b    #1,$12(a1,a2.l)
bset.b    #1,$1234.w
bset.b    #1,$12345678

NOTE:
Unfortunately, ASMONE also assembles bset with values greater than
7 (for example, DevPac would give an error).
NEVER give values greater than 7 for bset.b!
See the note on BCHG for more information.

***************************************************************** X N Z V C ***
BTST Bit TeST Dn,<ea> B-L - - * - -
#<data>,<ea>

This instruction tests whether the specified bit is ZERO.
If the destination operand is a data register, then the instruction
is always .L, and you can specify a bit from 0 to 31 with the source operand
.
If the destination operand is a memory byte, then the instruction
is always .B, and you can specify a bit from 0 to 7 with the source operand
.

; Addressing such as BCHG, BSET, BCLR, plus management of the PC register

Example:

Dn,<ea>
btst.l    d1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

btst.b    d1,(a1)        ; only .B when operating on other
btst.b    d1,(a1)+    ; addresses. In this case,
btst.b    d1,-(a1)	; possible to specify a bit
btst.b    d1,$1234(a1)    ; between 0 and 7
btst.b    d1,$12(a1,d2.w)
btst.b    d1,$12(a1,d2.l)
btst.b    d1,$12(a1,a2.w)
btst.b    d1,$12(a1,a2.l)
btst.b    d1,$1234.w
btst.b    d1,$12345678

btst.b    d1,label(pc)        ; BTST can also do
btst.b    d1,label(pc,d2.w)    ; relative addressing
btst.b    d1,label(pc,d2.l)    ; to the PC used as destination!!!
btst.b    d1,label(pc,a2.w)
btst.b    d1,label(pc,a2.l)

#<data>,<ea>
btst.l    #1,d2        ; only .L when operating on a
; DATA register. In this case, it is
; possible to specify a bit
; between 0 and 31

btst.b    #1,(a1)        ; only .B when operating on other
btst.b    #1,(a1)+    ; addresses. In this case, it is
btst.b    #1,-(a1)    ; possible to specify a bit
btst.b    #1,$1234(a1)    ; between 0 and 7
btst.b    #1,$12(a1,d2.w)
btst.b    #1,$12(a1,d2.l)
btst.b    #1,$12(a1,a2.w)
btst.b    #1,$12(a1,a2.l)
btst.b    #1,$1234.w
btst.b    #1,$12345678

btst.b    #1,label(pc)        ; BTST can also do
btst.b    #1,label(pc,d2.w)    ; relative addressing
btst.b	#1,label(pc,d2.l)    ; to the PC used as destination!!!
btst.b    #1,label(pc,a2.w)
btst.b    #1,label(pc,a2.l)

NOTE:
unfortunately, ASMONE also assembles btst with values greater than
7 (for example, DevPac would give an error).
NEVER give values greater than 7 for btst.b!
See the note on BCHG for further information.

***************************************************************** X N Z V C ***
BSR Branch to SubRoutine BSR.S <label> BW- - - - - -
BSR.W <label>

This instruction jumps to the label like a JSR and returns when it finds
the end of the subroutine (the rts).
FLAG: no flags are changed

bsr.s    label    ; possible .s (i.e. .b) or .w (NOT .L!)

***************************************************************** X N Z V C ***
CHK CHecK Dn Against Bounds <ea>,Dn -W- - * U U U

This instruction checks whether the 16-bit value contained in the
destination data register is less than zero or greater
than a specified source operand. If the value is within the limits,
 the next instruction is executed; otherwise, an
Exception is generated, however this instruction is NEVER used and
only sends everything into GURU MEDITATION... it is useless, do not use it.

***************************************************************** X N Z V C ***
CLR CLeaR (clear) <ea> BWL - 0 1 0 0

This instruction clears the destination, like a move.x #0,<ea>
FLAG: eXtend unchanged, Zero =1, the others cleared

E.g.:

<ea>
clr.b    d1    ; possible .b, .w and .l
clr.w    (a1)
clr.b    (a1)+
clr.w    -(a1)
clr.l    $1234(a1)
clr.w    $12(a1,d2.w)
clr.b	$12(a1,d2.l)
clr.w	$12(a1,a2.w)
clr.b	$12(a1,a2.l)
clr.w	$1234.w
clr.l	$12345678

***************************************************************** X N Z V C ***
CMP CoMPare (compare) <ea>,Dn BWL - * * * *

Compare the source with a data register by means of a subtraction.
Please note that if you want to check which of the
two operands is greater with BMI, BPL, BHI etc., which is the
destination operand, OP2, which is compared with the source (OP1).
You can see this better in the Bcc
FLAG instruction: eXtend unchanged, the others depending on the comparison.

Ex:

<ea>,Dn
cmp.b    d1,d0
cmp.w    a1,d0        ; note: cmp.b is not possible with Ax
cmp.w    (a1),d0
cmp.b    (a1)+,d0
cmp.w    -(a1),d0
cmp.l    $1234(a1),d0
cmp.w    $12(a1,d2.w),d0
cmp.l    $12(a1,d2.l),d0
cmp.w    $12(a1,a2.w),d0
cmp.l	$12(a1,a2.l),d0
cmp.w	$1234.w,d0
cmp.b	$12345678,d0
cmp.w    label(pc),d0
cmp.l    label(pc,d2.w),d0
cmp.w    label(pc,d2.l),d0
cmp.b    label(pc,a2.w),d0
cmp.w    label(pc,a2.l),d0

***************************************************************** X N Z V C ***
CMPA CoMPare Address <ea>,An -WL - * * * *

This instruction works like CMP, but is dedicated to comparisons
with address registers, so CMPA.B is not possible.
Addresses should be considered as unsigned numbers, so
use Bcc for these numbers:

beq.s    label    ; OP2 = OP1
bne.w    label    ; OP2 >< OP1
bhi.s    label    ; OP2 > OP1
bcc.s    label    ; OP2 >= OP1 - also called *‘BHS’*
bls.w    label    ; OP2 <= OP1
bcs.w    label    ; OP2 < OP1 - also known as *‘BLO’*

FLAG: eXtend unchanged, the others depending on the comparison.

Tip: ALWAYS use the .L extension

E.g.:

<ea>,An
cmpa.l    d1,a0        ; note: cmpa.b is not possible!!
cmpa.l    a1,a0
cmpa.l    (a1),a0
cmpa.l    (a1)+,a0
cmpa.l    -(a1),a0
cmpa.l    $1234(a1),a0
cmpa.l    $12(a1,d2.w),a0
cmpa.l	$12(a1,d2.l),a0
cmpa.l	$12(a1,a2.w),a0
cmpa.l	$12(a1,a2.l),a0
cmpa.l	$1234.w,a0
cmpa.l	$12345678,a0
cmpa.l	label(pc),a0
cmpa.l    label(pc,d2.w),a0
cmpa.l    label(pc,d2.l),a0
cmpa.l    label(pc,a2.w),a0
cmpa.l    label(pc,a2.l),a0

cmpa.l    #$1234,a1    ; note: to compare an #immediate
; with an Ax address register, use
; the cmpa instruction, not cmpi.

Note that if you do a CMPA.W xxxx,ax, you compare
32 bits, and not 16, as might appear from the .w we decide on.
The 16-bit source operand is sign-extended to 32 bits, i.e.
the value of the sign bit, 15, will be copied to bits 16 to 31.
For example:

lea    $1234,a0
CMPA.W    #$1234,a0    ; cmp $00001234 , a0
beq.s    SaltaLabel

In this case, the number is positive, in 2's complement, so
the high bit is zero and all the others (from 16 to 31) are set to zero,
and we jump to jump label, as they are equal.
In this case, however:

lea    $9200,a0
CMPA.W    #$9200,a0    ; cmp $FFFF9200 , a0, because $9200 in
; SIGNED .w is negative (-28672)
beq.s    JumpLabel

In this case, $9200 is extended to longword, and being negative in
signed notation, the high bits are filled with 1, so it compares
between $FFFF9200 and $9200, and does not jump to SaltaLabel. Using
a CMPA.L #$9200,a0 instead, we would have obtained the jump.
As you can see, for numbers below $7fff there are no differences
between CMPA.L and CMPA.W, while there are for higher numbers. WARNING!

***************************************************************** X N Z V C ***
CMPI CoMPare Immediate #<data>,<ea> BWL - * * * *

This instruction is like CMP, but is dedicated to comparing
an #immediate (a constant number) with the destination.
This is done by subtracting the #Immediate operand from the destination,
the result of this operation changes the flags accordingly.
FLAGS: eXtend unchanged, the others depending on the comparison.

Ex:

<data>,<ea>
cmpi.w    #$1234,        d1	; the destinations have been
cmpi.l    #$12345678,    (a1)    ; spaced for greater
cmpi.b    #$12,        (a1)+    ; readability
cmpi.w    #$1234,		-(a1)
cmpi.l    #$12345678,    $1234(a1)
cmpi.b    #$12,        $12(a1,d2.w)
cmpi.w    #$1234,        $12(a1,d2.l)
cmpi.b    #$12,        $12(a1,a2.w)
cmpi.l    #$12345678,    $12(a1,a2.l)
cmpi.w    #$1234,		$1234.w
cmpi.b    #$12,        $12345678

cmpa.w    #$1234,a1    ; note: to compare an #immediate
; with an Ax address register, use
; the cmpa instruction, not cmpi.

***************************************************************** X N Z V C ***
CMPM CoMPare Memory (Ay)+,(Ax)+ BWL - * * * *

This instruction is used to compare memory locations.
FLAG: eXtend is not modified, the others are modified according to the operation.

E.g.:

(Ay)+,(Ax)+
cmpm.w    (a0)+,(a1)+    ; cmpm.b, cmpm.w and cmpm.l are also possible

It can be used to replace a routine of this type:

move.w    (a0)+,d0
cmp.w    (a1)+,d0

***************************************************************** X N Z V C ***
DBcc Looping Instruction DBcc Dn,<label> -W- - - - - -

This instruction is basically used to create LOOPS, i.e.
cycles, in which the number of cycles is regulated by a
DATA register that is decremented for each cycle.
The instruction allows the use of all cc as Bcc, but is almost always
used in the DBRA form (also called DBF), which executes the loop
each time without checking the condition codes.
To create complicated loops, however, all cc can be used.
Please note that, unlike Bcc, DBcc jumps to the
label only if the condition is FALSE!
FLAG: No flags are modified


Ex:    (See Bcc for a description of the cc)

DBcc Dn,<label>
dbra    d0,label    ; also known as DBF, indicates to jump
; to label each time, until the
; counter d0 is exhausted

dbhi    d0,label ; > for unsigned numbers
dbgt    d0,label ; > for signed numbers
dbcc    d0,label ; >= for unsigned numbers - also called DBHS
dbge    d0,label ; >= for signed numbers
dbeq    d0,label ; = for all numbers
dbne    d0,label ; >< for all numbers
dbls    d0,label ; <= for unsigned numbers
dble    d0,label ; <= for signed numbers
dbcs    d0,label ; < for unsigned numbers - also called DBLO
dblt    d0,label ; < for signed numbers
dbpl    d0,label ; If Negative = 0 (PLus)
dbmi    d0,label ; If Negative = 1, (Minus) signed numbers
dbvc    d0,label ; V=0, no OVERFLOW
dbvs    d0,label ; V=1 OVERFLOW

***************************************************************** X N Z V C ***
DIVS DIVide Signed <ea>,Dn -W- - * * * 0

Signed binary division. One of the SLOWEST instructions.
The destination operand, the 32-bit dividend, is divided
by the 16-bit source (divisor), just like DIVU.
It is an integer division, since the
decimal point is not available. For example, if you execute 5:2, the result is 2, remainder 1.
The result, placed in the destination data register, is a long
number broken into 2 words, containing the quotient and the remainder.
The quotient is stored in the lower 16 bits (0-15)
The remainder of the division is stored in the upper 16 bits (16-31)
and is assigned the sign of the dividend.
The difference with DIVU is only that
binary arithmetic with SIGN (2's complement) is respected
In the case of division by zero, the computer goes into GURU mode, in fact
the vector exception at location $14 is executed
FLAG: The eXtend is not modified, the Carry is reset, while
the others are modified according to the quotient.
Note that if the result is too large to be contained
in the lower word of the register (if the quotient exceeds the limit +32767
-32768 of signed numbers), the oVerflow flag is set, so
it must be checked after the division to ensure that the
result is correct, since if it is not correct, the operands are not
modified.

Example:

<ea>,Dn
divs.w    d1,d0        ; only possible .w
divs.w    (a1),d0
divs.w    (a1)+,d0
divs.w	-(a1),d0
divs.w	$1234(a1),d0
divs.w	$12(a1,d2.w),d0
divs.w	$12(a1,d2.l),d0
divs.w	$12(a1,a2.w),d0
divs.w	$12(a1,a2.l),d0
divs.w	$1234.w,d0
divs.w	$12345678,d0
divs.w    label(pc),d0
divs.w    label(pc,d2.w),d0
divs.w    label(pc,d2.l),d0
divs.w    label(pc,a2.w),d0
divs.w    label(pc,a2.l),d0
divs.w    #$1234,d0

note: it is not possible to use an An address register as an operand

Let's try to perform a division:

moveq    #-33,d0    ; 32-bit SIGNED number to be divided
moveq    #5,d1    ; divisor
divs    d1,d0	; divide d0 into d1 parts, i.e. 33/5

the result, in d0, is $FFFDFFFA, where $FFFD = -3, and $FFFA = -6,
in fact -33 divided by 5 is -6, remainder -3. The remainder is negative because
the sign of the remainder is always that of the dividend.

***************************************************************** X N Z V C ***
DIVU DIVide Unsigned <ea>,Dn -W- - * * * 0

Unsigned binary division. This is one of the most powerful, but also
one of the SLOWEST instructions. It performs a binary division between a
32-bit destination operand (dividend) and a 16-bit source operand
(divisor). The division is performed between unsigned numbers,
and is an integer division, since no decimal point is available.
 For example, if you perform 5:2, the result is 2, remainder 1.
The result of the division, with quotient and remainder, is stored
in the destination data register.
The quotient is stored in the lowest 16 bits (0-15)
In the upper 16 bits (16-31), the remainder of the division is stored
In the case of division by zero, the computer goes into GURU mode, in fact
the vector exception at location $14 is executed
FLAG: The eXtend is not modified, the Carry is reset, while
the others are modified according to the quotient.
Note that if the result is too large to be contained
in the low word of the register, the overflow flag is set,
so it must be checked after the division to ensure that
the result is correct. If it is not correct, the operands are not
modified and only the overflow flag is set.

E.g.:

<ea>,Dn
divu.w    d1,d0        ; only possible .w
divu.w    (a1),d0
divu.w    (a1)+,d0
divu.w    -(a1),d0
divu.w    $1234(a1),d0
divu.w    $12(a1,d2.w),d0
divu.w    $12(a1,d2.l),d0
divu.w    $12(a1,a2.w),d0
divu.w    $12(a1,a2.l),d0
divu.w    $1234.w,d0
divu.w    $12345678,d0
divu.w    label(pc),d0
divu.w    label(pc,d2.w),d0
divu.w    label(pc,d2.l),d0
divu.w    label(pc,a2.w),d0
divu.w    label(pc,a2.l),d0
divu.w    #$1234,d0

note: it is not possible to use an An address register as an operand

Let's try to perform a division:

moveq    #33,d0    ; 32-bit number to be divided
moveq    #5,d1    ; divisor
divu.w    d1,d0    ; divide d0 into d1 parts, i.e. 33/5

The result, in d0, is $00030006, because 33 divided by 5 is 6, with a remainder of 3.

***************************************************************** X N Z V C ***
EOR Exclusive OR Dn,<ea> BWL - * * 0 0

This instruction performs a bitwise exclusive OR on the destination.
In practice, the result bit is 1 only if the operands are different.
Here is the table of results, which highlights the difference with OR:

0 EOR 0 = 0
0 EOR 1 = 1
1 EOR 0 = 1
1 EOR 1 = 0    ; This is the difference with OR! In fact, 1 OR 1 = 1.

Some examples:

0000000001 EOR 1101011101 = 1101010000 - 1 bit reset
1000000000 EOR 0010011000 = 1010011000 - 1 bit set

Therefore, it sets the bit only when it is 1 or the first or second bit,
not when both are 1, as the OR does.
FLAG: eXtend unchanged, oVerflow and Carry reset, Negative and Zero
changed according to the result of the operation

Ex:

Dn,<ea>
eor.b	d1,d2        ; possible .b, .w, .l
eor.w    d1,(a1)
eor.b    d1,(a1)+
eor.w    d1,-(a1)
eor.l    d1,$1234(a1)
eor.w	d1,$12(a1,d2.w)
eor.l	d1,$12(a1,d2.l)
eor.w	d1,$12(a1,a2.w)
eor.b	d1,$12(a1,a2.l)
eor.l	d1,$1234.w
eor.w	d1,$12345678

***************************************************************** X N Z V C ***
EORI Exclusive OR Immediate #<data>,<ea> BWL - * * 0 0


Like EOR, but specific to #Immediate as the source.
FLAG: eXtend unchanged, oVerflow and Carry reset, Negative and Zero
modified according to the outcome of the operation

E.g.:

#<data>,<ea>
eori.w    #$1234,        d1    ; the destinations have been
eori.b    #$12,        (a1)	; spaced for greater
eori.w    #$1234,        (a1)+    ; readability
eori.b    #$12,        -(a1)
eori.l    #$12345678,    $1234(a1)
eori.w    #$1234,        $12(a1,d2.w)
eori.b    #$12,		$12(a1,d2.l)
eori.l    #$12345678,    $12(a1,a2.w)
eori.b    #$12,        $12(a1,a2.l)
eori.w    #$1234,		$1234.w
eori.l    #$12345678,    $12345678

eori.b    #$12,ccr
eori.w    #$1234,sr    ; *** PRIVILEGED INSTRUCTION ***

***************************************************************** X N Z V C ***
EXG Exchange any two registers Rx,Ry --L - - - - -

Exchange the contents of 2 registers, both addresses and data.
FLAG: nessuno viene modificato

Es:

Rx,Ry
exg	d0,d1
exg	d0,a1
exg	a0,a1

***************************************************************** X N Z V C ***
EXT Sign EXTend Dn -WL - * * 0 0

This instruction ‘EXTEND’ a number with SIGN contained in a
data register. Used for negative numbers in particular,
as it simply ‘fills’ bits 8 to 15 (if EXT.W) or bits
16 to 31 (if EXT.L) by ‘replicating’ the sign bit (7 if EXT.W, or
15 if EXT.L). EXT.W ‘converts’ from .b to .w, EXT.L from .w to .l
By setting all bits as the sign bit, you get
the same number (especially if negative) even in .w or .l format,
starting from a .b. Let's take an example: d0=$000000FB. We know that
$FB is -5 if we are in the signed byte field, but in the .w or .l field it is
simply $FB=251 positive. With an EXT.W d0 we obtain
d0 = $0000FFFB, so $FFFB is -5 in the signed .w field.
With an EXT.L, we can now obtain $FFFFFFFB, which is -5 in the .l field
with a sign!

Example:

Dn
ext.w    d0    ; converts from .b to .w
ext.l    d0    ; converts from .w to .l

To extend a byte to a longword, you must first perform an ext.w, then an
ext.l . For example:

move.b    #$80,d0        ; d0.b = -128
ext.w    d0        ; d0.w = $ff80 (-128.w)
ext.l    d0        ; d0.l = $ffffff80 (-128.l)

***************************************************************** X N Z V C ***
JMP JuMP to Affective Address <ea> - - - - -

Jump to the destination routine, similar to BRA.
FLAG: None are modified.

Example:

<ea>
jmp    (a1)
jmp    $1234(a1)
jmp    $12(a1,d2.w)
jmp    $12(a1,d2.l)
jmp    $12(a1,a2.w)
jmp	$12(a1,a2.l)
jmp	$1234.w
jmp	$12345678
jmp	label(pc)
jmp	label(pc,d2.w)
jmp	label(pc,d2.l)
jmp	label(pc,a2.w)
jmp	label(pc,a2.l)

***************************************************************** X N Z V C ***
JSR Jump to SubRoutine <ea> - - - - -

Jump to the destination subroutine and return once that subroutine has finished
(found the RTS). Instruction similar to BSR
FLAG: No flags are modified

E.g.:

<ea>
jsr    (a1)
jsr    $1234(a1)
jsr    $12(a1,d2.w)
jsr    $12(a1,d2.l)
jsr    $12(a1,a2.w)
jsr    $12(a1,a2.l)
jsr	$1234.w
jsr	$12345678
jsr	aa17(pc)
jsr	label(pc,d2.w)
jsr	label(pc,d2.l)
jsr	label(pc,a2.w)
jsr	label(pc,a2.l)

***************************************************************** X N Z V C ***
LEA Load Effective Address <ea>,An --L - - - - -

Loads an address into an address register An.
For example, after a ‘LEA $10000,a0’, A0=$10000. In this case
the instruction works like a "MOVE.L #$10000,a0‘, but it is faster.
WARNING: the LEA command is different from MOVEA!! In fact, it can be
confusing when we have a ’LEA $12(a0),a1", for example: in a1
goes the address contained in a0 plus the offset, i.e. $12, and not
the content of that address, as would have happened with
indirect addressing. For example, writing ‘LEA $12(a0),a0’ is
equivalent to ‘ADDA.W #$12,a0’.
FLAG: none are modified

Ex:

<ea>,An
lea    (a1),a0		; note: in this case, it copies the value
; of a1 to a0 as a MOVE.L a1,a0!!!
; not to be confused with
; move.l (a1),a0, which is instead
; indirect addressing

lea    $1234(a1),a0    ; In this case, the address
; contained in a0+$1234, do not confuse
; with indirect addressing! It is
; a LEA and not a MOVE!!!!!!!!
lea    $12(a1,d2.w),a0
lea    $12(a1,d2.l),a0
lea    $12(a1,a2.w),a0
lea    $12(a1,a2.l),a0
lea    $1234.w,a0
lea	$12345678,a0
lea	label(pc),a0
lea	label(pc,d2.w),a0
lea	label(pc,d2.l),a0
lea	label(pc,a2.w),a0
lea	label(pc,a2.l),a0

***************************************************************** X N Z V C ***
LSL Logical Shift Left Dx,Dy BWL * * * 0 *
#<1-8>,Dy
<ea>

Logical Shift Left. Shift means a ‘sliding’
of bits, in this case to the left, e.g.: %0001 shifted by 2: %0100
i.e. the bits that make up the number are shifted
to the left; in the case of LSL, the low bits are ‘filled’ with
zeros, while the bits ‘exiting’ from the left are copied
to the Carry and Extend FLAGS. It is practically the same as ASL, the difference
between LOGICAL shift and ARITHMETIC shift can be seen between ASR and LSR, not between
ASL and LSL.
FLAG: the overflow is reset, the extend and carry contain the
high bit that has “exited”, negative and zero are modified according to
the operation.
value that shifts
to the left
------------
Flag X/C <-- |<- <- <- | <--- 0 - A zero enters from the right
------------

; Addressing such as ASL, ASR, LSR, ROL, ROR, ROXL, ROXR

E.g.:

Dx,Dy
lsl.w    d0,d1    ; possible .b, .w and .l, the maximum shift in
; this case is 63 (the first 6 bits
; of the data register)

#<1-8>,Dy
lsl.w    #2,d1    ; possible .b, .w and .l, maximum lsl.x #8,Dy

<ea>
lsl.w    (a1)    ; only .w possible, equivalent to lsl.w #1,<ea>
lsl.w    (a1)+
lsl.w    -(a1)
lsl.w    $1234(a1)
lsl.w    $12(a1,d2.w)
lsl.w    $12(a1,d2.l)
lsl.w    $12(a1,a2.w)
lsl.w	$12(a1,a2.l)
lsl.w    $1234.w
lsl.w    $12345678

***************************************************************** X N Z V C ***
LSR Logical Shift Right Dx,Dy BWL * * * 0 *
#<1-8>,Dy
<ea>

Logical shift right. Shift means a ‘scrolling’
of bits, in this case to the right, e.g.: %0100 shifted by 2: %0001
i.e. the bits that make up the number are scrolled, ‘shift’
to the right. In each shift, the low bit of the destination register
is copied to the Carry and eXtend bits, while the highest bit
is RESET. (unlike the ASR, i.e. the ARITHMETIC SHIFT
to the right, where the highest bit remains UNCHANGED)
FLAG: the overflow is reset, the extend and carry contain the
low bit that has ‘come out’, Negative and Zero are modified according to
the operation.
value that shifts
to the right
------------
A zero enters from the left - 0 --->|-> -> -> ->| ---> Flag X/C
------------

; Addressing such as ASL, ASR, LSL, ROL, ROR, ROXL, ROXR

E.g.:

Dx,Dy
lsr.w    d0,d1    ; possible .b, .w and .l, the maximum shift in
; this case is 63 (the first 6 bits
; of the data register)

#<1-8>,Dy
lsr.w    #2,d1    ; possible .b, .w and .l, maximum lsr.x #8,Dy

<ea>
lsr.w    (a1)    ; only possible .w, equivalent to lsr.w #1,<ea>
lsr.w    (a1)+
lsr.w    -(a1)
lsr.w    $1234(a1)
lsr.w    $12(a1,d2.w)
lsr.w    $12(a1,d2.l)
lsr.w    $12(a1,a2.w)
lsr.w    $12(a1,a2.l)
lsr.w    $1234.w
lsr.w    $12345678

***************************************************************** X N Z V C ***
MOVE Between Effective Addresses <ea>,<ea> BWL - * * 0 0

Copies the contents of the source operand to the destination.
FLAG: eXtend remains unchanged, oVerflow and Carry are reset
Negative and Zero are modified according to the operation.
The list would be too long here, so here are just a few examples:

<ea>,<ea>
move.w	$1234(a1),    (a0)    ; the destinations have been
move.w    $12(a1,a2.w),    (a0)    ; spaced for greater
move.w    $1234.w,    (a0)+    ; readability
move.w    label(pc),    -(a0)
move.w    label(pc,d2.l),    $1234(a1)
move.w    $12(a1,a2.w),    $12(a1,d2.w)
move.w    d1,        $12(a1,a2.w)
move.w    (a1)+,		$12(a1,a2.l)
move.w    -(a1),        $1234.w

note: to ‘move’ directly into an address register, there is
a dedicated command MOVEA (e.g. ‘movea.w d0,a0’). However, the assembler
also accepts a simple move for address registers,
and will assemble MOVEA without any problems.


***************************************************************** X N Z V C ***
MOVE To CCR <ea>,CCR -W- I I I I I

MOVE instruction specifically for modifying the CCR, i.e. the Condition
Code Register, which are the lower 8 bits of SR, those of the condition codes
. It copies the lower 8 bits of the source operand
to the lower 8 bits of SR.
FLAG: Clearly, all are modified, since we are rewriting them!

Ex:

<ea>,CCR
move.w    d1,ccr        ; only .w
...            ; etc., as normal MOVE.

move.w    #0012,ccr    ; only the low byte of the source
; is copied to CCR, which is a BYTE!

***************************************************************** X N Z V C ***
MOVE To SR <ea>,SR -W- I I I I I

*** PRIVILEGED INSTRUCTION! Only execute in supervisor mode! ***

This is a special move to modify the Status Register.
FLAGS: Obviously changed, since CCR is the low byte of SR!

E.g.:

<ea>,SR
move.w    d1,sr        ; only .w...
            ; Etc., like the move

move.w    #$1234,SR

***************************************************************** X N Z V C ***
MOVE From SR SR,<ea> -W- - - - - -

*** PRIVILEGED INSTRUCTION! Only execute in supervisor mode! ***

In reality, it is not privileged on the 68000, but on the 68010/20/30/40/60 it
made privileged, so executing it in user mode would only cause
a GURU on a1200 or other Amigas with 68010 or higher.
Copy the contents of the Status Register to the destination.

E.g.:

SR,<ea>
move.w    sr,d1        ; only .w
move.w    sr,(a1)
move.w    sr,(a1)+
move.w    sr,-(a1)
move.w    sr,$1234(a1)
move.w    sr,$12(a1,d2.w)
move.w    sr,$12(a1,d2.l)
move.w    sr,$12(a1,a2.w)
move.w	sr,$12(a1,a2.l)
move.w	sr,$1234.w
move.w	sr,$12345678

***************************************************************** X N Z V C ***
MOVE USP to/from Address Register USP,An --L - - - - -
An,USP

*** PRIVILEGED INSTRUCTION! Only execute in supervisor mode! ***

Copies the User Stack Pointer, i.e. the pointer to the user mode stack
 (a7) to an address register, or vice versa.

E.g.:

USP,An
move.l    usp,a0

An,USP
move.l    a0,usp

***************************************************************** X N Z V C ***
MOVEA MOVE Address <ea>,An -WL - - - - -

MOVE instruction dedicated to copying to address registers An.
It is therefore not possible to copy in byte length (.b).
Note: the assembler also accepts ‘move’ for ‘movea’,
which ‘move.l d1,a0’ is assembled correctly without errors
in ‘movea.l d1,a0’. Therefore, just write ‘move’ and leave
the task of assembling correctly to ASMONE.
FLAG: None are modified

Tip: always use the .L extension

Example:

<ea>,An
movea.l    d1,a0
movea.l    a1,a0
movea.l	(a1),a0
movea.l    (a1)+,a0
movea.l    -(a1),a0
movea.l    $1234(a1),a0
movea.l    $12(a1,d2.w),a0
movea.l    $12(a1,d2.l),a0
movea.l    $12(a1,a2.w),a0
movea.l    $12(a1,a2.l),a0
movea.l    $1234.w,a0
movea.l    $12345678,a0
movea.l    label(pc),a0
movea.l    label(pc,d2.w),a0
movea.l    label(pc,d2.l),a0
movea.l    label(pc,a2.w),a0
movea.l    label(pc,a2.l),a0

movea.l    #$1234,a0

Please note that if you do a MOVEA.W xxxx,ax,
all 32 bits are copied, not 16, as it might seem from the .w
we enter. The 16-bit source operand is sign-extended
to 32 bits, i.e. the value of the sign bit, 15, will be copied
to bits 16 to 31. For example:

MOVEA.W    #$1234,a0    ; a0=$00001234
MOVEA.W    #$9200,a0	; a0=$FFFF9200, because $9200 in
; SIGNED .w is negative (-28672)
MOVEA.L    #$9200,a0    ; a0=$00009200, but then it is better to
; use: LEA $9200,a0

As you can see, for numbers below $7fff there is no difference
between MOVEA.L and MOVEA.W, while there is a difference for higher numbers.
It is therefore better to use LEA xxxxx,ax for values above $7fff, given
that there is no possibility of error and it is faster.
Be careful in this case too:

move.l    #$a000,d0    ; address in d0
movea.w    d0,a0        ; a0 = $FFFFa000

A movea.l was definitely needed!!!!

***************************************************************** X N Z V C ***
MOVEM MOVE Multiple <register list>,<ea> -WL - - - - -
<ea>,<register list>

This instruction is used to copy a list of registers, data
and/or addresses to a memory area, or vice versa.
The following syntax is used to define the list of addresses: for
consecutive registers, write the first and last of the series
separated by a ‘-’, for example d0-d5 means d0,d1,d2,d3,d4,d5.
For any registers that are not in series, specify them by separating them
from the other ‘isolated’ registers or from the other series with a ‘/’, for
example: d0/d3/d6 indicates registers d0, d3, d6. Let's take a ‘mixed’ case:
d0/d2/d4-d7/a0-a3 indicates registers d0, d2, d4, d5, d6, d7, a0, a1, a2, a3.
If the instruction is .word, the words are copied to the registers from
memory, but are ‘extended’ with a 32-bit sign, i.e. bit 15 of the
sign is repeated to fill bits 16 to 31.

E.g.:

<register list>,<ea>
movem.l    d0/d2/d4/d6/a0/a2,$12345678    ; only .w or .l
movem.w    d0-d3/d6-d7/a6-a7,(a1)
movem.l	d3-d4/d6-d7/a3-a4,-(a1)
movem.w	d0-d7/a0-a1/a3-a4,$1234(a1)
movem.w	d6-d7/a1/a3/a5/a7,$12(a1,d2.w)
movem.l	d0/d2/d4/a3-a4/a6,$12(a1,d2.l)
movem.l	a0-a1/a3-a4/a6-a7,$12(a1,a2.w)
movem.w	d0-d1/d3-d4/d6-d7,$12(a1,a2.l)
movem.l	d0-d1/d3-d4/d6-d7,$1234.w
movem.w	d0-d1/d3-d4/d6-d7,$12345678

<ea>,<register list>
movem.w	(a1),d0-d7/a0-a6
movem.l	(a1)+,d0-d7/a0-a6
movem.w	$1234(a1),d0-d7/a0-a6
movem.l	$12(a1,d2.w),d0-d7/a0-a6
movem.w	$12(a1,d2.l),d0-d7/a0-a6
movem.w	$12(a1,a2.w),d0-d7/a0-a6
movem.l	$12(a1,a2.l),d0-d7/a0-a6
movem.l	$1234.w,d0-d7/a0-a6
movem.w    $12345678,d0-d7/a0-a6
movem.w    label(pc),d0-d7/a0-a6
movem.l    label(pc,d2.w),d0-d7/a0-a6
movem.w    label(pc,d2.l),d0-d7/a0-a6
movem.l    label(pc,a2.w),d0-d7/a0-a6
movem.w    label(pc,a2.l),d0-d7/a0-a6

A frequent use is to save and restore all or
part of the registers in the stack:

movem.l    d0-d7/a0-a6,-(SP)    ; saves all registers in the stack
....
movem.l    (SP)+,d0-d7/a0-a6    ; retrieves all registers from the stack

NOTE: the order of the registers is always the same, first the data registers,
 from smallest to largest, then the address registers. If you
write:

movem.l    a0/d2-d4/a6/a2/d7,-(SP)

In practice, it is assembled in the correct order:

MOVEM.L    D2-D4/D7/A0/A2/A6,-(A7)

Be careful not to restore the
‘swapped’ registers, thinking that they have been restored correctly.

***************************************************************** X N Z V C ***
MOVEP MOVE Peripheral Dn,x(An) -WL - - - - -
x(An),Dn

This MOVE copies the low bytes of the source operand to the destination operand.
 Let's look at some PRACTICAL examples:

Ex 1:

x(An),Dn
movep.w    $1234(a1),d0	; possible .w and .l

Word:
moveq    #0,d0
lea    data(PC),a1
movep.w    0(a1),d0
rts            ; d0 = $00001030

LongWord:
lea    data(PC),a1
movep.l    0(a1),d0
rts            ; d0 = $10305070


data:
dc.l    $10203040
dc.l    $50607080

***    ***    ***    ***

Ex 2:

Dn,x(An)
movep.w    d0,$1234(a1)    ; possible .w and .l

Word:
move.l    #$10203040,d0
lea    data(PC),a1
movep.w    d0,0(a1)
rts            ; 0(a1) = $30004000

LongWord:
move.l    #$10203040,d0
lea    data(PC),a1
movep.l    d0,0(a1)
rts            ; 0(a1) = $10002000 , $30004000

data:
dc.l    $00000000
dc.l    $00000000

This instruction is not used very often, it is mainly used to
communicate with peripherals (apparently). However, it could be useful
for some strange byte shuffling in your programs!
If you are not clear on everything, run Debug on the routines.

***************************************************************** X N Z V C ***
MOVEQ MOVE 8-bit immediate #<-128.+127>,Dn --L - * * 0 0

Move Quick, i.e. FAST MOVE, is an instruction dedicated to loading
a data register with an immediate value between -128 and +127, which
is faster than the usual ‘MOVE.L #Immediate,dn’.
The operation is like a MOVE.L, and it is always advisable to use it when
possible, given its faster execution speed.
FLAG: eXtend remains unchanged, oVerflow and Carry are reset
Negative and Zero are modified according to the operation.

E.g.:

#<-128.+127>,Dn
moveq    #10,d0
moveq    #-10,d0    ; d0 = $FFFFFFF6

***************************************************************** X N Z V C ***
MULS MULtiply Signed <ea>,Dn -W- - * * 0 0

Signed multiplication. Two 16-bit numbers
with sign, which can range from -32768 to +32767, are multiplied, so the maximum
positive value that can be obtained is 1073741824, while the negative value is
-1073709056, so no carry or overflow can occur.
Only the lower word of the source operands is read, so
a number such as $00123456 is read as $00003456.
The 32-bit result is stored in the destination data register.
The sign of the result follows the rules +*+=+, +*-=-, -*+=-, -*-=+.
FLAGS: eXtend remains unchanged, oVerflow and Carry are reset
Negative and Zero are modified according to the operation.

E.g.:

<ea>,Dn
muls.w    d1,d0
muls.w    (a1),d0
muls.w	(a1)+,d0
muls.w	-(a1),d0
muls.w	$1234(a1),d0
muls.w	$12(a1,d2.w),d0
muls.w	$12(a1,d2.l),d0
muls.w	$12(a1,a2.w),d0
muls.w	$12(a1,a2.l),d0
muls.w	$1234.w,d0
muls.w	$12345678,d0
muls.w    label(pc),d0
muls.w    label(pc,d2.w),d0
muls.w    label(pc,d2.l),d0
muls.w    label(pc,a2.w),d0
muls.w    label(pc,a2.l),d0
muls.w    #$1234,d0

note: it is not possible to use an An address register as an operand

***************************************************************** X N Z V C ***
MULU MULtiply Unsigned <ea>,Dn -W- - * * 0 0

Unsigned multiplication. Two 16-bit numbers are multiplied,
the 32-bit result is stored in the destination data register.
On the 68000, only MULU.w is possible, unlike the 68020+.
Only the lower word of the source operands is read, so
a number such as $00123456 is read as $00003456.
Since both the multiplicand and the multiplier are 16-bit,
i.e. max 65535, the product cannot exceed 4294836225, the full long,
 therefore no overflow condition is possible.
FLAG: eXtend remains unchanged, oVerflow and Carry are reset
Negative and Zero are modified according to the operation.

E.g.:

<ea>,Dn
mulu.w    d1,d0
mulu.w    (a1),d0
mulu.w    (a1)+,d0
mulu.w    -(a1),d0
mulu.w    $1234(a1),d0
mulu.w    $12(a1,d2.w),d0
mulu.w    $12(a1,d2.l),d0
mulu.w    $12(a1,a2.w),d0
mulu.w    $12(a1,a2.l),d0
mulu.w    $1234.w,d0
mulu.w    $12345678,d0
mulu.w    label(pc),d0
mulu.w    label(pc,d2.w),d0
mulu.w    label(pc,d2.l),d0
mulu.w    label(pc,a2.w),d0
mulu.w    label(pc,a2.l),d0
mulu.w    #$1234,d0

note: it is not possible to use an An address register as an operand

***************************************************************** X N Z V C ***
NEG NEGate <ea> BWL * * * * *

This instruction performs negation, i.e. subtracts the destination operand
from 0, making it negative. (e.g. 0-5 = -5!!!).

E.g.:

<ea>
neg.w    d1
neg.b    (a1)
neg.w    (a1)+
neg.l    -(a1)
neg.w    $1234(a1)
neg.b    $12(a1,d2.w)
neg.w	$12(a1,d2.l)
neg.b	$12(a1,a2.w)
neg.w	$12(a1,a2.l)
neg.l	$1234.w
neg.w	$12345678

***************************************************************** X N Z V C ***
NEGX NEGate with eXtend <ea> BWL * * * * *

The only difference with NEG is that the
eXtend flag is also subtracted from 0.

***************************************************************** X N Z V C ***
NOP No OPeration NOP - - - - -

This ‘nonsense’ instruction only serves to occupy ‘space’,
specifically one word ($4e71), since nothing happens when it is executed,
and not even the FLAGS are modified. In truth, its main use
is to ‘NOP’, i.e. to copy $4e71, or NOPs,
over the various SUBQ.W #1,VITE, to create TRAINERS.
Woe betide you if you think you can generate delays by putting a string of
NOPs or a DBRA cycle of NOPs! On fast processors, such delays
would ‘disappear’; only use VBLANK or the CIA timer for timing!

E.g.:
nop

***************************************************************** X N Z V C ***
NOT Complement to 1 <ea> BWL - * * 0 0

Logical NOT of the destination. NOT reverses the destination bit by bit
:

NOT 0 = 1
NOT 1 = 0

For example, $12, i.e. %00010010, would become %11101101
FLAG: the eXtend remains unchanged, the oVerflow and Carry are reset
the Negative and Zero are modified according to the operation.

E.g.:

<ea>
not.b    d1
not.w    (a1)
not.w    (a1)+
not.l    -(a1)
not.w    $1234(a1)
not.l    $12(a1,d2.w)
not.w	$12(a1,d2.l)
not.b	$12(a1,a2.w)
not.l	$12(a1,a2.l)
not.w	$1234.w
not.l	$12345678

***************************************************************** X N Z V C ***
OR Bit-wise OR <ea>,Dn BWL - * * 0 0
Dn,<ea>

Bitwise logical OR of the source with the destination, result
in the destination. Here is the OR table:

0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1

EITHER ONE OR THE OTHER BIT MUST BE 1 TO GIVE 1, in practice.
It can be used to set bits (unlike AND, which
is useful for clearing them). For example, an OR.B #%00001111,d0 has the
effect of setting the 4 low bits and leaving the 4 high bits unchanged.
FLAG: the eXtend remains unchanged, the oVerflow and Carry are reset
Negative and Zero are modified according to the operation.

E.g.:

Dn,<ea>
or.w    d0,d1
or.b    d0,(a1)
or.w    d0,(a1)+
or.b    d0,-(a1)
or.w    d0,$1234(a1)
or.l    d0,$12(a1,d2.w)
or.w    d0,$12(a1,d2.l)
or.b    d0,$12(a1,a2.w)
or.w    d0,$12(a1,a2.l)
or.l    d0,$1234.w
or.w    d0,$12345678

<ea>,Dn
or.l    d1,d0
or.w    (a1),d0
or.w    (a1)+,d0
or.b    -(a1),d0
or.w    $1234(a1),d0
or.b    $12(a1,d2.w),d0
or.w	$12(a1,d2.l),d0
or.l    $12(a1,a2.w),d0
or.w    $12(a1,a2.l),d0
or.l    $1234.w,d0
or.b    $12345678,d0
or.w    label(pc),d0
or.w	label(pc,d2.w),d0
or.l	label(pc,d2.l),d0
or.w	label(pc,a2.w),d0
or.b	label(pc,a2.l),d0

***************************************************************** X N Z V C ***
ORI Bit-wise OR with Immediate #<data>,<ea> BWL - * * 0 0


Bitwise logical OR of the source with the destination, result
in the destination. Here is the OR table:

0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1

EITHER ONE OR THE OTHER BIT MUST BE 1 TO GIVE 1, in practice.
It can be used to set bits (unlike AND, which
is useful for clearing them). For example, an OR.B #%00001111,d0 has the
effect of setting the 4 low bits and leaving the 4 high bits unchanged.
FLAG: the eXtend remains unchanged, the oVerflow and Carry are reset
the Negative and Zero are modified according to the operation.

E.g.:

#<data>,<ea>
ori.w    #$1234,        d1    ; the destinations have been
ori.b	#$12,        (a1)    ; spaced for greater
ori.w    #$1234,        (a1)+    ; readability
ori.l    #$12345678,    -(a1)
ori.w    #$1234,        $1234(a1)
ori.b    #$12,		$12(a1,d2.w)
ori.w	#$1234,		$12(a1,d2.l)
ori.l    #$12345678,    $12(a1,a2.w)
ori.b    #$12,        $12(a1,a2.l)
ori.w    #$1234,        $1234.w
ori.b    #$12,		$12345678

ori.b    #$12,ccr
ori.w    #$1234,sr    ; *** PRIVILEGED INSTRUCTION

***************************************************************** X N Z V C ***
PEA Push Effective Address <ea> --L - - - - -

Loads an address into the stack. Like a MOVE.L #Ind,-(SP), so
to speak. Note that the stack is updated to
4 bytes further back, like MOVE.L #ind,-(SP).
One use could be this, for example:

PEA    Copperlist(PC)
MOVE.L    (SP)+,$dff080

But why bother using the stack to point to a copperlist?
In fact, this instruction is not used very often.

E.g.:

<ea>
pea    (a1)
pea    $1234(a1)
pea    $12(a1,d2.w)
pea    $12(a1,d2.l)
pea    $12(a1,a2.w)
pea    $12(a1,a2.l)
pea    $1234.w
pea    $12345678
pea    label(pc)
pea    label(pc,d2.w)
pea    label(pc,d2.l)
pea    label(pc,a2.w)
pea    label(pc,a2.l)

***************************************************************** X N Z V C ***
ROL ROtate Left #<1-8>,Dy BWL - * * 0 *
Dx,Dy
<ea>

Left rotation of bits. Performs a shift like LSL, but in this
case the bits are ‘rotated’, i.e. the bits that ‘come out’ on the left
end up in the Carry, but are then copied to the right into the empty space
,
 unlike LSL where the ‘new’ bits on the right are reset.
For example, given %11100001, with a ROL #2 we will have %10000111.
(with LSL we would have had %10000100).
FLAG: eXtend unchanged, oVerflow reset, the others changed
depending on the operation. (In carry, the high bit)

value that shifts
to the left
------------
Flag C <---+<--|<- <- <- <-|<-+
| ------------ |
\_>____>_____>___/
The bit that exits on the left re-enters on the right!

; Addressing such as ASL, ASR, LSL, LSR, ROR, ROXL, ROXR

Ex:

Dx,Dy
rol.w    d0,d1	; possible .b, .w, .l, maximum shift in
; this case is 63 (the first 6 bits
; of the data register are used)

#<1-8>,Dy
rol.w    #2,d1    ; possible .b, .w, .l, maximum rol.x #8,Dy

<ea>
rol.w    (a1)    ; only .w possible; write rol.w #1,<ea>
rol.w    (a1)+    ; is equivalent
rol.w    -(a1)
rol.w    $1234(a1)
rol.w    $12(a1,d2.w)
rol.w    $12(a1,d2.l)
rol.w    $12(a1,a2.w)
rol.w    $12(a1,a2.l)
rol.w    $1234.w
rol.w    $12345678

***************************************************************** X N Z V C ***
ROR ROtate Right #<1-8>,Dy BWL - * * 0 *
Dx,Dy
<ea>

Rotates the bits to the right. Performs a shift like LSR, but in this
case the bits are ‘rotated’, i.e. the bits that ‘exit’ on the right
end up in the Carry, but are then copied to the left into the empty space,
 unlike LSR where the new bits on the left are cleared.
For example, having %10000111, with a ROR #2 we will have %11100001.
(with LSR we would have had %00100001).
FLAG: eXtend unchanged, oVerflow reset, the others changed
depending on the operation. (In carry, the high bit)

value that shifts
to the right
------------
+-->|-> -> -> ->|--+--> Flag C
| ------------ |
\_<____<_____<____/
The bit that exits on the right re-enters on the left!

; Addressing such as ASL, ASR, LSL, LSR, ROL, ROXL, ROXR

; as above

Ex:

Dx,Dy
ror.w    d0,d1    ; possible .b, .w, .l, the maximum shift in
; this case is 63 (the first 6 bits
; of the data register are used)

#<1-8>,Dy
ror.w    #2,d1    ; possible .b, .w, .l, maximum ror.x #8,Dy

<ea>
ror.w    (a1)	; only .w possible, equivalent to ROR #1,<ea>
ror.w    (a1)+
ror.w    -(a1)
ror.w    $1234(a1)
ror.w    $12(a1,d2.w)
ror.w    $12(a1,d2.l)
ror.w    $12(a1,a2.w)
ror.w    $12(a1,a2.l)
ror.w    $1234.w
ror.w    $12345678

***************************************************************** X N Z V C ***
ROXL ROtate Left with eXtend #<1-8>,Dy BWL * * * 0 *
Dx,Dy
<ea>

Instruction like ROL, except that the most significant bit that is
shifted ends up in the eXtend, as well as in the Carry.
Used for multiple precision shifts, since the eXtend flag enters
from the right: just have the carry from a previous shift,
with a ROXL you will continue that shift considering the eXtend flag
previously generated.
In addition, the X flag behaves like the ‘ninth’ bit of the register (if .B)
or the ‘seventeenth’ if in .w, or the ‘thirty-second’ in .L, and
participates in the rotation, returning to the register.

value that shifts the X flag is updated
to the left /
------------ /
Flag C <---+<--|<- <- <- <-|<--|X|-<-+
| ------------     |
\_>____>_____>____>__>__/
The bit that exits on the left re-enters on the right!

; Addressing such as ASL, ASR, LSL, LSR, ROL, ROR, ROXR

***************************************************************** X N Z V C ***
ROXR ROtate Right with eXtend #<1-8>,Dy BWL * * * 0 *
Dx,Dy
<ea>

Instruction like ROR, except that the least significant bit that is
shifted ends up in the eXtend, as well as in the Carry.
In addition, the X flag behaves like the ‘ninth’ bit of the register (if .B)
or the ‘seventeenth’ if in .w, or the ‘thirty-second’ in .L, and
participates in the rotation, returning to the register.

Used for multiple precision shifts

X flag updated     value that shifts
\ to the right
\ ------------
+->-|X|-->|-> -> -> ->|--+--> C flag
|      ------------ |
\__<___<____<_____<____/
The bit that exits on the right re-enters on the left!

***************************************************************** X N Z V C ***
RTE ReTurn from Exception RTE I I I I I

Returns from an exception, trap or interrupt.
Flags modified by the immediate data

E.g.:
rte

***************************************************************** X N Z V C ***
RTR ReTurn and Restore RTR I I I I I

Return with restoration of the CCR byte

E.g.:
rtr

***************************************************************** X N Z V C ***
RTS Return from Subroutine RTS - - - - -

Returns from a BSR or JSR. No flags modified

E.g.:
rts

***************************************************************** X N Z V C ***
Scc Set to -1 if True, 0 if False <ea> B-- - - - - -

This instruction SETS all bits of a byte (transforms it to $FF),
provided that the cc conditions are met, otherwise it RESETS
that byte ($00). There are two instructions that always set or reset
that byte: ST is the first and SF is the second.

Example:    (See Bcc for a description of cc)

<ea>
st.b    d1    ; Only .b - Always set, ALWAYS SET
st.b    (a1)
st.b    (a1)+
st.b    -(a1)
st.b    $1234(a1)
st.b    $12(a1,d2.w)
st.b	$12(a1,d2.l)
st.b	$12(a1,a2.w)
st.b	$12(a1,a2.l)
st.b	$1234.w
st.b	$12345678

The same addresses for:

sf    <ea>    ; only .b, Never Set, ALWAYS RESET

shi.s    <ea>    ; > for unsigned numbers
sgt.w    <ea>    ; > for signed numbers
scc.s    <ea>    ; >= for unsigned numbers - also called SHS
sge.s    <ea>	; >= for signed numbers
seq.s    <ea>    ; = for all numbers
sne.w    <ea>    ; >< for all numbers
sls.w    <ea>    ; <= for unsigned numbers
sle.w    <ea>	; <= for signed numbers
scs.w    <ea>    ; < for unsigned numbers - also known as SLO
slt.w    <ea>	; < for signed numbers
spl.w    <ea>    ; If Negative = 0 (PLus)
smi.s    <ea>    ; If Negative = 1, (Minus) signed numbers
svc.w    <ea>    ; V=0, no OVERFLOW
svs.s    <ea>    ; V=1 OVERFLOW

***************************************************************** X N Z V C ***
STOP Enable & wait for interrupts #<data> I I I I I

E.g.:
stop    #$1234

***************************************************************** X N Z V C ***
SUB SUBtract binary Dn,<ea> BWL * * * * *
<ea>,Dn

This instruction subtracts the source operand
from the destination operand and saves the result in the destination operand
.
The flags are modified according to the outcome of the operation.
The C (Carry) flag is set if the subtraction results in a borrow
(i.e., the result does not ‘fit’ into the destination operand).


Example:

Dn,<ea>
sub.b    d0,d1
sub.w    d0,(a1)
sub.l    d0,(a1)+
sub.w    d0,-(a1)
sub.w    d0,$1234(a1)
sub.l    d0,$12(a1,d2.w)
sub.w    d0,$12(a1,d2.l)
sub.w    d0,$12(a1,a2.w)
sub.w    d0,$12(a1,a2.l)
sub.b    d0,$1234.w
sub.l    d0,$12345678

<ea>,Dn
sub.w    d1,d0
sub.l    a1,d0
sub.w    (a1),d0
sub.b    (a1)+,d0
sub.w    -(a1),d0
sub.b	$1234(a1),d0
sub.w	$12(a1,d2.w),d0
sub.l	$12(a1,d2.l),d0
sub.w	$12(a1,a2.w),d0
sub.l    $12(a1,a2.l),d0
sub.w    $1234.w,d0
sub.b    $12345678,d0
sub.w    label(pc),d0
sub.b	label(pc,d2.w),d0
sub.w	label(pc,d2.l),d0
sub.l	label(pc,a2.w),d0
sub.w	label(pc,a2.l),d0

***************************************************************** X N Z V C ***
SUBA SUBtract binary from An <ea>,An -WL - - - - -

SUB operation specific to address registers. Therefore, it is not possible to
use the .b extension.
No flags are modified

Tip: ALWAYS use the .L extension

Example:

<ea>,An
suba.l    d1,a0
suba.l    a1,a0
suba.l    (a1),a0
suba.l    (a1)+,a0
suba.l    -(a1),a0
suba.l    $1234(a1),a0
suba.l	$12(a1,d2.w),a0
suba.l    $12(a1,d2.l),a0
suba.l    $12(a1,a2.w),a0
suba.l    $12(a1,a2.l),a0
suba.l	$1234.w,a0
suba.l	$12345678,a0
suba.l	label(pc),a0
suba.l    aa45(pc,d2.w),a0
suba.l    aa45(pc,d2.l),a0
suba.l    aa45(pc,a2.w),a0
suba.l    aa45(pc,a2.l),a0

suba.l    #$1234,a1    ; note: for the subtraction of an
; #immediate from Ax address registers
; SUBA is used instead of SUBI
; See the comment on ADDA for the
; meaning of .w and .l
; in this case.

***************************************************************** X N Z V C ***
SUBI SUBtract Immediate #x,<ea> BWL * * * * *

SUB version specific for subtracting an #Immediate
The flags are modified according to the outcome of the operation
The C (Carry) flag is set if the subtraction produces a borrow
(i.e. the result does not “fit” into the destination operand).

Example:

#x,<ea>
subi.l    #$12345678,    d1    ; the destinations have been
subi.b    #$12,        (a1)	; separated by greater than
subi.w    #$1234,        (a1)+    ; readability
subi.w    #$1234,        -(a1)
subi.b    #$12,        $1234(a1)
subi.l    #$12345678,    $12(a1,d2.w)
subi.w    #$1234,        $12(a1,d2.l)
subi.b    #$12,        $12(a1,a2.w)
subi.l    #$12345678,    $12(a1,a2.l)
subi.b    #$12,        $1234.w
subi.b    #$12,        $12345678

suba.w    #$1234,a1    ; note: for the subtraction of an
; #immediate from Ax address registers
; SUBA is used instead of SUBI

***************************************************************** X N Z V C ***
SUBQ SUBtract 3-bit immediate #<data>,<ea> BWL * * * * *

This means SUB Quick, i.e. fast subtraction of a number from 1 to 8,
which works exactly like SUBI, so it is always best to use
SUBQ instead of SUBI for subtracting numbers from 1 to 8, since
this dedicated instruction exists. The flags behave like ADD/SUB:
The C (Carry) flag is set if the subtraction produces a borrow
(i.e. the result does not ‘fit’ into the destination operand).
Negative = 1 if the result is negative, Negative = 0 if it is positive.
oVerflow = 1 if the result exceeds the .b, .w or .l size of the ADD
Zero = 1 if the result is zero

Example:

#<data>,<ea>
subq.b    #1,d1
subq.w    #1,a1    ; not possible in .b on the Ax address register!
subq.w    #1,(a1)
subq.b    #1,(a1)+
subq.w    #1,-(a1)
subq.l    #1,$1234(a1)
subq.w    #1,$12(a1,d2.w)
subq.b    #1,$12(a1,d2.l)
subq.w    #1,$12(a1,a2.w)
subq.b    #1,$12(a1,a2.l)
subq.w    #1,$1234.w
subq.l	#1,$12345678

***************************************************************** X N Z V C ***
SUBX SUBtract eXtended Dy,Dx BWL * * * * *
-(Ay),-(Ax)

SUB instruction with ‘extended’ precision, since it subtracts the source operand and the eXtend bit from the destination operand. See ADDX.
Ex:


Dy,Dx subx.w    d0,d1    ; possible .b, .w and .l -(Ay),-(Ax) subx.w    -(a0),-(a1)    ; possible .b, .w and .l

Dy,Dx
subx.w    d0,d1    ; possible .b, .w and .l

-(Ay),-(Ax)
subx.w    -(a0),-(a1)    ; possible .b, .w and .l


***************************************************************** X N Z V C ***
SWAP SWAP words of Dn Dn -W- - * * 0 0

Exchange the words of a data register. For example, if we have
d0= $11223344, after a swap, d0 = $33441122
The UPPER word (bits 16-31) is exchanged with the LOWER word (bits 0-15)

Example:
swap    d0

***************************************************************** X N Z V C ***
TRAP Execute TRAP Exception #<vector> - - - - -

This instruction is used to generate exceptions, usually
used to execute instructions in supervisor mode.

Example:
trap    #0

Executes the vector at address $80.

***************************************************************** X N Z V C ***
TRAPV TRAPV Exception if V-bit Set TRAPV - - - - -

This instruction generates an exception (vector $1c), but only
if the overflow bit is = 1 at the time of execution.

Example:
trapv

***************************************************************** X N Z V C ***
TST TeST for negative or zero <ea> BWL - * * 0 0

This instruction tests the destination, updating the
Negative and Zero flags. Used to check if the operand is zero or
if it is negative. The Carry and Overflow flags are reset.

Example:

<ea>
tst.w    d1    ; note: you cannot perform a TST on a register
tst.w    (a1)    ; direct Ax addresses. ‘TST.W a0’ is impossible.
tst.w    (a1)+
tst.w    -(a1)
tst.w    $1234(a1)
tst.w    $12(a1,d2.w)
tst.w    $12(a1,d2.l)
tst.w    $12(a1,a2.w)
tst.w    $12(a1,a2.l)
tst.w    $1234.w
tst.w	$12345678

*******************************************************************************

Now here is a list of the meanings of the GURU MEDITATION messages, in case
your computer resets itself when running a program, at least you will
know why and what instruction was given:

GURU $00000002    - BUS ERROR        ($08)
GURU $00000003    - ADDRESS ERROR        ($0C)
GURU $00000004    - ILLEGAL INSTRUCTION    ($10)
GURU $00000005    - DIVISION BY ZERO	($14)
GURU $00000006    - CHK,CHK2        ($18)    ; on 68020+
GURU $00000007    - TRAPV,TRAPCC        ($1c)    ; on 68020+
GURU $00000008    - PRIVILEGE VIOLATION    ($20)
GURU $00000009    - TRACE            ($24)
GURU $0000000A    - EMULATOR LINE 1010    ($28)
GURU $0000000B    - EMULATOR LINE 1111    ($2c)

2) Bus error: A bus error occurs when accessing strange
and non-existent addresses, and it is often the MMU that causes this error
in computers that have one. (writing to protected memory)

3) Address error: If you try to execute or read a word or longword
stored at an ODD address. For example:

move.l    #$4e754e75,label ; write.l to odd address (on 68020 it is
; possible, this passes...)
bra.s    label         ; jump to odd address (this GURA
rts             ; even on a 68020+, since from 68020 onwards
; it has been made possible to move
; even long words to odd addresses, but it is
; always ‘forbidden’ to jump to execute
; code at odd addresses.

dc.b	0    ; a byte of interference
label:
dc.b    0,0,0,0    ; odd address!

4) Illegal instruction: If binary code is executed that does not correspond
to any 680x0 instruction. It can also be generated
with the appropriate ‘ILLEGAL’ instruction.

5) Division by 0: You cannot divide a number by zero!!

8) Privilege Violation: If you try to execute a privileged instruction
in USER mode instead of SUPERVISOR mode.
For example, operating with ANDI, ORI, MOVE on the SR.

A) Linef Emulator 1010: If you execute an unknown binary code that
begins with %1010, i.e. $Axxx. There are no
instructions that begin this way, so
this exception is generated.

B) Linef Emulator 1111: If you execute binary code that begins with $Fxxx.
However, some of the instructions of the math coprocessor
and the MMU do begin this way,
so while on a computer without MMU/FPU these
codes will generate a LINE-F exception, on others
68882/68851 instructions may be executed.

*******************************************************************************

A table with powers of 2 might be useful... (max: one longword)

2^n        n
|_____________|_____________|
2        1
4        2
8        3
16        4
32        5
64        6
128        7
256        8
512        9
1024        10
2048		11
4096
8192
16384
32768
65536
131072
262144
524288
1048576		20
2097152
4194304
8388608
16777216
33554432
67108864
134217728
26
536870912
1073741824
21
4294967296    32

*******************************************************************************

Finally, here is a brief table on optimisations and advice on which
instructions to use rather than others; an entire chapter will be devoted to
optimisations, but for now, MEMORISE this gospel, because if
I see instructions like "MOVE.L #label,a0‘ or ’add.w #4,d0", I cry.

INSTRUCTION example    | EQUIVALENT, BUT FASTER
------------------------|-----------------------------------------------
add.X #6,XXX        | addq.X #6,XXX        (maximum 8)
sub.X #7,XXX        | subq.X #7,XXX        (maximum 8)
MOVE.X LABEL,XX        | MOVE.X LABEL(PC),XX    (if in the same SECTION)
LEA LABEL,AX		| LEA LABEL(PC),AX    (if in the same SECTION)
MOVE.L #30,d1        | moveq #30,d1		(min #-128, max #+127)
CLR.L d4        | MOVEQ #0,d4        (only for data registers)
ADD.X/SUB.X #12000,a3    | LEA (+/-)12000(a3),A3	(min -32768, max 32767)
MOVE.X #0,XXX        | CLR.X XXX        ; moving #0 is stupid!
CMP.X #0,XXX        | TST.X XXX        ; where do you leave the TST?
To reset an Ax register	| SUBA.L A0,A0        ; better than ‘LEA 0,a0’.
JMP/JSR    XXX        | BRA/BSR XXX        (If XXX is nearby)
MOVE.X #12345,AX    | LEA 12345,AX        (address registers only!)
MOVE.L 0(a0),d0        | MOVE.L (a0),d0    (remove the offset if it is 0!!!)
LEA    (A0),A0		| HAHAHAHA! Remove this instruction! It has no effect!!
LEA    4(A0),A0    | ADDQ.W #4,A0        ; You never stop
; learning and optimising, eh!?

; Here is a table to be taken with a pinch of salt, given that the instructions
; given as equivalent are not really equivalent, mainly because
; the rest of the divisions are lost. However, it is always worth trying to
; replace a multiplication or division, as these are the
; slowest instructions. You can check the “reason” for the
; equality by consulting the table of powers of 2.

MULU.w    #2,d0        | ADD.l d0,d0 ; seems clear to me!
MULU.w    #4,d0        | LSL.l #2,d0 ; sometimes you need an EXT.L D0 first
MULS.w    #4,d0		| ASL.l #2,d0 ; to eliminate any ‘dirt’
MULS.w    #8,d0        | ASL.l #3,d0 ; in the high word, which in the case of MULS
MULS.w    #16,d0		| ASL.l #4,d0 ; is not considered, while
MULS.w    #32,d0        | ASL.l #5,d0 ; with ASL is shifted together with
MULS.w    #64,d0        | ASL.l #6,d0 ; rest.
MULS.w    #128,d0		| ASL.l #7,d0
MULS.w    #256,d0        | ASL.l #8,d0
DIVS.w    #2,d0        | ASR.L #1,d0    ; caution: IGNORE THE REST!!!!!!!
DIVS.w    #4,d0        | ASR.L #2,d0
DIVS.w    #8,d0        | ASR.L #3,d0
DIVS.w    #16,d0        | ASR.L #4,d0
DIVS.w    #32,d0        | ASR.L #5,d0
DIVS.w    #64,d0        | ASR.L #6,d0
DIVS.w    #128,d0        | ASR.L #7,d0
DIVS.w    #256,d0        | ASR.L #8,d0
DIVU.w    #2,d0        | LSR.L #1,d0    ; attention: IGNORE THE REST!!!!!!!!
DIVU.w    #4,d0        | LSR.L #2,d0
DIVU.w    #8,d0		| LSR.L #3,d0
DIVU.w    #16,d0        | LSR.L #4,d0
DIVU.w    #32,d0        | LSR.L #5,d0
DIVU.w    #64,d0        | LSR.L #6,d0
DIVU.w	#128,d0        | LSR.L #7,d0
DIVU.w    #256,d0        | LSR.L #8,d0

We successfully used this substitution in the PRINT routine of the
text in lesson8b.s, for example:

MULU.W	#8,d2

Which was transformed into:

LSL.W    #3,D2        ; MULTIPLY THE PREVIOUS NUMBER BY 8,
; the characters being 8 pixels high

Let's look at some examples:

muls.w    #4,d0

can be replaced with:

ext.l    d0
asl.l    #2,d0

Sometimes EXT is not necessary if the high word of d0 is zero.

-        -		-        -

Finally, consider that the Ax and Dx REGISTERS were invented precisely to
make the most of them. For example, let's optimise a loop of this kind:


move.w    #2000-1,d7    ; Number of loops
Loop1:
move.w    #$0234,$dff180
move.w	#0567,$dff182
move.w    #089a,$dff184
move.w    #0bcd,$dff186
dbra    d7,Loop1
rts

Don't mind the uselessness of the loop, let's assume it serves a purpose, and that we
want to speed it up: here's a decent speedup:


move.w    #0234,d0
move.w    #0567,d1
move.w    #089a,d2
move.w    #0bcd,d3
lea    $dff000,a0    ; Base for offsets
move.w    #2000-1,d7    ; Number of loops
Loop1:
move.w    d0,$180(a0)
move.w    d1,$182(a0)
move.w    d2,$184(a0)
move.w    d3,$186(a0)
dbra    d7,Loop1
rts

This loop is THOUSANDS of times faster, because moving a value from a
Dx data register is faster than a ‘move #xxx,dest’, and accessing
addresses via address registers is faster than writing the address
or label. ‘Exaggerating’ a little, you could optimise it even more:


move.w    #$0234,d0
move.w    #$0567,d1
move.w    #$089a,d2
move.w    #$0bcd,d3
lea    $dff180,a0
lea    $dff182,a1
lea    $dff184,a2
lea    $dff186,a3
move.w    #2000-1,d7    ; Number of loops
Loop1:
move.w    d0,(a0)
move.w    d1,(a1)
move.w    d2,(a2)
move.w    d3,(a3)
dbra    d7,Loop1
rts

Now we have used 3 more address registers, but we save the offsets,
which further increases speed and reduces the size of the code!
Obviously, these optimisations are only useful in loops or parts of code
that are executed very often.
