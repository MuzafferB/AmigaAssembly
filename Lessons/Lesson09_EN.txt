
“”'
(o o)
+---------------------------oOOO--(_)-------------------------------------+
|
| ASSEMBLER COURSE - LESSON 9
|
+--------------------------------------oOOO-------------------------------+
|__|__|
|| ||
ooO Ooo

Authors: Luca Forlizzi, Alvise SpanЫ, Fabio Ciucci

(Directory Sorgenti5) - then type ‘V Assembler2:sorgenti5’

иОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОX 
Anyone who owns
an Amiga will surely have heard of this special circuit
inside their computer, which is one of its greatest
strengths when compared to other computers. However, not everyone
knows what the blitter actually is and why it is
so useful. In fact, most of the special effects
you can admire in demos (such as sinusoidal scroll text
or vectorballs) make use of the blitter. So, you may ask, how
can these effects be achieved on PCs that do not have
a blitter? The reason is that everything the blitter can
do could be done with the microprocessor, and this is
how PCs work. However, the blitter , however, is able to perform 
its tasks much faster, in some cases even 10 times
faster. It is thanks to the blitter that special effects that can only be achieved on a PC
if you have a fast 386 or
even a 486, are commonplace for an Amiga 500
whose (68000 at 7Mhz, as you well know) is much slower than the 
386 and 486. So you will understand that for those who want to program demos or games
on the Amiga, knowledge of the blitter is essential. We will begin
our study of the capabilities of the blitter starting with the simplest ones, which
at first glance may seem meagre, but which we will gradually discover
hide the power that has enabled the creation of the most spectacular games and
demos. It should be noted that programs written for
68020+ often tend to use the CPU instead of the blitter, since
the latter does not increase speed.

.
.
.
.
.
 
.
.и :и и :::. . . и: )( г(X ) ) О)» ) \ _/,
 :::и. ..:. , »»»»»» (»»»»»» /_____________ ___ T
и: . . и '»\_ _ »\ _ _/ `-----||( АА:::!|
. :и . / / (,_) \ \ xCz ll !|:::||.,
 _______\ / ________ \ /_______ »»T |:::||
/ппппппппп\ /_T_T_T_T\ /ппппппппп\ | !ддд!|
/ппппппппппп\__» » » » »»__/ппппппппппп\ l______!
/пппппппппппппп`----------“пппппппппппппп\ `----”
иппппппппппппппппппппппппппппппппппппппппппи


*******************************************************************************
*            BLITTER FUNCTIONS                 *
*******************************************************************************

The word ‘blitter’ is an abbreviation of ‘BLock Image TransferER’
or ‘image block copier’. The blitter is therefore a
tool that allows us to move ‘pieces’ of images. In reality,
as you will discover later, this is only one of the capabilities of the
blitter, which is also capable of performing more complex operations.
As you know, an image within the Amiga is simply
a memory area containing the data that defines
the colour of each individual pixel. If you don't remember how
images are formed, it is a good idea to review lessons 4 and 5 before
continuing. When the blitter performs an operation on a ‘piece’
of an image, it actually works on the area of memory that forms the ‘piece’
of image in question. In effect, the blitter simply operates on
memory areas, regardless of whether they contain a graphic image,
 sound or program code.
This means that the blitter can also be used for tasks that
do not involve graphics.
It is important to note, however, that the blitter, like the copper in
audio circuits and all other Amiga custom chips, is not
able to operate on all available memory, but only on a
part of it called ‘chip RAM’.

To access the memory, the blitter uses the DMA channels discussed
in general terms in lesson 8, to which I refer you if you have any doubts.
The blitter has 4 DMA channels, 3 of which (called A, B and C)
are used to READ data from RAM (and are therefore called
‘source’ channels), while the fourth (channel D) is used to WRITE to memory
(and is therefore called the ‘destination’ channel). Like all DMA channels, those
of the blitter transfer one word of data at a time.

The general outline of a blitter operation (called a ‘BLIT’) is very
simple: the blitter reads data from memory through channels A, B and C,
performs operations on it and writes the results back to memory through
channel D. To perform a blit, it is therefore necessary to specify the 
following information:

1) which channels to use for this operation
2) what operation to perform on the data read
3) for each channel used, the address from which to start reading and writing
4) how much data to read or write

Note that the amount of data read (or written) during an operation is the
same for all four channels: if channels A, B and D are used in an operation,
the number of words read through channel A is equal to the number
of words read through channel B and the number of words
written through channel D.

This information is specified through some hardware registers.
The registers that control the blitter are, like all hardware registers,
16-bit registers. However, there are many registers that have consecutive addresses.
This makes it possible to access them in pairs using ‘move.l’
instead of ‘move.w’, similar to what we saw for the pairs
of registers BPLxPT ($dff0e0...) and COPxLC ($dff080...).

Before starting to write to the registers, however, you must be sure that
the blitter is stopped, i.e. that it is not already performing another operation.
It is essential to wait for the last ‘blit’ to finish before doing another one,
 otherwise you could cause explosions and crashes within a radius of
100 metres, a real cataclysm, comparable to an air raid.

To find out if the blitter is idle or ‘blitting’, simply check
the status of a bit (bit 6) in the DMACONR register ($dff002).
If this bit is 1, then the blitter is working, while if it is 0, it means
that the blitter has finished.
In practice, therefore, a simple assembler instruction is sufficient:


WaitBlit:
btst    #6,$dff002    ; dmaconr - has the blitter finished?
bne.s    WaitBlit    ; Do not continue until it has finished


Unfortunately, to complicate matters, there is an annoying hardware bug in
early versions of the Agnus chip (the chip that contains the blitter) which
causes the first time the bit in question is read,
the result is incorrect: a blank read must be performed before
the exact status of the bit can be known.
 

After making sure that the blitter is stopped, we can write
the information it needs for the blit,
 which we listed above, to the registers.

Let's now see in detail how to proceed.

1) For each blitter, we can independently enable or disable the
DMA channels, so as to use only those that interest us, by means of
enable bits which, if set to 1, enable the channel;
if they are reset, they disable it. The enable bits are located
in the BLTCON0 control register ($dff040):

channel        enable bit name    bit position in BLTCON0

A            SRCA                8
B            SRCB                9
C            SRCC                10
D            DEST				11

2) To specify which operation to perform, bits 0 to 7 of the
BLTCON0 control register, called MINTERMS, are used. The value of these
bits determines the operation performed by the blitter. The operation of the 
MINTERMS is quite complicated, and will be explained in detail later.

3) Let's now see how to indicate the starting addresses of the channels.
Each channel is connected to a pointer to the chip RAM, which is used to
store the starting address of an operation. During the operation,
 the value contained in the pointer will change automatically, indicating
the address of the word that the blitter reads or writes.
A pointer consists (as for the DMA channels of sprites and planes)
of a pair of 16-bit registers, one containing the 16 least significant bits
(i.e. the lowest) and one containing the remaining (high) bits.
This table summarises the names and addresses of the pointers:

channel        high register            low register

name     address        name     address

A        BLTAPTH     $DFF050        BLTAPTL     $DFF052
B        BLTBPTH     $DFF04C        BLTBPTL     $DFF04E
C        BLTCPTH     $DFF048        BLTCPTL     $DFF04A
D        BLTDPTH     $DFF054        BLTDPTL     $DFF056

Clearly, these pairs of registers can be treated as single
32-bit registers - as for pointers to CopperLists and Planes - and, 
therefore, be written with a single ‘move.l’ instruction at the address
of BLTxPTH. Therefore, from now on we will consider them as single 32-bit registers
, using the names BLTxPT and referring to the addresses $dff050,
$dff04c, $dff048 and $dff054 (except for any exceptions that will be
appropriately noted).

The pointer registers should be written with a byte address, but
since the blitter only works on WORDS, the least significant bit of our
address is ignored, so we must remember that addresses must
be EVEN, i.e. aligned to WORDS.
Therefore, we must remember that only EVEN addresses of the
CHIP memory can be written, both for the sources and for the destination.

NOTE: Assign unused bits to zero, especially those that have
no function even in ECS, as they may be used for unknown purposes in future versions
and the results would be unpredictable.

4) The last operation to perform is to indicate the amount of data that
needs to be read or written. This is done using the
BLTSIZE ($dff058) register. This register allows the blitter to consider the data
it reads and writes not as a simple sequence of words, but as a sort
of two-dimensional rectangle composed of words. For example, the blitter
considers a sequence of 8 words as a rectangle 8 words wide and
1 line high:

Width=8 WORD
_______________|_______________
/ \

one word
_
/ \
/ +---+---+---+---+---+---+---+---+
Height=1 LINE - | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
\ +---+---+---+---+---+---+---+---+

fig. 1    rectangle of 8*1 words

Let's take another example: a sequence of 50 words can be considered
as a rectangle of 10 words X 5 lines:


Width=10 WORDS
_______________|_______________
/ \

one word
_
/
/
| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---+
| | | | | | | | | | |
| +---+---+---+---+---+---+---+---+---+---+
Height=5 LINES -| | | | | | | | | | |
| +---+---+---+---+---+---+---+---+---+---+
| | | | | | | | | | |
| +---+---+---+---+---+---+---+---+---+---+
| | | | | | | | | | |
\ +---+---+---+---+---+---+---+---+---+---+

fig. 2    10*5 rectangle of words

This fact, which at first glance may seem like an unnecessary complication, is
actually one of the features that makes the blitter so powerful.
We will see why in a moment. But first, let's see how
BLTSIZE works. To specify the amount of data involved in the blit,
write the dimensions of the rectangle of words that the data form in BLTSIZE.
The lower 6 bits express the horizontal dimension, i.e. the NUMBER OF
WORDS that make up each horizontal line; the upper 10 bits express
THE NUMBER OF horizontal LINES that make up the rectangle: basically,
the 6 low bits represent the X width of the rectangle, while the 10 high bits represent
the Y height of the rectangle.
У Note that if the value of the 10 high bits (height) is 0, the blitter
 
will transfer 1024 lines, and if the value of the 6 low bits (width in words) is 0,
the blitter will transfer 64 words: the largest blitter, therefore, is obtained
by writing ‘move.w #$0000,$dff058’.
It will be 64 words X 1024 lines (=64*2*1024=128 Kb).
The BLTSIZE register also has anotheranother very important function: WRITING
ACTIVATES THE BLITTER, starting the specified operation.
For this reason, YOU MUST ALWAYS WRITE IN THE BLTSIZE REGISTER AFTER
WRITING IN ALL THE OTHER BLITTER REGISTERS, otherwise the
 
blitter will start before you have set all the registers correctly,
 producing results that are different from those desired.

._________________
| _________ |
| (_________) |
|_________________|
|:и и|
_|______ ______|_
|______. .______|
_/ |^| \_
__\\_______|_|_______//__
/__/ __(_____)__ \__\
//\/ / \ \/\\
\_/ /_____________\ \_/
/ /» _____ »\ \
\ _ / _ / ___________
.____________\_______( )_______/__/ \
| ___/ \_____/ / _ _ _ \
| | \_________________________________/ \| | | \
| | g«m| _________ / \ | | \
__| |__ | »» /|\ »» /______\___|___|___/
/ \ _____|___________ | ______//______\\ )
(__|_| |_// \_|_/ \ /____/
|_| /___________________\ /_____ __\______/____\


At this point, it is a good idea to put what you have learned so far into practice
by looking at some examples. These examples also use
registers that we have not yet discussed, such as BLTDMOD and BLTCON1.
Ignore them for now; we will explain them later.

In Lesson 9a1.s, you will see how to clear a memory area using the blitter.
To perform a deletion operation, you only need to use
channel D, as all you need to do is write zeroed words
to memory. By disabling the source channel, the value $00 will be written to the destination
.
Furthermore, to define a deletion operation, you need to write
the value $00 in the MINTERMS, i.e. in bits 0-7 (the low byte) of the
BLTCON0 register.

In lesson9a2.s, we will use the blitter to copy data from one
memory area to another. For this operation, we will use channels A and D.
The data will be read from memory via channel A and written
via channel D. To define a copy operation from channel A to channel
D, you need to write the value $F0 in MINTERMS.

__________
\ AMIGA! / lllll
\ !!!! / __/ \__
\____/ \/ (o!o) \/
|| / \_____/ \
|| /___________\\\\\
|| _| |_ \ \
||__________/ \_____\_ \
()(________/ \________)
|| /_________\
|| (_____░_____)
|| \ Y /
|| __\___|___/__
__||____ __\_____!_____/_____

*******************************************************************************
*        FIRST APPLICATIONS OF THE BLITTER                 *
*******************************************************************************

Now we will start using the blitter in graphics applications. We know that
an image is made up of words of data in memory. Since we can perform operations on memory using the
blitter, modifying the data that
make up an image causes a change in the image itself.
Let's briefly review how images are represented,
limiting ourselves for now to the case of a single bit plane.

A bit plane is a set of words, each of which represents the state
of a pixel: one word represents 16 pixels arranged horizontally.
The first word of the bit plane represents the 16 pixels furthest to the left of the first
line of the image.
The following words represent all the pixels in the first row in order.
When the pixels in the first row are finished, we start in the same way with
those in the second row.
If there are, for example, 320 pixels in a row, 320/16=20 words are needed
are needed to represent it all; therefore, the first 20 words of the bit plane represent
the first row of the image, words 21 to 39 represent
the second row, and so on:

____ ____ ____ ____ _ _ _ _ _ _ ____
| | | | |        | |
| 0 | 1 | 2 | 3 |	 | 19 |
|____|____|____|____|        |____|
| | | | |        | |
| 20 | 21 | 22 | 23 |        | 39 |
|____|____|____|____|        |____|
| | | | |        | |
| 40 | 41 | 42 | 43 |		| 59 |
|____|____|____|____|        |____|
|                 |
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |
| | | | |        | |
|____|____|____|____|_ _ _ _ _ _|____|

Fig. 3 Representation of an image in memory:
each square is a word

We have seen that with the blitter we can copy data from one point to another
in memory. If we copy data within a bit plane, the values we
copy will be used to form the image on the screen. The blitter,
since, as we have said, it works on WORD-sized data (16 bits),
allows us to modify the image in groups of WORDs, i.e. in groups of 16 pixels.
For example, if we use the blitter to write over the 21st word of the bitplane
shown in the figure, we will modify the 16 pixels to the left of the second row
of the image. Now suppose we have an image that is one row high and
a certain number L of pixels wide. Precisely because the bitplane is divided
into words, which contain 16 pixels, it is convenient that the width in pixels
of our image, i.e. L, is a multiple of 16, so that
the image is contained exactly in L/16 words. This can be achieved
by adding pixels with a value of 0 at the end of our image, as
illustrated in the following example:

This is an image 20 pixels wide and one row high.

11001101010100011001
\__________________/
|
20 pixels

This is not convenient to manage because 20 is not a multiple of 16. So
let's add pixels with a value of 0 at the end to make the width
equal to 32 pixels, i.e. a multiple of 16.

1100110101010001100100000000000
\______________________________/
|
32 pixels

Our image is stored among the data in our program. To make it
appear on the screen, we must copy it to the memory area dedicated to the
bit plane. The image will appear on the screen in a position corresponding
to the words of the bit plane into which we copy it. Suppose we want to draw
the image on the screen so that the first pixel, i.e. the pixel
, has the X and Y coordinates (remember that the
coordinate system of the screen has its origin, i.e. the point with coordinates X=0 and Y=0,
in the upper left corner, with the X coordinates increasing towards the right
and the Y coordinates increasing towards the bottom).
This pixel is contained in a word of the bit plane.
For now, let's just consider the case where X is also
a multiple of 16. This ensures that our pixel is the first (i.e. the
leftmost pixel) of the word to which it belongs. In this way, once
we have calculated the address of that word, we can copy (with the blitter) the first
word of the image. The other words that make up our image will be
copied naturally into the subsequent words of the bit plane.
All this, since the blitter is capable of copying sequences of words,
can be done with a single blit that has as its source address the
first word of the image, and as its destination address, the address of the
word of the bit plane to which the pixel with coordinates X and Y belongs.
Let's see how to calculate this address.
Let's number the words of the bit plane starting from 0, as shown in the figure, and
calculate the number of the word we are interested in: from this number we will then trace back
to the actual address.
Let's start by calculating the number of the first word of row Y, remembering
once again that each row consists of 20 words and that the rows are
numbered starting from 0. You can see from the figure that the first word of
row 0
 (the first row) has number 0, the first word of row 1 (the second row) has number 20, the first word of row 2 has number 40, the first word
of row 3 has number 60, and so on.
In general, therefore, the first word of row Y has number Y*20.
The numbers of the other words in the row are consecutive to that of the first:
the second word in the row has number Y*20+1, the third word in the row has
number Y*20+2, and so on.
We can call the “distance” of a certain word R from the first word of the line
to which R belongs, the quantity that must be added to the number of the first
word of the line to obtain the number of word R: in practice, since the
second word of the line has number Y*20+1, we say that it has a ‘distance’ of 1
from the first word of the row; similarly, the third word of the row, which
has number Y*20+2, has a distance of 2 from the first word of the row, and so on.
We can also say that the first word in the row has a distance of 0 from itself.
It is very simple to calculate the distance between the word containing the pixel with
coordinate X and the first word in the row, as we will see with the help of the
following figure:

________ ________ ________ ________ _ _ _
| | | | |
row Y        | Y*20+0 | Y*20+1 | Y*20+2 | Y*20+3 |
|________|________|________|________|_ _ _

Distance
from the first 
word        | 0     | 1     | 2 | 3 | - -

Pixels
contained:    | 0-15 | 16-31 | 32-47 | 48-63 | - -

fig. 4    row of words

The X coordinate of our pixel represents the distance (in pixels) between it
and the first pixel of the row. Since each word contains 16 pixels, the first word
of a row contains the first 16 pixels of the row, i.e. those with an
X coordinate (=a distance from the edge) between 0 and 15.
The second word contains the pixels whose X coordinate varies from 16 to 31,
the third word contains the pixels with X varying from 32 to 47, and so on: every 16 pixels
we have a word.
So to calculate the distance between words, simply divide the distance in
pixels (i.e. the value of X) by 16. Since we have chosen X to be a multiple of 16,
the result will be an integer. For example, if X=32, the distance in words is
32/16=2. In fact, as you can see in the figure, pixel 32 of row Y is
the first pixel of the second word of the row, whose number is Y*20+1.
Using the same calculation, we see that the pixel with X=64 is contained in the word
which is 64/16=4 away, a word whose number is Y*20+3. This calculation also works
if X=0: in fact, we have a distance of 0/16=0, i.e. the word with number Y*20+0, which is
precisely the first word of the row.

In total, therefore, the word containing pixel X,Y is the word with number N
given by the following formula:

N=(Y*20)+(X/16)

This formula is valid for bit planes in which a row is made up of 20
words. In general, the formula is:

N=(Y*NUMBER_OF_WORDS_MAKING_UP_A_ROW)+(X/16)

From the word number, we can trace back to the corresponding address:
just know the address of the first word of the bit plane and add the
word number multiplied by 2 (the multiplication is necessary because
the address is expressed in bytes and 1 word = 2 bytes):

Word address = (Bit plane address) + N*2 .

In the example Lesson9b1.s, you will find the application of everything we have
said. In the example Lesson9b2.s, you will see a series of blits in different
positions on the screen.

Let's now start dealing with images that are taller than one line.
We saw when we talked about the BLTSIZE register how the blitter
considers the data it has to operate on as ‘rectangles’ of words. This
feature is very useful because it allows it to work easily
with rectangular images. Suppose, for example, that we want to copy
an image 32 pixels wide and 2 lines high into a bitplane. This small
image will occupy a small portion of the bitplane, highlighted
in the figure by the slanted lines.

____ ____ ____ ____ _ _ _ _ _ _ ____
| | | | |        | |
| 0 | 1 | 2 | 3 |     | 19 |
|____|____|____|____|        |____|
| |\\\\|\\\\| |        | |
| 20 |\21\|\22\| 23 |        | 39 |
|____|\\\\|\\\\|____|        |____|
| |\\\\|\\\\| |        | |
| 40 |\41\|\42\| 43 |        | 59 |
|____|\\\\|\\\\|____|        |____|
|                 |
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |
| | | | |        | |
|____|____|____|____|_ _ _ _ _ _|____|

Fig. 5 A bit plane with the portion
we will blit highlighted

This is a small rectangle 2 words wide (i.e. 32 pixels) and 2 lines high.
 You will immediately understand that in order to make the copy, it is necessary to
specify the dimensions of the rectangle in BLTSIZE. But that is not
enough. To understand why, let's put ourselves in the blitter's shoes for a moment
and try to perform the copy ourselves, focusing
for now only on the writing phase.
We know (because it is written in BLTDPT) the address of the word at the top
left of the rectangle (word 21 in the figure). We also know (it is written
in BLTSIZE) the size of the rectangle to be copied. Very good.
We read the first word and copy it to the address of word 21.
Now we have to copy the second word of the first line. We know that this word
is consecutive to the first word, so we add 2 to the address of the first
word (which is written in BLTDPT) and we know the address of the second word to
be written. 
We write it and we have finished the first line. Very satisfied, we
prepare to write the second line. And here we notice that there is a small
problem: the first word of the second line is NOT CONSECUTIVE to the last word
of the first line! In fact, as you can see from the figure, the last word of the
first line is word 22, while the first word of the second line is word 41.
How do we calculate the address of the first word of the second line?
The figure shows a bitplane 20 words wide, but this is only an example.
How does the poor blitter know how many words wide the bitplane is? In fact,
we could be dealing with a bitplane that is wider than the visible screen!
Come to think of it, who told the blitter that we are using it to copy
a rectangle onto the screen? What if we were simply copying
data into a copperlist? It is clear that the blitter alone cannot get itself out of this
mess. But no problem, we'll help it. All the blitter needs to
know is how to calculate the address of the first word
in a row, knowing the address of the last word in the previous row. If
you look at the figure for a moment, you will see that the blitter simply has to
‘skip’ words 23 to 40 inclusive. This can be done by adding
to the address of word 22 (i.e. the address of the last word of the first
line, which the blitter already knows) the number of bytes difference compared to
word 42 (which is the first word of the new line). This number of
bytes, called MODULE, is obviously equal to the number of words to
‘skip’ multiplied by 2 (since, as you know, a word occupies 2 bytes).


word        0 X X+L H
line y         |------------|*************|--------------|
riga y+1	|------------|*************|--------------|
\____________/\____________/\_____________/
|         |         |
word from    figure         word from
skip    wide L        skip
word

Fig. 6    Module

In general, if we need to copy a rectangle that is L words wide within
a bitmap that is H words wide, the MODULE expressed in bytes is obtained with
the following formula:

MODULE = (H-L)*2

The calculation H-L would give us the module expressed in words, multiplication by 2
is used to express it in bytes. In our example, the MODULE is (20-2)*2.
If you remember, we have already encountered the concept of module in relation
to bit planes. The blitter module works in exactly the same way.
It is possible to assign a different module for each DMA channel. In this way
data can be copied and moved between bitplanes of different widths.
The module value is written in 4 special registers, one for each DMA channel
: BLTAMOD for channel A ($dff064), BLTBMOD for B ($dff062),
BLTCMOD for C ($dff060), BLTDMOD for D ($dff066). The module values are
in bytes, not words. Since the blitter can only operate on words, the least significant bit
is ignored, which means that the module value must be
even.
The value, positive or negative, is automatically added to the registers that
point to the addresses (BLTxPT) each time the blitter has finished copying
a line, in order to calculate the address of the first word of the next line
.
Negative module values can be useful in many cases, for example to
repeat a line by setting the module as the bitplane width to
negative. We have already seen in lesson 5 how to replicate a line by setting
the copper module BPL1MOD/BPL2MOD to -40, or in any case -LineLength.

._________
| _ ____/
___|______|___
_/ \_
\________________/
\_ Oo _/
/\_(»»»»)_/\
/ \ / \
./ /\ \/ /\ \.))
| | \__ __/ | |
| | | | | |
| \ | | / |
(( \ \__|____|__/ /
\/ _/ \_ \/
\||______||/
/|_| | |_|\
/ || | || \
( (» | ») )
| | | | |
| | | | |
_|_| | |_|_
\ | |______| /)
 | g| (
___/ | «| \___
/______| m|______\

At this point, we know how to copy a rectangle within a bitmap.
Let's summarise all the necessary calculations with an example:

Suppose we want to operate on a section of a 320x200 bitmap, which
starts at line 13, word 6 (where both are numbered from zero) and is 5
words wide. First, we need to calculate the address of the first word of the
rectangle, and then write it in the BLTxPT register of the channel we are interested in.
The calculation is done as follows: take the address of the first
word of the bitplane, add 13*20*2 bytes to calculate the address of the
first byte of line 13 (in fact, each line occupies 20 words=40 bytes) and finally
add 12 bytes (=6 words) to arrive at the correct horizontal position.
The width is 5 words (10 bytes). At the end of each row, we must skip
30 bytes to get to the beginning of the next row, so we use a modulus of
30. In general, the width (in words) doubled plus the modulus value (in
bytes) should be equal to the full width, in bytes, of the bitplane that
contains the image.

These calculations are illustrated in the figure showing the values required
used in the BLTxMOD and BLTxPTR blitter registers (BLTxPTH and BLTxPTL) registers.


<Mem_Addr> = Address (0,0)
\
\
\         NUMBER OF BYTES (COLUMN)
\
\ 0     10     20    30     39
\|     |     |     |     |
+----------------------------------------+ - -
0|ииииииииииииииииииииииииииииииииииииииии|	|
1|иииииииииииииииииииииииииииииииииииииии|
2|иииииииииииииииииииииииииииииииииииииии|    |
3|иииии|
4|иииииииииииииииииииииииииииииииииииииии|    |
5|иииииииииииииииииииииииииииииииииииииии|
6|иииииииииииииииииииииииииииииииииииииии|	|
7|иииииииииииииииииииииииииииииииииииииии|
8|иииииииииииииииииииииииииииииииииииииии|	|
9|иииииииииииииииииииииииииииииииииииииии|
NUMBER    10|иииииииииииииииииииииииииииииииииииииии|    |
row    11|ииииииииииииииииииииииииииииииииииииии|
12|иииииииииииииииииииииииииииииииииииииии|    |- - window
13|ииииииииииии##########иииииииииииииииии|     bitmap
14|ииииииииииии##########иииииииииииииииии|    |
15|иsalto sin. ##########иии salto dest.иии|
16|<---------->##########<---------------->|    |
17| = 12 bytes ##########иии = 18 bytes иии|
18|ииииииииииии##########ииииииииииииииииии|	|
19|иииииииииииииииии\ииииииииииииииииииииии|
20|ииииииииииииииииии\иииииииииииииииииииии|    |
-|ииииииииииииииииииии\ииииииииииииииииииии|
-|ииииииииииииииииииии\иииииииииииииииииии| |
-|иииииииииииииииииииии\ииииииииииииииииии|
-|ииииииииииииииииииииии\иииииииииииииииии|    |
+-----------------------\------------\---+ - -
\        \
\         \
image to be manipulated     \
\
one byte

BLTxPTR = <Mem_Addr> + (40*13) + 12
= <Mem_Addr> + 532

BLTxMOD = 12 + 18
= 30 bytes

Fig. 7 calculations for BLTxPTR and BLTxMOD

At this point, it is a good idea to pause and look at a few examples.

In lesson9c1.s and lesson9c2.s you will find simple examples of copying rectangular areas.
 Study them carefully, focusing on the calculation of the
addresses and modules used in the blits.

In lesson9c3.s there is an example in which a blit is performed with a
negative module.

In lesson9d1.s and lesson9d2.s you will see the first examples of animation with the
blitter.

The idea is very simple: to give the impression of movement, just draw
our figure each time in a different position, a bit like we did with
sprites.
Unlike then, however, before drawing the figure in the new
position, we will have to delete it from the old one, otherwise we would get a
‘trail’ effect.
In these two examples, we move the figure down one line at a time,
adding 40 bytes to the BLTxPT address each time.

In lesson 9d3.s, we apply the same technique to move the figure horizontally.
Note, however, that changing the address is equivalent to moving the rectangle to the right (or left) by one or more words. Since a word corresponds to 16 pixels, we can only move the figure horizontally in increments of 16 pixels, which, as you can see in the example, makes the movement less smooth.
To solve this problem, we can use the same technique used for sprites.
corresponds to 16 pixels, we can only move the figure horizontally
in 16-pixel increments, which, as you can see in the example,
 makes the movement less smooth and too fast..

 :
и
д:.:.:.:д
l______ |
(░X░ ) »)
|C_»»__ T___
________ l_____г l _ \
(_____ \________T____/ ) \
(__ ______________/ \
(____/ /\░ \
/ /\░ \
/ / \░ \
.и. / / \░_________\
.и и. _/ \ »\ _.. г\ xCz
.и (_ _) \/и: \____
.и `-`-' /и: \. \__
ииии. .иииии /и: \:. \ \
: : \и:. \::.\ \
....:.. .:........... \и::. \___\ \
__\___________\ `-\_)
(_____________)

So far, we have limited ourselves to drawing figures with the leftmost pixel in
a multiple position of 16. To achieve smooth movement, however, it is
necessary to be able to draw the figure in an arbitrary position on the screen.
Let's take an example, imagining that we have an image of a car that we want to
move around the screen.
By calculating the address of the rectangle that contains it, we can
“blit” our car from any of the words that make up the
screen. If our car image, for example, has its door 5
pixels from its far left, we can move it, together with the car,
to 5 pixels from the beginning of any word on the screen. If we want to move it
to the right, we can “blit” it from the next word.
The result would be a 16-pixel ‘jump’ each time. But if we want to
move that car to the right or left one pixel at a time, or if we
want to blit it to a horizontal position that is not a multiple of 16,
how do we do it?

We have to make sure that the pixels that form the image are copied
NOT starting from the first bit of the first word, but from an arbitrary bit
within that word, as illustrated in the following figure.

copy with X multiple of 16

first word
source        1 0 0 1 1 0 1 0 1

| | | | | | | | |
| | | | | | | | |
v v v v v v v v v
first word         _ _ _ _ _ _ _ _ _ _
destination     |_|_|_|_|_|_|_|_|_

bit            0 1 2 3 4 5 6 7 8 ..


copy with arbitrary X

first word
source          1 0 0 1 1 0 1 0 1

| | | | | | | | |
| | | | | | | | |
v v v v v v v v v
first word         _ _ _ _ _ _ _ _ _ _
destination     |_|_|_|_|_|_|_|_|_

bit            0 1 2 3 4 5 6 7 8 ..

Fig. 8 Shift


In practice, we need to shift the bits that make up the figure from right to
left.
The blitter has hardware shifters for channels A and B, which shift
all the bits of the words read by channels A and B to the right.
The bits are shifted by a number of positions that can vary from 0 to 15.
Shifting by 0 positions is equivalent to not shifting at all: all the blits we 
we have seen (and done) so far were shifted by 0 positions.
The shift value for channel A is assigned with bits 15 to 12 of the
BLTCON0 register ($dff040);
 the shift value for channel B is assigned with bits 15 to 12 of BLTCON1 ($dff042). If you remember, so far we had always
left these bits at a value of 0, which indicates a shift of 0 positions.
Channel C, on the other hand, is a proletarian, it has no shifter.
(For those who have forgotten, shifting bits means ‘scrolling’ bits
to the right or to the left....)
The shifting operation is performed simultaneously with normal
copy operation and does not affect the speed of the blitter: whatever the shift value,
 the time taken for the blitter operation is always the same.

Thanks to the shift, we can draw a figure with the leftmost pixel
in an arbitrary X position. In fact, by calculating the destination address as usual,
 we can draw the figure at a position
X that is a multiple of 16. By activating the shifter at the same time, we can move it
further to the right to reach the desired position.
For example, suppose we want an X position of 38 pixels.
By calculating the address, we can move the figure 32 pixels
(32 is a multiple of 16) to the right of the edge, 0, and we can move to the right by
another 6 bits (38-32=6) by setting a shift of 6.
In general, if X is not a multiple of 16, by doing the integer division X/16
we obtain an integer result (which we use to calculate the destination address)
 and a remainder that tells us how much the shift must be.
(Remember that integer division is a division in which the decimal digits of the result are not
calculated and a remainder is obtained, as
in primary school; for example, 7/3=2 with a remainder of 1).
In the case of a horizontal position X=100, we have 100/16=6 with a remainder of
4 (in fact, 16*6=96 and 100-96=4); therefore, the distance between the first destination word
and the first word of the row is equal to 6 words, or 12 bytes, and
the shift value is 4 bits.

Before we start using the shift, however, we need to understand how it works.
To begin with, some bits are naturally shifted to the right out of the words
to which they belonged. From the left, something must be shifted in to
replace the bits that have been removed. What in particular? For the first word of the
blit, zeros are shifted in; for each subsequent word of the
same blit, the bits shifted into a word are those shifted out
from the previous word. In short, what comes out on one side (the right)
goes back in on the other side (the left!) in the next word.
Let's look at a small example, with the help of a diagram to understand it better.
Suppose we copy 3 words (they can form a rectangle one row high and
3 words wide, or 3 rows high and 1 word wide, it makes no difference from the
point of view of the shift), applying a shift value of 3.
Let's see what happens:

SOURCE
word 1             word 2             word 3
1000110001010101    0001001001000110    1010101010101010

DESTINATION
word 1             word 2             word 3
0001000110001010    1010001001001000    1101010101010101
^^^			^^^            ^^^
these 3 bits are the    these are the 3 bits    these are the 3 bits
zeros shifted into    shifted out of    shifted out of
the first word        the first word and back in    word 2 and back in
the second word    word 3

Fig. 9 shift


Note that the last 3 bits of word 3 of the source are NOT
copied from ANYWHERE!

For example, consider a blit that is three words wide and two words high, with a
shift of 4 bits. For simplicity, let's assume that it is a normal copy from A to D.
The first word that will be written in D is the first word taken from A, shifted to the right by four bits with 4 bits zeroed shifted in from the left.
The second word will be the second word taken from A, shifted to the right, with the
four least significant bits
shifted in. 
(on the right) of the first word shifted in.
Next, write the first word of the second row taken from A, shifted four
bits, with the four least significant bits of the last word from the first row
shifted in. This continues until the blit is complete.

In lesson 9e1.s you can see an example of the use of shift, which allows
a figure to move one pixel at a time to the right. However, the result
is not very good due to the fact that the bits that are shifted out
of a word are shifted into the next word, which is one
line lower. So the bits that come out on the right come back in on the left
in the next row! The situation is illustrated by the following figure,
assuming a 4-bit shift:
 


SOURCE
word 1        1000001111100000
‘ 2        1100111111111000
’ 3        1111111111101100
" 4        1111111111111110
‘ 5        1100111111111000
word 6        1000001111100000


DESTINATION
word 1        0000100000111110
’ 2        0000110011111111
‘ 3        1000111111111110
’ 4        1100111111111111
" 5        1110110011111111
word 6		1000100000111110
^^^^
These four columns of bits are made up of the bits entered from the
left: as you can see (except for the first row), each
row contains the bits that came out of the previous row.

Fig. 10 Shift of a rectangle

Fortunately, this problem can be solved very easily.
If you think about it, what we want is for the bits that exit on the right
of a word to re-enter on the left NOT in the next row, but rather
IN THE RIGHT-MOST WORD! We must therefore ‘involve’ the rightmost words in the bit shift
. This can be done simply by increasing
the width of the figure by adding a ‘column’ of words OF
ZERO VALUE to the right. In this way, the extra column is invisible, and
the bits shifted out of the words that compose it will all be zeros and therefore
will not interfere when they re-enter the words of the following line.
To clarify, here is what happens:

SOURCE
word 1        word 2
line 1        10000011111000000000000000000000
" 2		11001111111110000000000000000000
" 3		11111111111011000000000000000000
‘ 4        11111111111111100000000000000000
’ 5        11001111111110000000000000000000
" 6		10000011111000000000000000000000
^^^^^^^^^^^^^^^^
This is the added words column

DESTINATION
word 1        word 2
line 1        00001000001111100000000000000000
‘ 2        00001100111111111000000000000000
’ 3		00001111111111101100000000000000
‘ 4		00001111111111111110000000000000
’ 5		00001100111111111000000000000000
" 6		00001000001111100000000000000000
^^^^        ^^^^
|        These 4 bits have left word 1
|        and entered word 2
|
These 4 bits have left word 2 of the previous line and
entered word 1 (except those that entered word 1 of
line 1, which are automatically reset)

Fig. 11 Shift of a rectangle

In the example lesson9e2.s, you will see this technique applied, which allows you to
move a figure to the right by a number of pixels between 1 and 15
(in fact, the possible shift values range from 0 to 15 inclusive). 
In the example lesson9e3.s, we finally see our figure move to the
right by an arbitrary number of pixels. In practice, the
examples lesson9d3.s and lesson9e2.s are combined together.

__---__
_- _--______
__--( / \ )XXXXXXXXXXXXX_
--XXX( O O )XXXXXXXXXXXXXXX-
/XXX( U ) XXXXXXX\
/XXXXX( )--_ XXXXXXXXXXX\
/XXXXX/ ( O ) XXXXXX \XXXXX\
XXXXX/ / XXXXXX \__ \XXXXX----
XXXXXX__/ XXXXXX \__-----
---___ XXX__/ XXXXXX \__ ---
-- --__/ ___/\ XXXXXX / ___---=
-_ ___/ XXXXXX '--- XXXXXX
--\/XXX\ XXXXXX /XXXXX
\XXXXXXXXX /XXXXX/
\XXXXXX _/XXXXX/
\XXXXX--__/ __-- XXXX/
--XXXXXXX---------------- XXXXX--
\XXXXXXXXXXXXXXXXXXXXXX-
--XXXXXXXXXXXXXXXX-

*******************************************************************************
*        BLITTATE ‘A COLORI’                     *
*******************************************************************************

So far, we have only considered images consisting of a
single bitplane, i.e. only two colours. Normally, when working with
multicoloured images, the bitplanes are arranged consecutively in memory,
so that immediately after the last word of one bitplane comes the first word of the
next bitplane.
The image is therefore structured as follows:

____ ____ ____ ____ _ _ _ _ _ _ ____
bitplane 1    | | | | |        | |
| 0 | 1 | 2 | 3 |     | 19 |    line 0 bitplane 1
|____|____|____|____|        |____|
| | | | |        | |
| 20 | 21 | 22 | 23 |        | 39 |    row 1 bitplane 1
|____|____|____|____|        |____|
|                 |
|


|____ ____ ____         |
| | | |        | |
| | | |        | |    last row bitplane 1
|____|____|____|____|_ _ _ _ _ |____|
bitplane 2    | | | |        | |
| 0 | 1 | 2 | 3 |     | 19 |    line 0 bitplane 2
|____|____|____|____|        |____|
|                 |
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |
| | | | |        | |    last row bitplane 2
|____|____|____|____|_ _ _ _ _ _|____|
bitplane 3    | | | | |        | |
| | | | |        | |    row 0 bitplane 3
|____|____|____|____|_ _ _ _ _ _|____|
|				 |


|____ ____ ____ ____         ____|
| | | | |        | |    last row
| | | | |        | |    of the last bitplane
|____|____|____|____|_ _ _ _ _ _|____|

Fig. 12 Memory representation of a
multi-bitplane (each square is a word)


As you already know, a bitplane that is H words wide and V rows high occupies H*V
words, or 2*H*V bytes (normally H=20 and V=256, so a bitplane
occupies 40*256 bytes). This means that, since the bit planes are arranged
in memory one after the other, if bit plane 1 starts at address
PLANE1, bit plane 2 will start at address PLANE2=PLANE1+2*H*V.
Similarly, bit plane 3 starts at address PLANE3=PLANE2+2*H*V and so
on. The same formula applies to determine the address of a word in the
second bit plane when the address of the corresponding word in the
first bit plane is known: for example, the seventh word of the first bit plane has
address ADDRESS1 = PLANE1+2*7, while the seventh word of the second bit plane
has address ADDRESS2 = PLANE2+2*7 = PLANE1+2*H*V+2*7. But since
PLANE1+2*7 = ADDRESS1, we have the following formula:

ADDRESS2 = ADDRESS1+2*H*V.

This formula will be very useful in a moment. A rectangular image
contained in a screen with N bitplanes will consist of N rectangles,
one per bitplane. Therefore, to manipulate it with the blitter, just perform a 
blit for each bitplane. In the figure below, you can see a
screen with 3 bitplanes, with a 3-line high image highlighted.
In memory, the lines of each bitplane constitute a different rectangle
of words (we have indicated in each line of the image the bitplane to which it
belongs). As you can see, the rows of each bitplane are close to each other and
far from the rows of the other planes, so they must be manipulated
with different blits.

+----------------------------------------+
|ииииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииии#####1####иииииииииииииииии|
|ииииииииииии#####1####иииииииииииииииии|
|ииииииииииии#####1####иииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|

|ииииииииииииииииииииииииииииииииииииииии|
+----------------------------------------+
|ииииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииии#####2####ииииииииииииииииии|
|ииииииииииии#####2####иииииииииииииииии|
|ииииииииииии#####2####иииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|

|иииииииииииииииииииииииииииииииииииииии|
+----------------------------------------+
|иииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииии#####3####ииииииииииииииииии|
|ииииииииииии#####3####ииииииииииииииииии|
|ииииииииииии#####3####ииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|

|иииииииииииииииииииииииииииииииииииииии|
+----------------------------------------+

Fig. 13     Screen with an image highlighted.

For example, if we have a figure to draw on the screen, first we blitter
the first plane of the figure to the first plane of the screen, then the second
plane of the figure to the second plane of the screen, then we do the same
with the third plane and so on with the others. Usually, therefore, a blitter loop is used,
 like the following:

move.w    #NUMEROPLANES-1,d1    ; loop counter
LOOP:
waitblit:            ; wait for the blitter to finish
btst    #6,2(a5)    ; the previous blit
bne.s    waitblit

move.l    #$09f00000,$40(a5)    ; bltcon0 and BLTCON1 - copy from A to D

;    load the other blitter registers
;    start the blit

dbra    d1,LOOP        ; loop

The values to be loaded into the blitter registers are always the same for
every blit, except of course for the BLTxPT registers,
because the addresses of the various bit planes are different. At this point
the formula we have seen comes into play. Using this formula,
 knowing the addresses to write in the BLTxPT registers for the first
blit (i.e. for the blit relating to the first bit-plane), we are able to
calculate the addresses to be written in the BLTxPT registers for the subsequent blits
(i.e. relating to the subsequent bit planes). It is sufficient to put
the address relating to the first bit plane in a variable and add
2*H*V to this address at each loop.

In the example lesson9f1.s you can see this technique applied. However,
loops of this type are not always used.

In the examples lesson9f2.s and lesson9f3.s there are other examples of
‘colour’

blitting. However, there is another way of arranging the bitplanes in memory, which allows us
to blit all the bitplanes of an image in one go, called
"INTERLEAVED BITMAP‘ or interlaced “bitmap”. As the name suggests,
this technique consists of ’mixing" the rows of the various planes together.
Instead of first putting all the rows of the first plane, then those of the second
and so on, we first put row 0 (the first) of the first bitplane,
 then line 0 of the second bitplane, and then the lines 0 of the other planes in order;
after the lines 0 of all the planes, we put line 1 of the first plane, then
line 1 of the second, and then all the lines 1 of the other planes; then we continue
like this with the other lines. To understand this better, look at the following figure and
compare it with figure 12, which shows the normal arrangement
of the bit planes.


____ ____ ____ ____ _ _ _ _ _ _ ____
| | | | |        | |
| 0 | 1 | 2 | 3 |     | 19 |    line 0 bitplane 1
|____|____|____|____|        |____|
| | | | |        | |
| 20 | 21 | 22 | 23 |        | 39 |    row 0 bitplane 2
|____|____|____|____|        |____|
|                 |
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |
| | | | |        | |    line 0 last bitplane
|____|____|____|____|_ _ _ _ _ _|____|
| | | | |		| |
| | | | |     | |    line 1 bitplane 1
|____|____|____|____|        |____|
| | | | |        | |
| | | | |     | |    line 1 bitplane 2
|____|____|____|____|        |____|
|                 |
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |
| | | | |        | |    line 1 last bitplane
|____|____|____|____|_ _ _ _ _ _|____|
|                 |
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |
| | | | |        | |    last line bitplane 1
|____|____|____|____|_ _ _ _ _ _|____|
| | | | |        | |
| | | | |     | |    last line bitplane 2
|____|____|____|____|        |____|
|                 |


|____ ____ ____ ____         ____|
| | | | |        | |    last row
| | | | |        | |    of the last bitplane
|____|____|____|____|_ _ _ _ _ _|____|

Fig. 14 Memory representation of a multi-bitplane image
(each square is a word)
using the INTERLEAVED (or RAWBLIT) technique.

First, let's see how images can be displayed in this format,
leaving the blitter aside for a moment. The number of words that make up
the rows is always the same. What changes is the relative arrangement
of the rows. This requires two changes to the procedure we usually use
to display bitplanes. The first concerns the way we
calculate the addresses to be placed in the BPLxPT registers.
Normally, to point to the bitplanes in the copper list, we calculate the addresses
of the bitplanes following the first one, starting from the address of the first one,
adding to it each time the number of bytes occupied by a row,
multiplied by the number of rows that make up the bitplane.
This is because the first row of a bitplane is stored after the last row of the
previous bitplane, and therefore “distances” from the first row of the previous bitplane
by a number of rows equal to the height of the bitplane itself.
With the interleaved arrangement, on the other hand, the row of a bitplane is
stored immediately after row 0 of the bitplane that precedes it.
This means that in the loop that calculates the addresses of the bitplanes, we will have to
add the number of bytes occupied by ONE row to the address of a bitplane each time
to obtain the address of the next bitplane.
We must also note that, unlike in the normal case, the rows that
form a bitplane are NOT arranged consecutively in memory.
In fact, between line Y and line Y+1 there are the lines of the other bitplanes.
This means that the pointer to the bitplane, every time it reaches the end of
a line, must “jump” over the lines of the other bitplanes to point
to the beginning of the next line.
As you may have already guessed, to make it jump we must use the module.
Remember that bitplanes also have their own modules, contained in the
BPLxMOD registers (where x=1 for odd bitplanes and x=2 for even ones).
With the normal arrangement of bitplanes, since the next row begins immediately after the end of a
row, we set the module to 0 (unless we want to
create a flood effect or have an image larger than the screen).
Let's see the value to set with the interleaved arrangement.
Let N be the number of bitplanes we use.
Consider bitplane 1: at the beginning of line Y, the BPLPT1 register points
to the first word of line Y of bitplane 1.
While line Y is displayed on the monitor, the BPLPT1 register
moves, pointing to the following words.
At the end of line Y, BPLPT1 points to the first word of line Y of
bitplane2.
At this point, the module is added.
We want BPLPT1 to point to the first word of line Y+1 of
bitplane 1.
We must therefore skip lines 2, 3, etc. up to N.
In total, this is N-1 lines (for example, if we have 4 bitplanes, we must
skip line Y of bitplanes 2, 3 and 4, i.e. 3 lines).
So if a line occupies L words, or 2*L bytes, the correct value of the
module is 2*L*(N-1).

____ ____ ____ ____ _ _ _ _ _ _ ____
| | | | |        | |
| | | | |     | |    Y row bitplane 1
|____|____|____|____|        |____|
/    | | | | |        | |
|    | | | | |        | |    Y row bitplane 2
|    |____|____|____|____|        |____|
|    |                 |
|    |                 |
|
|
we must skip
these N-1 lines
|
|
|    |____ ____ ____ ____         ____|
|    | | | | |        | |
|    | | | | |        | |    Y line bitplane N
\    |____|____|____|____|_ _ _ _ _ _|____|
| | | | |        | |
| | | | |     | |    line Y+1 bitplane 1
|____|____|____|____|        |____|

Fig. 15 Module value with the INTERLEAVED technique.


Of course, all the images we want to display on the screen must 
have the bitplanes arranged in interleaved format.
  
All
conversion programs support this format, although many
call it by other names. In particular, the KEFRENS CONVERTER that we used
in the course calls this format ‘RAW-BLIT’. Other converters call it
‘RASTER MODULE’. Therefore, be careful to convert the image to the correct
format, otherwise you will not see anything and you will spend hours searching your
program for a non-existent BUG!

In lesson 9g1.s, you can see an example of an interleaved bitmap display.
___
_/ г\
/ .г\
/._/\\_\ \ \
(( _/\__\\ \<
/\/__. \_. \
<__ \Э\\__Y\\ \
____< »»___/// /
/Э Y .// /
// |_ э---|` ./
/` /\__ ^/\ |
/. . [_ \_/ \|
.// _/ \_/ ~\
|( | , \
|? | ( . / ))
|и | Э Y // _
| _ | ? | / \ (%)
| |_| | | ? ` /"XI_I_
?_| |_? ? и\ ` [____г\
/?? ??\ и \_ [____ ()
 ( ._ _. \_[_____/
\_____/ \_/ |эaXeэ|
X_____X

Let's now see why this format is convenient for using the blitter.
The following figure shows an interleaved screen with
a rectangular area highlighted inside it. As you can see, the lines that form
the various bitplanes are ‘mixed’ together and form a single rectangle in
memory (we have indicated in each line of the image the bitplane to which it
belongs). Compare this figure with Figure 13, which showed a
similar situation on a ‘normal’ screen. In the normal case, the lines of the N
bitplanes of the image form N distinct rectangles of words, each
as many lines high as there are lines in the image. In the interleaved case, however,
the lines of the N bitplanes mix together to form a single rectangle of words.
Note that this rectangle has a height equal to the height of the image
multiplied by the number of bitplanes that form it. In the figure,
 we have an image of 3 bitplanes 3 lines high.
The rectangle of words has 9 rows.

+----------------------------------------+
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|
|иииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииии#####1####иииииииииииииииии|
|ииииииииииии#####2####иииииииииииииииии|
|ииииииииииии#####3##|
|ииииииииииииииииии|
|ииииииииииии#####2####иииииииииииииииии|
|ииииииииииии#####3####иииииииииииииииии|
|ииииииииииии#####1####иииииииииииииииии|
|ииииииииииии#####2####иииииииииииииииии|
|ииииииииииии#####3####иииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|

|иииииииииииииииииииииииииииииииииииииии|
|иииииииииииииииииииииииииииииииииииииии|
|ииииииииииииииииииииииииииииииииииииииии|
+----------------------------------------+

Fig. 16     INTERLEAVED screen with an image highlighted.

The fact that in the interleaved format the bitplane lines of an image
form a single rectangle in memory is very important because it allows us
to operate on the image using a single blit. Of course, this
blit is different from the blits we do in the normal case.
First of all, the size of the blit is different.
In fact, in the normal case, each blit has a height equal to the height
of the image, while in the interleaved case, the rectangle of words has
a height equal to the height of the image multiplied by the number of
bitplanes that form it, and therefore this must be the height of our
blit.
Secondly, the way we calculate the addresses of the
blits is different; in particular, we must change the way we calculate the address
of the first word of a row.
In the normal case, we have seen that if the rectangle to be blitted starts at
line Y, the ‘distance’ (offset) of the first word of line Y from the start
of the bitplane is equal to Y*(NUMBER OF BYTES OCCUPIED BY A LINE).
This is logical, because in a normal screen the lines of a bitplane
are consecutive in memory.
In an INTERLEAVED screen, however, things are different because the lines of
a bitplane are not consecutive.
In fact, as you know, after line Y of the first bitplane, there are the lines Y
of the other bitplanes, and after them the Y+1 line of the first bitplane.
Therefore, the distance between the first word of the Y line of the first bitplane and the
first word of the Y+1 line of the first bitplane is equal to the number of bytes
occupied by the Y lines of all the bitplanes in the figure.
Using the same reasoning, you can easily see that the distance between the first word
of the Y line of the first bitplane and the beginning of the screen is equal to:

Y*(NUMBER_OF_BYTES_OCCUPIED_BY_A_LINE)*(NUMBER_OF_PLANES)

In conclusion, therefore, the calculation of the address for bitmap a rectangle
that starts at coordinates X and Y for an INTERLEAVED screen becomes:

Word_address = (Bitplane_address)+N*2

where:
N=(Y*(NUMBER_OF_WORDS_THAT_MAKE_UP_A_ROW)*(NUMBER_OF_PLANES))+(X/16).

Performing a single blit instead of many, in addition to simplifying the
program, also makes it faster.
Note that the time taken by the blitter is (more or less) the same,
because although we only perform one blit, it has a height equal to the
sum of the heights of the blits in the normal case, and therefore requires the
same time, because the speed of the blitter is essentially determined by the
number of words it has to manipulate, i.e. by the size of the
blit.
However, performing a single blit greatly benefits the processor, as
you can see from the following diagram, which compares the operations to be performed
in the two cases (screen consisting of three bitplanes):

NORMAL SCREEN                INTERLEAVED SCREEN

1)	wait for the end                wait for the end
of the (possible) blit        of the (possible) blit
previous                previous

2)    load the registers of the            load the registers of the
blitter for the first            blitter for the first
blit                and only blit

3)    wait for the end
of the first blitter

4)    load the registers of the
blitter for the second
blitter

5)    wait for the end
of the second blitter

6)    load the registers of the
blitter for the third
blitter


As you can see, in the case of an interleaved screen, the processor has to perform fewer
operations, and above all it only has to wait once for the blitter to finish,
whereas in the case of a normal screen it has to wait a number of times equal
to the number of bitplanes. Since during a wait the processor does nothing
useful and does not need to rest, it is advisable to make it work as much as
possible by reducing the number of waits.

The example lesson9g2.s is the INTERLEAVED version of the example lesson9f1.s.
Look at them together, noting the differences between them.

The example lesson9g3.s, on the other hand, is the INTERLEAVED version of the example
lesson9f3.s. Compare these as well.
........
.::::::::::::::.
::::::::::::::::
::: :::::::::.
::: :::::::
::(__ ___ :::::::
.::/_) /__, :/_\::::.
.:::o/ o .: //::::::
.::/ .::./::::::
::(__ ) .:: ::::::
.::/() .:: ::::::'
_n_____________n__ (___ ::::
|-----------\\\--__F \ ~ |
|_____________ (O_.\________ __________\___. ./X\
\(__D)__\ \\ ~~~~~~ \______/.xST\
`-(___O)|_ || . XX|
(___O) \_// : .: . О|
(__O)///__________ //________.: : .|
~~~ : : :.
 . .

*******************************************************************************
*                MASKS                 *
*******************************************************************************

The blitter has the ability to mask the first and last words of each
line that passes through channel A. Masking means reading only
some bits of those words and ignoring the others. This operation is
performed by two registers, which we have used so far without explaining their
meaning. These two registers are called BLTAFWM ($dff044) and BLTALWM
($dff046), and are used to mask the first and last words
of each line read through channel A, respectively. Each of them contains a word,
called a mask. When the blitter reads the first or last word of a line,
 it performs a logical AND operation between the word read and the corresponding mask
. The bits of the word read from channel A corresponding to
bits set to 0 in the mask will be deleted.
Let's look at some examples:

word read from
channel A    %1001101100010111

mask    %1111111100000000
_________________________________

result    %1001101100000000

In this way, we have selected only the 8 bits furthest to the right of the word.

word read from
channel A    %1001101100010111

mask    %1111110000111111
_________________________________

result    %1001100000010111

In this way, we have reset the 4 bits in the centre of the mask.
If we completely reset the mask, we delete the entire word:

word read from
channel A    %1001101100010111

maschera	%0000000000000000
_________________________________

risultato	%0000000000000000

If, on the other hand, we set the mask to the value $ffff=%1111111111111111=-1, the mask
does not delete anything, i.e. it “passes” the entire word:

word read by
channel A    %1001101100010111

maschera	%1111111111111111
_________________________________

risultato	%1001101100010111

In all the examples we have seen so far, we have not needed to
mask anything and, in fact, we have initialised both masks to the
value $ffff.

The first word of each line (i.e. the word furthest to the left) is ‘ANDed’ with
BLTAFWM, and the last word (the rightmost word) is ‘ANDed’ with BLTALWM.
You can easily remember this because the F in the name BLTAFWM stands for ‘First’
which, as everyone knows, means “first”, and the L in BLTALWM stands for ‘Last’,
i.e. last. Of course, the two masks can be different from each other
(otherwise, what would be the point of having two registers?). If the line width is one
single word, both masks are applied simultaneously to the
same word. Since the two registers BLTAFWM and BLTALWM have consecutive addresses,
 they can be initialised with a single MOVE instruction.L #mask,$dff044.
It is important to note that the masks are applied to the data BEFORE 
executing the SHIFT. Channels B and C, on the other hand, do not have the ability to
mask the words read.

In the example lesson9h1.s, we show the effect of masks with simple
copy operations.

In lesson9h2.s, we demonstrate the usefulness of masks
in ‘extracting’ only the part of an image that interests us.

In lesson9h3.s and lesson9h4.s, we present two new effects created with
the help of masks.

The examples lesson9h2r.s, lesson9h3r.s and lesson9h4r.s are the
rawblit (interleaved) versions of lesson9h1.s, lesson9h2.s and lesson9h3.s.
Compare them, noting all the differences
(in particular, note that all the routines in the interleaved version do not
need to loop to blitter on each plane, and therefore have a
much simpler structure).

After seeing the new effects, let's go back to an old one, i.e.
the fish swimming on the screen, to discover that, with our new
knowledge of the blitter, we can make an important improvement.
We have seen, in fact, that to shift a figure correctly, it is necessary to
add a ‘column’ of zeroed words to the right of the figure. This
forces us to waste more memory than necessary to store the figures.
But now, thanks to masks, we can avoid this waste.
To shift, the last word of each line of the figure must be
zeroed.
Instead of reading a zeroed word directly from memory, we can
read a word of any value and zero it using the mask.
Since masking is performed BEFORE the shift, the
shift circuit will still receive the last word of each line reset, and everything will
proceed as if the reset word had been read from memory.
Since the value of the last word in the row is irrelevant, we can
read a word of any value.

Let's try the following game: we don't add any words to
the right of the image, but without telling the blitter, i.e. we set the width
of the blitter as if there were one more word to the right of the figure.
 
The blitter, therefore, after reading the last word of a line, will think it
needs to read one more word, and will therefore read the word following
the last one in the line. What is this word? If we use an image in
normal format, it will be the first word of the next line of the same bitplane,
while if the image is in interleaved format, it will be the first word of a
line of another bitplane. In any case, it will still be a non-zero word, but
this is not a problem for us because we can reset it with the mask.
At this point, we only have one small problem: since we have read one word too many,
 the source pointer has moved forward by one word,
so when it starts reading the next line, it will start from the second
word instead of the first. How can we move the pointer back?
With the old negative module trick, of course! By setting the module
of the source to -2 (the module is expressed in bytes), the blitter repositions itself
on the first word of the next line. Let's summarise everything by returning to the example
of the fish that we used to illustrate the shift. We therefore have an image
of a single bitplane, 1 word wide and 6 lines high. As we said, we do NOT
add the column of words on the right.

SOURCE
word 1
line 1 1000001111100000
" 2 1100111111111000
‘ 3        1111111111101100
’ 4        1111111111111110
" 5        1100111111111000
" 6        100000111110000

Fig. 17 Do NOT add any columns of words

However, let's pretend that the extra column is there, and therefore we bleed
a rectangle 2 words wide and 6 lines high. The blitter then reads 2 words
per line, taking the first word of the next line as the second word.
Let's see in particular, with the help of the following figure, what happens during
the reading of the first line:

SOURCE
word 1
line 1 1000001111100000--------
" 2 1100111111111000--------+-----------------------
‘ 3        1111111111101100    |            |
’ 4        1111111111111110    |            |
" 5        1100111111111000    |			|
" 6        1000001111100000    |            |
|            |
V            V
WORDS READ
FROM CHANNEL A            1000001111100000    1100111111111000
|            |
|            |
V            V
THE LAST WORD OF THE
LINE IS MASKED        1000001111100000    0000000000000000
|            |
|            |
V			V

SHIFT (2 pixels)            0010000011111000    0000000000000000
|            |
|            |
V            V

Written to channel D    Written to channel D

Fig. 18     Shift with last word reset.


As you can see, the second word read is reset before being shifted.
After the shift, the two words are written through channel D.
In the meantime, the pointer to channel A has moved forward by two words,
and points to the first word of the third line.
 Instead, we need to make it point to the first word of the second line, i.e. we need to move it back
one word. We therefore use a module equal to -2. The pointer movements
are illustrated in the following figure:

SOURCE        POINTED WORD    POINTED WORD    POINTED WORD
AT THE BEGINNING    AFTER THE FIRST    ADDING
|		LINE        THE MODULE
1000001111100000    <----         |         |
1100111111111000    <-------------------+--------------
1111111111101100    <-------------------
1111111111111110
1100111111111000
100000111110000

Fig. 19     Movement of the pointer to the source.

To see our fish in action, see the example lesson9i1.s.

By now, we know how to move figures on the screen very well using the blitter.
These figures are called BOBs, which is an abbreviation of the term
‘Blitter OBject’, i.e. objects created by the blitter.
With BOBs, we can do the same things we know how to do with hardware sprites
. BOBs are slower than sprites because the blitter takes
some time to copy data. On the other hand, however, BOBs do not suffer
from the limitations of sprites in terms of size, colours and maximum number.
In fact, a BOB can be as large as we want (obviously, however, as
the size increases, so does the amount of memory occupied and
consequently the time needed by the blitter to move it), and it can have
the same number of colours as the screen.
Furthermore, there is no limit to the number of BOBs
simultaneously on the screen (obviously, however, the more BOBs there are, the more
time we lose drawing them).
‘Great,’ you might say, ‘we can start making a game!’ Hold on, let's not
get too excited. Are we really sure we can do the same things with BOBs
that we can do with sprites?

Let's look at lesson9i2.s and its ‘twin’ in interleaved format, lesson9i2r.s.

We have a coloured BOB that we can move freely around the screen with the mouse.
But there's a problem... when we move the BOB, we erase the background!
This doesn't happen with sprites, because sprites are small
bitplanes separated from the background bitplanes.
BOBs, on the other hand, are drawn directly on the bitplanes of the background image,
so they partially overwrite it.

We present a first solution to the problem in the examples lesson9i3.s and
lesson9i3r.s (the second is, of course, the rawblit version of the first).

As you will see, however, it is not yet satisfactory.

In the example lesson9i4.s, we try another solution, but it also has
problems.

In the example lesson9i5.s, on the other hand, we see an example of a BOB moved by the joystick
that partially exits the screen.

We have begun to learn about BOBs, but for now we have not achieved a
satisfactory result, i.e. being able to perform typical video game operations with BOBs
due to the background problem. Unfortunately, with what
we know so far, we cannot do any better.

But don't worry: there is still a lot to learn about the blitter, and
one of these things will help us solve the problem!
So, let's keep going, there's still a long way to go!
.
) \\\..
( __/ __ \
)
 (.__.) O
( n_______n /(__, \
|________ }__________/ ____, )__
((O) \\. (__________/ \
=(_O) | /( )\ \
(_O)|_______ \_\ /_/ \ )
\ \)(/ | /)
 /. \ |/
| / . \ |
| (__.___) |
|_|==()==|___|
| _ |
| | |
| | |

*******************************************************************************
*        COPYING OVERLAPPING MEMORY AREAS             *
*******************************************************************************

We will now illustrate another feature of the blitter, taking inspiration from
copying rectangles, an operation we are now familiar with. What happens if
the source and destination of the blitter are overlapping, i.e. they are
two word rectangles that have parts in common? It is obvious that the blitter
will modify the entire destination, including the parts in common with the
source.
Copying between overlapping areas therefore consists of placing the contents of the
source BEFORE copying to the destination.
After copying, the contents of the source will have changed.
Therefore, after copying, the destination will NOT be the same as the source!
Rather, we repeat, it will be the same as the source was BEFORE
copying!
In short, imagine that the destinationaction is a photograph taken of the
source, and that during the time it takes the photographer to develop the
photo, the source has aged rapidly so that it looks very different
from how it appears in the photo.
Should we always make a copy in such conditions?
We need to study the problem carefully.
Let's see what happens with an example of a copy of a rectangle 2
lines high and 3 words wide.
Let's assume that the source is lower than the destination, as
illustrated in the following figure:

____ ____ ____ ____ ____ ____
| |\\\\|\\\\|\\\\| | |
| |\\\\|\\\\|\\\\| | |
|____|\\\\|\\\\|\\\\|____|____|        rect. SOURCE=////
| |\\\\|XXXX|XXXX|////| |
| |\\\\|XXXX|XXXX|////| |        rect. DESTINATION=\\\\
|____|\\\\|XXXX|XXXX|////|____|
| | |////|////|////| |        rect. IN COMMON=XXXX
| | |////|////|////| |
|____|____|////|////|////|____|
| | | | | | |
| | | | | | |
|____|____|____|____|____|____|


Fig. 20     Blittata between overlapping rectangles

Let's analyse the subsequent phases
of the operation with the help of a series of figures. Let's use the letters A, B, C, D, E, and F to indicate the content of the 6
words we want to copy, and the symbol ‘?’ to indicate the content of the words
we are not interested in, which we can therefore delete.
Before starting to copy, we have the following situation:

____ ____ ____ ____ ____ ____
| |\\\\|\\\\|\\\\| | |
| | ? | ? | ? | | |
|____|\\\\|\\\\|\\\\|____|____|        rett. SOURCE=////
| |\\\\|XXXX|XXXX|////| |
| | ? | A | B | C | |        rett. DESTINATION=\\\\
|____|\\\\|XXXX|XXXX|////|____|
| | |////|////|////| |        rect. IN COMMON=XXXX
| | | D | E | F | |
|____|____|////|////|////|____|


Fig. 21a Blittering between overlapping rectangles

As we know, the blitter copies words one at a time, starting from the top left
and continuing downwards and to the right. The first line
is read and copied to an area of the destination that is not shared, and which
we can therefore safely overwrite. Here is the situation after copying
the first line:

____ ____ ____ ____ ____
| |\\\\|\\\\|\\\\| | |
| | A | B | C | | |
|____|\\\\|\\\\|\\\\|____|____|        rett. SOURCE=////
| |\\\\|XXXX|XXXX|////| |
| | ? | A | B | C | |        rett. DESTINATION=\\\\
|____|\\\\|XXXX|XXXX|////|____|
| | |////|////|////| |        rect. IN COMMON=XXXX
| | | D | E | F | |
|____|____|////|////|////|____|


Fig. 21b Blittata between overlapping rectangles

At this point, we need to copy the second row. The second row of the
destination overlaps with the first row of the source. This means
that when we write the data to the destination, we will overwrite part
of the source, destroying its contents. Note, however, that the overwritten data belongs to the FIRST row of the source, which we have already
and therefore no longer need. Therefore, there are no problems.
The situation after copying the second (and last) row is as follows:

____ ____ ____ ____ ____ ____
| |\\\\|\\\\|\\\\| | |
| | A | B | C | | |
|____|\\\\|\\\\|\\\\|____|____|        rett. SOURCE=////
| |\\\\|XXXX|XXXX|////| |
| | D | E | F | C | |        rett. DESTINATION=\\\\
|____|\\\\|XXXX|XXXX|////|____|
| | |////|////|////| |        rect. IN COMMON=XXXX
| | | D | E | F | |
|____|____|////|////|////|____|


Fig. 21c Blitting between overlapping rectangles

We have achieved exactly what we wanted, as the destination rectangle
destination rectangle is an exact copy of the contents of the source rectangle BEFORE
we started the blitting. Note that now, however, the contents of the source
have changed, but this was inevitable.

You can see all this in practice in the example lesson9l1.s.

It would therefore seem that overlapping between source and destination does not create
problems. However, let's examine the case where the destination is
lower than the source:

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| |////|////|////| | |
|____|////|////|////|____|____|		rett. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| |////|XXXX|XXXX|\\\\| |        rett. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |        rett. IN COMMON=XXXX
| | |\\\\|\\\\|\\\\| |
|____|____|\\\\|\\\\|\\\\|____|
| | | | | | |
| | | | | | |
|____|____|____|____|____|____|


Fig. 22     Blit between overlapping rectangles

Before the blit, the situation is as follows:

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| | A | B | C | | |
|____|////|////|////|____|____|        rect. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| | D | E | F | ? | |		rect. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |        rect. IN COMMON=XXXX
| | | ? | ? | ? | |
|____|____|\\\\|\\\\|\\\\|____|

Fig. 23a Blittata between overlapping rectangles

Let's start by copying the first line. The first line of the destination is
partially overlapped with the second line of the source, which has not
yet been copied. Here is what we get:

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| | A | B | C | | |
|____|////|////|////|____|____|        rect. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| | D | A | B | C | |        rect. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |        rect. IN COMMON=XXXX
| | | ? | ? | ? | |
|____|____|\\\\|\\\\|____|

Fig. 23b Blittata between overlapping rectangles

As you can see, we have lost the values E and F! It seems that this time
the copy will not work! However, let's copy the second line as well, and see
what happens.

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| | A | B | C | | |
|____|////|////|////|____|____|        rett. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| | D | A | B | C | |		rect. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |        rect. IN COMMON=XXXX
| | | D | A | B | |
|____|____|\\\\|\\\\|\\\\|____|


Fig. 23c Blitting between overlapping rectangles

That's it. The blitting is finished, but the result is not what we wanted.
Are you convinced?

No? Then take a look at the example in lesson9l2.s and see for yourself!

Let's try to understand why it worked the first time and not this time.
The problem arises when we write on parts of the destination that
overlap with the source, because by doing so we overwrite some
data.
In the first case, there were no problems because we had already copied the overwritten data
.
This happened because the source is located lower (at higher addresses)
 than the destination, and the overlap occurs between the first
line of the source and the second line of the destination.
Since the blitter copies starting from the first line, the data in the first line
of the source are copied BEFORE being overwritten by the second line
of the destination.
In the second case, however, the source is located higher (at lower addresses)
 than the destination, and the overlap occurs between the second
line of the source and the first line of the destination.
The data in the second line of the source is therefore overwritten during
the copying of the first row, i.e. BEFORE being copied in turn,
and is therefore lost.
To solve this problem, you should copy the second row first and
then the first.
This is possible using the DESCENDING MODE of the blitter.
When using this mode, the blitter performs the copy (or any other
other operation) in the opposite direction to what it usually does, i.e. it starts from the
bottom right word of the rectangle and continues to the left and upwards
.
The words that are blitted following this path have progressively lower addresses.
It is therefore said that the blitter DESCENDS along the memory, hence the name of the
mode of operation (by contrast, the normal mode is also called ASCENDING MODE,
 because normally words with increasingly higher addresses are blitted
).
Before examining in detail how to use the blitter in descending mode,
let's return to the problem of copying overlapping regions and verify that 
descending mode is the right solution.
The starting situation is as follows:

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| | A | B | C | | |
|____|////|////|////|____|____|        rett. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| | D | E | F | ? | |        rect. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |        rect. IN COMMON=XXXX
| | | ? | ? | ? | |
|____|____|\\\\|\\\\|____|

Fig. 24a Blittata between overlapping rectangles

This time we use the descending method, so we start copying from
the last line. This way, we don't write on the overlapping part at the beginning
:

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| | A | B | C | | |
|____|////|////|////|____|____|        rett. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| | D | E | F | ? | |        rett. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |        rect. IN COMMON=XXXX
| | | D | E | F | |
|____|____|\\\\|\\\\|\\\\|____|

Fig. 24b Blitting between overlapping rectangles

Now let's copy the first line. In doing so, we overwrite the second line of the
source, but since we have already copied it, this is not a problem:

____ ____ ____ ____ ____ ____
| |////|////|////| | |
| | A | B | C | | |
|____|////|////|////|____|____|        rect. SOURCE=////
| |////|XXXX|XXXX|\\\\| |
| | D | A | B | C | |        rect. DESTINATION=\\\\
|____|////|XXXX|XXXX|\\\\|____|
| | |\\\\|\\\\|\\\\| |		rect. IN COMMON=XXXX
| | | D | E | F | |
|____|____|\\\\|\\\\|\\\\|____|

Fig. 24c Blitting between overlapping rectangles

OK! This time we've got it. Now the destination looks the same as the
source before blitting.
To conclude, we can therefore say that when we make a copy with
the source and destination overlapping, if the source is located at memory addresses
higher than the destination, the blit must be done in the
normal (ASCENDING) mode, whereas if the source is located at lower memory addresses,
 the DESCENDING mode must be used.
__________
/ \
|_________ _ |
/ _______ \| |
| / o_o \ | |
\| ___ |/\_|
_____|\/ = \/|_(_)__
/ | | \
/ | | \
/ _. \_____/ __ _\_____
___/__ | o | _\_ \____
/ \_ \| o |/ __\__| /
| |) |\_______________/|\(__/ \_/__/__
O==o==O_/| ||__|| | / ____ \_
| `-' | \____||__||_____/ / / _ ___ \
| sk8 | \ / ( / (_)\/ \ |
| .-. | |_____Y_____| \ / \/ /
O==o==O __| | _|_ | “ )
| | / `` | ”' \ ( /
\___/ (_________|________) \_____________)

At this point, we can go into detail about the descending mode.
First of all, the descending mode must be activated by a control bit.
This is bit 1 of the BLTCON1 register, which, when set to 1, activates the descending mode,
 while when it is reset (as we have done so far),
 it activates the ascending mode.
As we have already mentioned, in descending mode, the blitter goes “backwards”,
 i.e. it moves between memory locations with progressively lower addresses.
For this reason, the DMA channel pointers must point at the beginning
of the blit to the blit word with the highest address,
i.e. the first word to be blitted.
As you know, this is the lowest and rightmost word of the
rectangle of words to be blitted.
For example, if you want to blit a rectangle 3 words wide and
2 rows high, you must initialise the pointers with the address of the third
word of the second row of the rectangle, which is indicated in the figure with two
asterisks (**)

____ ____ ____ ____ _ _ _ _ _ _ ____
| | | | |        | |
| | | | |     | |
|____|____|____|____|        |____|
| |\\\\|\\\\|\\\\|        | |
| |\\\\|\\\\|\\\\|        | |
|____|\\\\|\\\\|\\\\|        |____|
| |\\\\|\\\\|\\\\|        | |
| |\\\\|\\\\| ** |        | |
|____|\\\\|\\\\|\\\\|        |____|
| | | | |        | |
| | | | |     | |
|____|____|____|____|        |____|
|
|                 |

Fig. 25 Word rectangle with the word
to be pointed to at the beginning of the blit highlighted

To calculate the address of this word, follow a similar reasoning to that
used in the ascending case. We need to calculate the distance (offset) of this word
from the beginning of the bitplane. Suppose we know the Xa and Ya coordinates of the
pixel at the top left of the rectangle, as well as the width in words L
and the height A of the rectangle. The word we are interested in belongs to the last
row of the rectangle with coordinates Yb=Ya+A. The offset of the first word of
this row is given by the following formula:

OFFSET_Y = 2*(Yb*NUMBER_OF_WORDS_PER_ROW)            in the normal case and

OFFSET_Y = 2*(Yb*NUMBER_OF_WORDS_PER_ROW*NUMBER_OF_PLANES)    in the interleaved case.

Now we need to calculate the distance between the first word of the row and the last word
of the rectangle. As we know, this distance is given by 2*(Xa/16).
On the other hand, between the first and last words of the rectangle there are L-1 words, which
are equivalent to a distance (expressed in bytes) of 2*(L-1).
Adding the two differences, we have:

OFFSET_X=2*(Xa/16+L-1).


| |        | |\\\\|\\\\|    |\\\\|
| A |        | | B |\\\\|	| C |
|____|_ _    |____|\\\\|\\\\|_ _    |\\\\|

\____________________/\______________________/
|            |
Xa/16 words         L words

distance between word A and word B = 2*(Xa/16)
distance between word B and word C = 2*(L-1)

Fig. 26 OFFSET_X calculation

Therefore, the address to be written in the DMA channel pointers is given by:

WORD_ADDRESS = BITPLANE_ADDRESS+OFFSET_Y+OFFSET_X.

As regards the modules and the size of the blob, there are no
differences compared to the ascending case; they are all calculated using the same
formulas. Now we can finally copy two overlapping rectangular regions correctly
even when the source starts at a memory address lower
than that of the destination: this is example 9l3.s.

In descending mode, the masks and shift behave differently
than in ascending mode.
The masks always work in the same way, but the words to which they apply change
.
The mask contained in BLTAFWM is applied, as in the ascending case,
to the first word we bleed in each row.
However, since in descending mode we bleed in reverse, the first word is the
word furthest to the right of the rectangle, whereas in ascending mode it is the word furthest to the
left.
Similarly, the mask contained in BLTALWM is always applied
to the last word bled in each row, except that in descending mode this word
is the word furthest to the left. In summary:

- In ascending mode (normal), BLTAFWM is applied to the leftmost word
and BLTALWM to the rightmost word.

- In descending mode, BLTAFWM is applied to the rightmost word and BLTALWM
to the leftmost word.

If we look at the image as it appears on the screen, switching to descending mode
the masks swap the columns on which they operate. To verify this, load
and run the example lesson9m1.s, which does exactly the same things
as lesson9h1.s, except that it operates in descending mode. You will see that the masks
produce the same effects but swap the columns.

The shift, in descending mode, has a fundamental difference: it is done
to the LEFT, instead of to the right. If we specify a shift value equal to
2, for example, the source is shifted 2 pixels TO THE LEFT.
Using this feature, we can achieve the effect of scrolling
an image to the left. You can find this in the example lesson9m2.s.

At this point, we are finally able to create one of the most classic demo effects: SCROLLTEXT, which is text that scrolls across the screen from
right to left.
A simple but significant example is lesson9n1.s, where you will find all the explanations.

A simple but significant example is lesson9n1.s, where you will find
all the explanations. Please study this example carefully
because knowing how to do scrolltext is absolutely essential for
a demo coder!

In the example Lesson9n2.s you will find the scrolltext of the intro of disc1.

.-%%%-,
( )
( )
-~x~- ( )
/% %\ ( )
| | ( )
| | ( )
| __ _, (%%%%-( )
/\/\ (. ).) `_'_', ( )
C __) (.( .)-( )
| /%%% \ (_ ( )
/ \ %====“ /_____/` D)
/`-_ `---” \ |
.__|%-/~\-%|_/_ |~~~~~~~|| |
__. ||/.\ | |OooooO
\ ---. \ | | \ _
_- ,`_'_' .%\ \|__ __|-____ / )
< -(. ).) > \ ( .\ (. ) \(_/ )
%- _) \_- ooo @ (_) @ \(_//.
/ /_C (-.____) /((O)/ \ ._/\%_.
/ |_\ / / /\\\\`-----“” _|>o< |__
| \ooooO ( \ \\ \\___/ \ `_'_', /
\ \__-| \ `)\\-~\\ ~--. /_(.(.)- _\
\ \ ) |-`--.`--=\-\ /-//_ ' ( c D\
\_\_) |-___/ / \ V /.% \/\\\ (@)___/ %|
/ | / |. /`\\_/\/ / /
/ | ( C`-'` / | \/ (/ /
/_________- \ `C__-% | / (/ /
| | | \__________| \ (/

Do you understand how scrolltext works? If so,
you can start to be satisfied with what you have learned. By now
you know the basic operation of the blitter. In the next lesson
we will discover the most hidden secrets of this powerful friend, starting
with the biggest, the most difficult to understand, which we have been dealing with
throughout this lesson but have always avoided:
the operation of MINTERMS!
