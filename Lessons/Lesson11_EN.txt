__________________________________________
______ |::. .::| ______
//_____\ |:::: ASSEMBLER COURSE - LESSON 11 .::::| /_____\\
_\\ O o / |::::::::::::::::::::::::::::::::::::::::::| \ o O //_
\_/\_-_/_ ------------------------------------------' _\_-_/\_/
/ __|. \/ / \ \/ .|__ \
/____|. \__/ \__/ .|____\
.---/ |. \--------------------------------------------/ .| \---.
/ /____|____\ INTERRUPT, CIAA/CIAB, DOSLIB /____|____\ \
/ \
`-------------------------------------------------------------------------'

Author: Fabio Ciucci

(Directory Sorgenti7) - then type ‘V Assembler3:sorgenti7’

Now that you have learned more about how the blitter works, you can safely say that you know the Amiga hardware, since you know how to program the 68000, blitter and copper.
However, you never stop learning, and in this lesson we will look at some advanced information about the 68000, such as interrupts, as well as some listings. blitter and copper
. However, you never stop learning, and in this
lesson we will look at some advanced information about the 68000, such as interrupts,
as well as listings showing special uses of Blitter and Copper, and
finally the use of CIAA and CIAB chips, which we have only used so far to
test mouse pressure.
Let's start with the new information on the 68000, so that we can get off to a
better start than we did in LESSON 8.
The information on exception vectors, interrupts, etc. that will be explained
will not all be useful and indispensable for programming games and
demos, but only some of it will be needed. So don't be intimidated
by the amount of things mentioned: in practice, we will use very little of it!
First of all, we need to talk about the two operating modes of the 680x0, namely
user mode and supervisor mode. In 68000-2.txt, we mentioned, without
explaining, that there are ‘privileged’ instructions that must be
executed in supervisor mode, i.e. during an exception or an interrupt.
So far, we have always executed our routines in USER mode, i.e.
in user mode, because it was not necessary to execute privileged instructions,
and because we have not used the processor interrupts.
I must point out that the execution speed does not change between user mode and
supervisor mode, so running your program as an exception
or interrupt will certainly not affect execution.
After all, an ‘exception’ is so called because it is something
that should only occur in ‘exceptional’ cases, such as software
failure, known as GURU. Note that there are gurus that are caused by the
Amiga operating system (such as exec errors) and others that are programmed
directly by Motorola, the author of the 680x0. For example, errors such as
BUS, DIVISION BY ZERO, etc., i.e. vectors, are of this type.
You may have noticed that the operating system manages to update the position
of the mouse pointer even if we are running our own
routine, provided that multitasking is not disabled with a call to
Disable(). Well, if the processor is executing one of our loops, how does
each frame update other things? You will remember that if you disable
the system interrupts, everything stops. In fact, it uses interrupts,
which “interrupt” the execution of our little program every frame,
execute their own routine, and resume the execution of our program
where they left off, all without us noticing!
In addition to interrupts, there are other ways to execute routines in
supervisor mode, such as TRAP instructions, or any error in a
program. For example, when a division by zero occurs, or the processor
finds data that does not correspond to any instruction, the guru meditation and software failure routines are executed
in supervisor mode.
Emulators of other processors, for example, ensure that each
binary value of the emulated processor instruction, such as an 80286 or
the 6502 of the Commodore 64, corresponds to a routine that performs the operations that
that instruction would have performed for that processor (roughly speaking!).
Now, it is not the purpose of this course to teach you how to program operating systems
or emulators, since the Amiga operating system is already
the best in the world, and emulators on Amiga are unbeatable, so much so that
those who have an Amiga can run MacIntosh and MSDOS programs
and play old C64 and Spectrum games.
But even if you want to program a demo or a game, or a utility such as
protracker/octamed, it is VERY USEFUL to manage some interrupts.
Many old-style demos and games started by sending the 68000 to supervisor mode
,
 immediately writing to the SR and doing strange things with the stack.
Well, many of these games do not work on computers with 68020, because
the Status Register in more advanced processors has additional functions that
these programmers were unaware of, and by setting or clearing bits at random
, they made a huge mistake. Furthermore, in supervisor mode, the stack (SP) is a
‘private’ stack of the supervisor mode, while the user stack is accessed
with the USP (User Stack Pointer) register. In short, in supervisor mode, it is
best to tread carefully, unless you are fully familiar
with all the new features of the 68020/30/40 and also the 68060!
In fact, user mode is used precisely to avoid executing instructions that
could cause different effects on different processors, which only operating systems
need to execute. However, coders have always felt tougher
turning registers upside down in supervisor mode, with the result of gaining a
reputation as ‘programmers incapable of writing compatible code’.
But let's execute a few instructions in supervisor mode before
continuing with the theory. Among the many ways to execute a
routine in exception mode, the ‘safest’ is to use the appropriate
operating system function ‘exec.library/Supervisor’, which requires the
address of the routine to be executed to be placed in A5:

move.l    4.w,a6            ; ExecBase in a6
lea    SuperCode(PC),a5	; Routine to be executed in supervisor
jsr    -$1e(a6)        ; LvoSupervisor - execute the routine
; (do not save the registers! be careful!)
rts                ; exit after executing the routine
; ‘SuperCode’ in supervisor.

SuperCode:
movem.l    d0-d7/a0-a6,-(SP)    ; Save the registers to the stack...
                ; instructions to be executed
...                ; as if it were a subroutine....
movem.l    (SP),d0-d7/a0-a6    ; Restores the registers from the stack
RTE    ; Return From Exception: like RTS, but for exceptions.



As you can see, it couldn't be easier. The routine to be executed
can be considered as a subroutine to be called with JSR or BSR, except that
it is called with ‘JSR -$1e(a6)’ after putting its address in A5, and
of course the ExecBase in A6. At the end of the short ‘supervisor subroutine’,
instead of putting an RTS to return, you will need to put an RTE, which is specifically for
returning from exceptions and interrupts. At this point, the processor will return to
executing the instruction under ‘JSR -$1e(a6)’ in user mode, just as
if it had been a “BSR” or a ‘JSR’. The Supervisor function does not save the registers
nor does it restore them with movem, so if any are modified during the
supervisor routine, those values will remain when returning from that routine.
In this regard, I recommend saving and restoring the registers
manually at the beginning and end of the supervisor routine.
Note that accessing SP or A7 in supervisor mode saves to the supervisor stack
, not the user stack, which can be recalled as USP. This is not
a problem, because the supervisor stack saves and restores like the
user stack, but in case of dangerous stack programming, you could encounter
major problems with general implantation.
Let's execute some privileged instructions in the example lesson11a.s.
Here are the privileged instructions that can only be executed in supervisor mode:

ANDI.W    #xxxx,SR
ORI.W    #xxxx,SR
EORI.W    #xxxx,SR
MOVE.W    xxxxx,SR
MOVE.W    SR,xxxxx
MOVEC    register,register    ; 68010+ - special registers for
; cache control, MMU, vectors such as:
; CAAR,CACR,DFC,ISP,MSP,SFC,USP,VBR.
RTE

There would also be MOVES, RESET, STOP, but we are not interested in them.
The possibility of acting on the Status Register is of little interest because it is
very dangerous (given the difference in SR bits between 68000 and other 680x0),
and it is not essential to disturb it. Among other things, when jumping to an 
exception, in addition to the Program Counter, the Status
Register is also saved in the stack, and at the time of the RTE, the old value of the
Program Counter is restored, to return under the "JSR -$1e(a6)", and the old SR,
so that there are no changes except during the execution of the exception.
On the other hand, the MOVEC instruction will be of much more interest to us, because in order to
use an interrupt so that it also works on 68020+ processors, it is
necessary to know where the VBR (Vector Base Register).
As for CACHE control, I think it is best not to interfere,
so that the user can enable or disable them with utilities before
running our demo or game, in order to evaluate the differences in
settings. If, on the other hand, we decide for the user which caches should be enabled and
which disabled, we also risk creating code that does not work on the 68060
and any new RISC processors that might emulate it.
The MOVEC instruction, available only from the 68010 onwards, is used to copy
the contents of an An or Dx register to a special register, or vice versa.
Let's look at the special registers present in the 68020:

CAAR    - CAche Address Register
CACR    - CAche Control Register
VBR    - Vector Base register

There are also DFC (Destination Function Code), SFC (Source Function Code),
ISP (Interrupt Stack Pointer), MSP (Master Stack Pointer), USP (User Stack
Pointer), but these are not relevant to us, as they are only used by those who program operating systems,
 emulators, etc.
At this point, we need to know the value of the special register VBR,
we will see why later. To obtain it, all you need is ‘MOVEC VBR,d0’, for example.
But what is the Vector Base Register? First of all, we need to explain what a
vector is (not to be confused with vectors in mathematics or 3D vectors!).
First, let's look at the vector table, then we'll explain them:

NUM. VECTOR OFFSET	Assignment and meaning

0    $0    Only needed at reset (SSP start)
1    $4    Only needed at reset, in fact there is ExecBase (PC start)
2    $8    GURU/soft. failure: BUS error
3    $c    GURU/soft. failure: Address error
4	$10    GURU/soft. failure: Illegal instruction
5    $14    GURU/soft. failure: Division by zero
6    $18    Exceptions generated by CHK, CHK2 instructions (68020+)
7    $1c    Exceptions generated by TRAPV instructions (68020+ TRAPCC)
8    $20    GURU/soft. failure: Privilege violation
9    $24    Trace (trace exception)
$A    $28    GURU/soft. failure: Line emulator %1010 (LINE-A)
$B    $2c    GURU/soft. failure: Line emulator %1111 (LINE-F)
$C    $30    not used
$D    $34    Coprocessor protocol violation (68020+)
$E    $38	Format error (only 68020, after CALLM,RTM)
$F    $3c    Interrupt not initialised
...
    ...

$18    $60    Spurious interrupt

; Here are the interrupt vectors: these are the ones we are interested in!

$19    $64    INTERRUPT level 1 (softint, dskblk, tbe)
$1a    $68    INTERRUPT level 2 (ports: I/O, ciaa, int2)
$1b    $6c    INTERRUPT level 3 (coper, vblanc, blit)
$1c    $70    INTERRUPT level 4 (audio channels aud0/aud1/aud2/aud3)
$1d    $74    INTERRUPT level 5 (rbf,dsksync)
$1e    $78    INTERRUPT level 6 (exter: ciab, int6 + inten)
$1f    $7c    INTERRUPT level 7 (external hardware cards: NMI)

$20    $80    Vector callable with TRAP #0
$21    $84    Vector callable with TRAP #1
$22    $88    Vector callable with TRAP #2
$23    $8c    Vector callable with TRAP #3
$24    $90    Vector callable with TRAP #4
$25    $84    TRAP vector #5, etc., up to TRAP #15
...

follow vectors for errors of the possible math coprocessor
and MMU, which are not of interest to us.


-| |- 
-| [-_-_-_-_-_-_-_-] |- 
[-_-_-_-_-] | | [-_-_-_-] 
| o o | [ 0 0 0 ] | o o |
 
| | -| | | |- | |
| |_-___-___-___-| |-___-___-___-_| |
| o ] [ 0 ] [ o |
| ] o o o [ _______ ] o o o [ | ----__________
_____----- | ] [ ||||||| ] [ |
| ] [ ||||||| ] [ |
_-_-|_____]--------------[_|||||||_]--------------[_____|-_-_
( (__________------------_____________-------------_________) )
 


Let's imagine the situation of a 68000 processor, for which it is not necessary to
search for the value of the VBR register (it doesn't even exist!).
In this case, the offset is the memory location itself! $0 = $00000000
At address $4 we find the Execbase, while the first long at $0 is usually
set to zero. But “inside” location $8 we find the address of the
routine that displays the message “GURU MEDITATION/SOFTWARE FAILURE” in the event
of a BUS ERROR. In fact, as seen in 68000-2.TXT, this guru has the identification number
#00000002, which is its vector number.
The third vector contains the address of the routine that displays the guru
of ADDRESS ERROR (#00000003), and so on.
In practice, when the processor finds one of these errors, it jumps to the corresponding vector,
 which contains the address of the routine to be executed in
supervisor mode (given the seriousness of the situation!).
When the system is reset, all the addresses in the vectors are written from the ROM
from the first to the last. If you have small programs that modify the messages of
software failures or gurus, be aware that they cause the vectors to “point” to their 
routines, rather than to the normal system routines.
Of course, there are “legal” ways to change the vectors, i.e. by going through
operating system structures and routines. Simply writing the address
of your routine in the vector may be ineffective or incompatible.
For example:

MOVE.L    #MyDivisionByZero,$14.w    ; replace the
; guru vector from div. by zero.
rts

MyDivisionByZero:
...
RTE

NEVER DO AS IN THIS EXAMPLE, FOR A COUPLE OF REASONS. THE FIRST is that
IN THE 68020+ IT IS NOT CERTAIN THAT SUCH A VECTOR IS LOCATED AT ADDRESS $14, THE SECOND
is that it is a method that is incompatible with MMU and Amiga operating system structures.
AMIGA.
However, in theory this system should work, and on Amiga500 it works
almost always, provided that the supervisor routine is written correctly.
However, we are not interested in modifying the error/guru vectors, because
our program should not contain errors to be corrected when
jumping to guru/software failure!
We are also not very interested in the ‘TRAP #xx’ instruction vectors. These vectors
were used in the past to go into exception, but we have already seen a safer way
to do this, using the operating system.
However, for your curiosity, the ‘old’ way was:

move.l    $80.w,OldVector        ; Save the old TRAP vector #0
move.l    #SuperCode,$80.w    ; Routine to be executed in supervisor
; placed in TRAP vector #0
TRAP    #0			; Execute Supercode as an exception
move.l    OldVector(PC),$80.w    ; Restore the old TRAP vector #0
rts                ; Exit after executing the
; ‘SuperCode’ routine in supervisor.
OldVector:
dc.l    0

SuperCode:
movem.l    d0-d7/a0-a6,-(SP)    ; Save the registers in the stack
...                ; instructions to be executed
...
                ; as if it were a subroutine....
movem.l    (SP),d0-d7/a0-a6    ; Restore the registers from the stack
RTE    ; Return From Exception: like RTS, but for exceptions.

As you can see, it is easy to understand the function of the TRAP instruction: in
practice, if you execute a ‘TRAP #0’, the routine whose address is contained in .l at address $80 is executed as an exception, while
with the ‘TRAP #1’ instruction, the one in $84 is executed, and so on.
Similarly,
the interrupts contain the address of the routine to be executed in case of an interrupt. The old way of setting an interrupt was: move.l    $6c.w,OldInt6c        ; Save the old int level interrupts contain the address of the routine to be
executed in case of an interrupt. The old way to set an interrupt was:

move.l    $6c.w,OldInt6c        ; Save the old int level 3
move.l    #MyInt6c,$6c.w        ; My routine for int level 3

At the end of the programme, the old interrupt was restored in $6c.
In this interrupt, ‘BSR.w MT_MUSIC’ is usually placed, since
this interrupt (VERTB) is executed once per frame.

_----| _ _ _ _ _
----|_----| ]-I-I-I-[
 
_ _ _ _ _ _ _----| | ----| \ ` ' /
]-I-I-I-I-[ ----| | | |. ` |
\ ` '_/ | / \ | | /^\|
[] `__| ^ / ^ \ ^ | |*||
|__ ,| / \ / ^ ^`\ / \ | ===|
 
___| ___ ,|__ / ^ /=_=_=_=\ ^ \ |, `_|
I_I__I_I__I_I (====(_________)_^___|____|____
\-\--|-|--/-/ | I [ ]__I I_I__|____I_I_| 
|[] ` '|_ |_ _|`__ ._[ _-\--|-|--/-/
 
/ \ [] ` .| |-| |-| |_| |_| |_| | [] [] | 
<===> .|-=-=-=-=-=-=-=-=-=-=-| / \
] []|` ` [] | . _________ . |- <===>
<===> ` “ |||| | | ||| | [] <===>
\_/ -- |||| | | ||| | . ” \_/
./|' . . . .|||||/|_______|\|||| /|. . . . .|\_ 
- ---------------------------------------------------
 

*******************************************************************************
*        THE VBR REGISTER IN 68010 AND HIGHER PROCESSORS     *
*******************************************************************************

You may be wondering what the VBR has to do with vectors. Well, the Vector
Base Register is the BASE address to which offsets are added to find
the address of the vectors. If VBR=0, then level 3 interrupt will be found
at address $6c, as in the 68000, and similarly TRAP #0 will always be found
at $80, and the examples seen above would work.
But if VBR were at $10000, level 3 interrupt would no longer be found
at $6c, but at VBR+$6c, i.e. at $1006c! The same applies to all other vectors.
So, in general:

vector address = VBR + OFFSET

On the 68000 processor, the base is always $0000, so much so that there is no
VBR register or MOVEC privileged instruction. But on 68010 and above, the VBR can
be moved to other locations, even to FAST RAM.
After a reset, the VBR is always reset to zero, whether on the A3000, A1200
or A4000. The VBR is moved by running SETPATCH or other utilities.
In fact, many demos/games on files that work when started on their own
from a disk without first loading the setpatch do not work when loaded
from the Workbench shell. Some work but are “silent”, precisely because
they write their interrupt, which only plays the music, in $6c, when
the VBR points further ahead than $0000.
Given that we know this, we just need to check if the processor is a 68000 or
a 68010+, and if it is a 68010 or higher, take the VBR value
and add it to the vector you want to change.
Here's how to do it in practice:

move.l    4.w,a6        ; ExecBase in a6
btst.b    #0,$129(a6)    ; Check if we are on a 68010 or higher
beq.s    IntOK        ; it's a 68000! So the base is always zero.
lea    SuperCode(PC),a5 ; Routine to be executed in supervisor
jsr    -$1e(a6)    ; LvoSupervisor - execute the routine
; (do not save the registers! be careful!)
bra.s    IntOK        ; We have the VBR value, let's continue...

;**********************SUPERVISOR CODE for 68010+ **********************
SuperCode:
movem.l    a0-a1,-(SP)    ; Save a0 and a1 in the stack
dc.l 	$4e7a9801    ; Movec Vbr,A1 (instruction 68010+).
; It is in hexadecimal because not all
; assemblers assemble movec.
lea    BaseVBR(PC),a0    ; Label where to save the VBR value
move.l    a1,(a0)        ; Save the value.
movem.l    (SP)+,a0-a1    ; Restore the old values of a0 and a1
RTE            ; Return from the exception
;*****************************************************************************

BaseVBR:
dc.l    0

IntOK:
move.l    BaseVBR(PC),a0     ; In a0 the value of VBR
move.l    $64(a0),OldInt64 ; Sys int liv 1 saved (softint,dskblk)
move.l    $68(a0),OldInt68 ; Sys int liv 2 saved (I/O,ciaa,int2)
move.l    $6c(a0),OldInt6c ; Sys int liv 3 saved (coper,vblanc,blit)
move.l    $70(a0),OldInt70 ; Sys int liv 4 saved (audio)
move.l    $74(a0),OldInt74 ; Sys int liv 5 saved (rbf,dsksync)
move.l    $78(a0),OldInt78 ; Sys int liv 6 saved (exter, ciab, inten)

movem.l    d0-d7/a0-a6,-(Sp)    ; Save the registers to the stack
bsr.s    START            ; Run the main routine
movem.l    (sp)+,d0-d7/a0-a6    ; Restore registers from stack

move.l    BaseVBR(PC),a0     ; In a0, the value of VBR
move.l    OldInt64(PC),$64(a0) ; Sys int liv1 saved (softint,dskblk)
move.l    OldInt68(PC),$68(a0) ; Sys int liv2 saved (I/O,ciaa,int2)
move.l    OldInt6c(PC),$6c(a0) ; Sys int liv3 saved (coper,vblanc,blit)
move.l    OldInt70(PC),$70(a0) ; Sys int liv4 saved (audio)
move.l    OldInt74(PC),$74(a0) ; Sys int liv5 saved (rbf,dsksync)
move.l    OldInt78(PC),$78(a0) ; Sys int liv6 saved (exter,ciab,inten)
rts

START
move.l    BaseVBR(PC),a0     ; In a0 the value of VBR
move.l    #MioInt6c,$6c(a0)    ; I put my rout. int. level 3.
...
I run the programme
...
rts

Note that even if you wanted to use the TRAP instruction, you would have to put
in a0 the BaseVbr and do the offset $80(a0). The same applies to all vectors.
From this lesson onwards, there is a new startup, startup2.s, to
be included in place of startup1.s. The only difference is that it contains the
instructions seen above and the BaseVbr label is available to modify the
interrupts properly on all microprocessors. The old
interrupts are saved and restored at the end by the startup, together with
the DMA and INTENA channels.
Another change is the addition of a routine that blocks mouse
and keyboard input to the operating system. We will see that this is necessary when loading files.
Now that we know how to replace a system interrupt with our own,
we need to see how to make our own interrupt.
To anticipate the following pages, let's play the music in interrupt in the listing
example Lesson11b.s. You will understand better how it works by continuing to read!

|||||
.__________________________.oOo_/o_O\_oOo.____________________________________.
*******************************************************************************
*        HOW TO ‘BUILD’ AN INTERRUPT ROUTINE         *
*******************************************************************************

The interrupt system allows an external device or
a custom chip to interrupt the execution of the processor, causing it to
jump in user mode to the routine whose address must be found in one
of the interrupt vectors (e.g. $6c).
These interrupts have different PRIORITY levels, ranging from a
minimum level (1) to the maximum level (7). These priorities are used in the event
that one or more interrupts occur during the execution
of an interrupt. If, for example, the normal program in user mode is
interrupted by a low-level interrupt, say 2, and while this interrupt is being executed
this routine is being executed, a higher level interrupt request occurs,
for example 5, interrupt 2 is interrupted in turn by interrupt 5, with
higher priority, and once the latter interrupt has finished, control
returns to the level 2 interrupt, which then passes it back to the normal program
in user mode. In this way, multiple interrupt routines can remain
waiting to finish execution, and depending on their level, they will finish
executing first. The need to introduce interrupts from the very first
microprocessors is linked to the fact that CPU power is often misused
due to very long wait loops. If, for example, you had to
wait for the start of the vertical blank, you would have to create a loop that checks
the line reached, and until that line is reached, the processor
does nothing but freeze in that ridiculous loop. If the wait for a certain
signal were a few seconds, imagine how much processor power would be wasted
! This is why interrupts exist, allowing the processor
to execute programs without worrying about waiting for “events”.
If you generate a level 3 interrupt every vertical blank, you can have
the processor calculate a fractal or a 3D image, and when
the interrupt occurs, at the moment of vertical blanking, the calculation of the
3D solid will be interrupted, the routine to be executed at the beginning of the Vblank will be executed, and then
the 3D routine will resume where it left off.
Multitasking itself is possible thanks to this: being able to print or read
from the disk drive while doing something else is possible because, unlike
the PC MSDOS, the processor can perform a task that will be interrupted
at the right time by the disk or serial/parallel port interrupt,
and will resume as soon as these interrupts are executed.
The Amiga assigns 6 of the 7 available interrupt levels to signals produced
by custom chips (blitter, copper, cia) in certain situations.
The seventh level is used by external cards such as Action Replay, since
the IPL2-IPL0 lines that generate it are routed to the expansion port.
The first 6 interrupt levels are generated by custom chips, for example
when a blitter or a vertical blank video is completed.

||||
_A_ /oO\
.__________________________(iIi)_\\//_oOo.____________________________________.
*******************************************************************************
*            HOW TO USE INTENA AND INTENAR             *
*******************************************************************************

It is possible, using the INTENA register ($dff09a), to mask some of
these interrupts, i.e. prevent them from being generated.
There is also a register for requesting interrupts, the INTREQ ($dff09c).
These registers work like the DMACON ($dff09a), in fact bit 15 decides
whether the other specified bits should be set or reset.
As we did for the DMACON/DMACONR in lesson 8, let's look at the ‘map’
of the INTENA ($dff09a) write-only registers and INTENAR ($dff01c) read-only registers
:

INTENA/INTENAR ($dff09a/$dff01c)

BIT    NAME     LEVEL    DESCRIPTION

15    SET/CLR        ‘Set/clear’ control bit. Determines whether the bits set to 1
must be reset or set, as in DMACON.
Bits set to 0 will neither be set nor reset
14    INTEN        Master interrupt (general enable interrupt)
13    EXTER    6 ($78)    External interrupt, connected to the INT6 line
12    DSKSYN    5 ($74)    Generated if the DSKSYNC register matches the data
read from the disk in the drive. Used for hardware loaders.
11    RBF    5 ($74)    UART receive buffer of the serial port FULL.
10    AUD3    4 ($70)    Reading of a data block from audio channel 3 finished.
09    AUD2    4 ($70)    Reading of a data block from audio channel 2 finished.
08    AUD1    4 ($70)    Reading of a data block from audio channel 1 finished.
07    AUD0    4 ($70)    Reading of a data block from audio channel 0 finished.
06    BLIT    3 ($6c)    If the blitter has finished a blit, it is set to 1
05    VERTB    3 ($6c)    Generated every time the electronic brush is
at line 00, i.e. at the beginning of each vertical blank.
04    COPER    3 ($6c)    Can be set with the copper to generate it at a certain
video line. Just request it after a certain WAIT.
03    PORTS    2 ($68)    Input/Output Ports and timers, connected to the INT2 line
02    SOFT    1 ($64)    Reserved for software-initialised interrupts.
01    DSKBLK    1 ($64)    End of transfer of a data block from the disk.
00    TBE    1 ($64)    UART transmission buffer of the serial port EMPTY.

As can be seen, the analogy with DMACON/DMACONR is clear:
-Bit 15 is very important: if it is on, then the bits set to 1 in
writing in $dff09A are used to enable the corresponding interrupts; if bit 15
is 0, then the other bits set to 1 in the register are used to disable, i.e.
mask, the corresponding interrupts.
To enable or disable one or more interrupts, as in DMACON, it is still
necessary to set the corresponding bits to 1; what determines whether those
interrupts should be enabled or disabled is bit 15: if it is set to 1, they are enabled, while if it is set to 0, they are disabled (always regardless of their
previous state).
Let's say you choose which bits to OPERATE on, then you decide whether to enable (0) or
disable (1) them based on bit 15. Bits 0 are neither set nor cleared.

Let's take an example:
;5432109876543210
move.w #%1000000111000000,$dff09A ; bits 6, 7 and 8 are ENABLED
;5432109876543210
move.w #%0000000100100000,$dff09A ; bits 5 and 8 are DISABLED.

-Bit 14 acts as a general switch (as does bit 9 in DMACON).
It can be reset, for example, to temporarily disable all
interrupt levels without resetting the entire register.

You will remember from the old Lesson 3a.s that with a:

MOVE.W    #$4000,$dff09a    ; INTENA - Stops interrupts

All interrupts were blocked, while with:

MOVE.W    #$C000,$dff09a    ; INTENA - Re-enable interrupts

;5432109876543210
all interrupts were re-enabled. Well, $4000 = %0100000000000000, i.e. the
MASTER bit, number 14, is reset.
 Instead, $c000 = %1100000000000000, i.e. the MASTER bit is re-enabled, and with it all interrupts. In Lesson 11b.s, to enable VERTB:

move.w	#$c020,$9a(a5)    ; INTENA - enable interrupt ‘VERTB’ of
; level 3 ($6c), the one that is generated
; once per frame (at line $00).

; 5432109876543210
In fact, $c020 = %1100000000100000 - bit 5, VERTB, set together with MASTER.

As you may have noticed, the interrupts range from serial port management
to reading the synchronisation of the disk drive tracks, without sparing
the blitter, CIA or COPPER. Redefining all interrupt levels is
very dangerous from a compatibility point of view, and is also very
difficult and specific to those who want to create their own operating system.
Demo and game programmers are only interested in the $6c interrupt, i.e.
the one at level 3, which concerns the generation of synchronised interrupts
with the electronic brush (VERTB - bit 5), or that can be generated on particular video lines
with the copper (COPER - bit 4). More rarely, you may have to
deal with interrupts for keyboard management or other purposes.
In particular, loading from disk via a hardware loader is out of fashion,
because games and demos need to be installable on the hard disk, so
disk drive interrupts are of no interest to us. Furthermore, even if you wanted to make
a game that uses the serial port to play on two computers
connected via cable or modem, it would be better to use the legal calls from
the SERIAL.DEVICE operating system, rather than creating interrupts that are not very
compatible with any multiserial cards or new hardware.
.
·
: :
¦ ¦
_| l_
\ /
\ /
\ _!_
\/¡

*******************************************************************************
*            HOW TO USE INTREQ AND INTREQR             *
*******************************************************************************

In Lesson 11b.s, we also saw INTREQ/INTREQR. What are they?
You may have noticed how the $6c interrupt is structured:

MioInt6c:
btst.b    #5,$dff01f    ; INTREQR - is bit 5, VERTB, reset?
beq.s    NointVERTB		; If so, it is not a ‘true’ int VERTB!
movem.l    d0-d7/a0-a6,-(SP)    ; save the registers in the stack
bsr.w    mt_music        ; play the music
movem.l    (SP)+,d0-d7/a0-a6    ; retrieve the registers from the stack
nointVERTB:     ;6543210
move.w    #%1110000,$dff09c ; INTREQ - clear rich, BLIT, COPER, VERTB
; since the 680x0 does not clear it by itself!!!
rte    ; exit from int COPER/BLIT/VERTB


NOTE: INTREQR is the word $dff01e/1f. In this case, we act on its byte $dff01f
instead of $dff01e, but it is still the low byte of INTREQR.

The INTREQ/INTREQR map is the same as that of INTENA/INTENAR:

INTREQ/INTREQR ($dff09c/$dff01e)

BIT    NAME     LEVEL    DESCRIPTION

15    SET/CLR		‘Set/clear’ control bit. Determines whether the bits set to 1
should be cleared or set, as in DMACON.
Bits set to 0 will neither be set nor cleared.
14    INTEN    6 ($78)    interrupt level 6 CIAB
13    EXTER    6 ($78)    External interrupt, connected to the INT6 line.
12	DSKSYN    5 ($74)    Generated if the DSKSYNC register matches the data
read from the disk in the drive. Used for hardware loaders.
11    RBF    5 ($74)    UART receive buffer of the serial port FULL.
10    AUD3    4 ($70)    Reading of a data block from audio channel 3 finished.
09    AUD2    4 ($70)    Reading of a block of data from audio channel 2 finished.
08    AUD1    4 ($70)    Reading of a block of data from audio channel 1 finished.
07    AUD0    4 ($70)	Reading of a data block from audio channel 0 completed.
06    BLIT    3 ($6c)    If the blitter has finished a blit, it is set to 1
05    VERTB    3 ($6c)    Generated every time the electronic brush is
at line 00, i.e. at the beginning of each vertical blank.
04    COPER	3 ($6c)    Can be set with the copper to generate it at a certain
video line. Just request it after a certain WAIT.
03    PORTS    2 ($68)    Input/Output Ports and timers, connected to the INT2 line
02    SOFT    1 ($64)    Reserved for interrupts initialised via software.
01    DSKBLK    1 ($64)    End of transfer of a data block from the disk.
00    TBE    1 ($64)    UART transmission buffer of the serial port EMPTY.


What is an interrupt request register for?
To request interrupts, of course. And also to DISABLE them, since once
an interrupt is requested, automatically (by custom chips) or
manually (by our program), the interrupt is executed, but the ‘request’ is not
cleared, so at the end of each interrupt it is necessary to
clear the interrupts already performed from the list of interrupts to be performed.

INTREQ ($dff09c) is used by the 680x0 to force the execution of an interrupt,
usually the software interrupt, or by COPPER to execute the
COPER interrupt on a certain video line. Of course, once an interrupt request has been set,
 if that interrupt is not enabled in INTENA, you can wait
forever.
When a bit set in INTREQ is also set in INTENA
, the interrupt corresponding to that bit occurs.
Please note that if bit 14 of INTREQ is set,
a level 6 interrupt occurs (provided that the corresponding bit in
INTENA, Master Enable, is also set).
Otherwise, it is used to clear the request bits of interrupts that have already been
executed, since interrupt requests are not automatically cleared.
Be careful with this, because if you forget to clear the
request bits at the end of each executed interrupt, the processor will
execute it again! Now you should understand the final part of the interrupt:

;6543210
move.w    #%1110000,$dff09c ; INTREQ - clear BLIT, COPER, VERTB requests
; since the 680x0 does not clear it itself!
rte    ; exit from COPER/BLIT/VERTB interrupt


INTREQR ($dff01e) is read-only, unlike INTREQ, which is write-only.
 It is used to find out which chip requested the interrupt. In fact, if
the level 3 interrupt ($6c) is executed, it may be the fault of the blitter,
the vertical blank or the copper. By testing the INTREQR bits, we can understand which of
these 3 is the cause, and determine which routine to execute, or whether to execute the
routine, if we are only interested in one of these 3 possibilities. Bit 15
has no meaning in INTREQR, as it is Set/Clr.
Let's now review its use in Lesson 11b.s:

btst.b	#5,$dff01f    ; INTREQR - is bit 5, VERTB, reset?
beq.s    NointVERTB    ; If so, it is not a ‘true’ int VERTB!

In this case, since BTST on an address can only be .BYTE,
$dff01f is tested, i.e. the low byte of the word, instead of $dff01e.
If Noint is jumped to, it is clear that the interrupt was generated
by the copper or the blitter, and bits 4 or 6 would be set. In this case,
 these interrupt requests must also be cancelled to prevent the interrupt from being executed every
microsecond for no reason:

;6543210
move.w    #%1110000,$dff09c ; INTREQ - clear BLIT, COPER, VERTB requests
; since the 680x0 does not clear it by itself!!!
rte    ; exit from COPER/BLIT/VERTB interrupt

It may seem strange that, despite only VERTB being enabled with INTENA,
COPER or BLIT interrupts may be requested and EXECUTED.
In fact, they should not be requested or executed...
But for reasons probably related to the MMU or the processor speed,
on computers faster than the 1200 base, such as the A4000, it can happen,
and this causes problems with some demos, even some recent ones for AGA.
In fact, on a base A1200, the interrupt may work even without the
btst of the VERTB bit, but this is not the case on an A4000 or A1200 with turbo. I admit that
‘in theory’ it should work, but the fact is that many demos for A1200, when
run on A4000, play the music twice per frame, which is ridiculous.
So be sure to always test the intreq bits before running
theinterrupt, even if everything works on your computer, or you'll end up with
a game/demo that acts up on A4000 and company.

To sum up, here are the things to do to set up our interrupt:

- Get the VBR address, save the old interrupt and restore it
before exiting. This task is done well by startup2.s, no
problem: the VBR address is in the BaseVBR label.
- Clear all interrupts with INTENA. This task is also performed
by startup2.s, with a MOVE.W #$7fff,$9a(a5).
- Put the address of our interrupt in the right autovector.
- Enable only the interrupt or interrupts we need

And here's what to remember to put in our interrupt routine:

- Save and restore all registers with a nice MOVEM, because if
any registers get “dirty”, imagine what would happen at the end of the interrupt
when you return to execute an interrupted program in
who knows what situation and with who knows what values in the registers!
- Immediately test $dff01e/1f (INTREQR) to find out who or what
generated an interrupt of that level. For example, a level 3 interrupt
can be generated by COPER, VERTB or BLITTER; a level 4 interrupt
by AUD0, AUD1, AUD2 or AUD3,
 etc. Be aware that even if it sometimes seems to work without this test, on A4000 or similar it will all go out of sync
as if the CPU were drunk (it may be a special effect, though!).
- Clear the INTREQ bits ($dff09c) that caused the interrupt to be executed,
as they are not cleared automatically. If you forget to do
this, the processor will have a fixed interrupt request and will be executed
continuously.
- Terminate the interrupt with an RTE, as you would terminate a subroutine with RTS.

In light of these considerations, I propose the first interrupt again:

MioInt6c:
btst.b    #5,$dff01f    ; INTREQR - is bit 5, VERTB, zeroed?
beq.s    NointVERTB        ; If so, it is not a ‘true’ VERTB interrupt!
movem.l    d0-d7/a0-a6,-(SP)    ; save the registers in the stack
bsr.w    mt_music        ; play the music
movem.l    (SP)+,d0-d7/a0-a6    ; retrieve the registers from the stack
nointVERTB:     ;6543210
move.w    #%1110000,$dff09c ; INTREQ - clear rich, BLIT, COPER, VERTB
; since the 680x0 does not clear it by itself!!!
rte    ; exit from COPER/BLIT/VERTB interrupt

||||
<---/oO\--®®
._________________________________\--/________________________________________.
*******************************************************************************
*        INTERRUPTS AND THE OPERATING SYSTEM             *
*******************************************************************************

The 680x0 only has 7 INTERRUPT levels, so how is it possible that there
are actually 15 interrupts? Well, the Paula chip divides
the 7 ‘real’ interrupt levels into pseudo-interrupts. For example, it jumps
to the level 3 interrupt in three cases: COPER, VERTB and BLIT, and the only way
to know which of these three cases generated the interrupt is to
consult a register connected to the Paula chip itself, namely INTREQR!
On the other hand, since there are only 7 ‘real’ interrupt levels on the 680x0, it is not
possible for ‘split’ interrupts of the same level by Paula to
interrupt each other. While a level 5 interrupt, such as DSKSYNC,
can interrupt the execution of a level 3 interrupt, such as COPER, it is not
possible for BLIT to interrupt COPER, even if it has higher ‘Paula priority’
,
 since they are on the same physical level of the 680x0.
For this reason, if during the execution of an interrupt there is a request
for another Paula psoud level interrupt in the same 680x0 level,
such as a BLIT while a COPER is being executed, at the end of the
executing the COPER, the level 3 interrupt will be executed again immediately
, this time executing the COPER routine (according to the btst done
on the INTREQR, the type of ‘sub-interrupt’ to be executed will be identified).
Here are the priorities of the interrupt levels in the operating system, i.e.
in the Exec.library, which, as you can see, follows the hardware priority:


level 1: ($64)	MINIMUM PRIORITY

1    empty transmission buffer    TBE
2    disk block transferred    DSKBLK
3    software interrupt        SOFTINT

level 2: ($68)

4    external ports INT2 & CIAA    PORTS

level 3: ($6c)

5    copper                COPER
6    vertical blank interval    VERTB
7    blit finished            BLIT

level 4: ($70)

8    audio channel 2            AUD2
9    audio channel 0            AUD0
10    audio channel 3            AUD3
11    audio channel 1            AUD1

level 5: ($74)

12    receive buffer full    RBF
13    disk sync found        DSKSYNC

level 6: ($78)        MAXIMUM PRIORITY

14    external INT6 & CIAB        EXTER
15    special (master enable)    INTEN

level 7: ($7c) (external cards such as Action Replay)

-    unmaskable interrupt    NMI

The fact that the operating system manages its own interrupt routines makes it
dangerous for us to replace some of them.
As for priority 6, the graphics.library uses the
CIAB Time Of Day (TOD) timer interrupt to control the screen.
In priority 5, DSKSYNC is used by TrackDisk and RBF by serial.device.
In level 4, there are the audio channels, used by audio.device.
In level 3, the BLIT interrupt, which occurs when the blitter has finished an
operation, often contains routines that reuse
the data just written by the blitter, to avoid wasting time.
In level 2, of the CIAA chip, the Timer.device uses the TimerA interrupt for
the keyboard handshake, TimerB for the microsecond timer, and the
TOD alarm interrupt at 50/60Hz. There is also INT2 for any external hardware
cards.
In level 1, the lowest, the TBE interrupt is used by Serial.device,
the DSKBLK interrupt is used by TrackDisk.device. SOFTINT interrupts, i.e.
software interrupts, can be defined via the operating system, for example with the
Cause function of Exec or by making a SOFT_INT type message port.

*******************************************************************************
*        COPER INTERRUPTS CALLED BY COPPERLIST         *
*******************************************************************************

If you want to call the COPER interrupt of level 3 ($6c) on a certain video line,
 just write $8010 in the interrupt ($dff09c), after a wait that waits for
that video line:

COPPERLIST:
dc.w    $100,$200    ; BPLCON0 - no bitplanes
dc.w    $180,$00e    ; colour0 BLUE
dc.w    $a007,$fffe    ; WAIT - wait for line $a0
dc.w    $9c,$8010    ; INTREQ - Request a COPER interrupt, which
; acts on colour0 with a ‘MOVE.W’.
dc.w    $FFFF,$FFFE    ; End of copperlist

In fact, the value $8010 = $8000 + %10000, i.e. bit 4, COPER, is set.

Let's see a practical example in Lesson 11c.s.

Of course, the interrupt can also be called on different lines, each time
changing the ‘effect’. Let's check it out in Lesson 11d.s

Given the particular complexity of interrupts, for now we will not give
further examples regarding disk interrupts, serial port interrupts, etc.
For the applications we are interested in, namely DEMO and GAMES,
 the two types of level 3 ($6c) interrupts we have seen are often sufficient, namely VERTB,
which is executed every frame, and COPER, which can be called by the copper on
any video line.
The applications of the other interrupts will be commented on as they are
found in the example listings, as they cover every field!
For now, we can anticipate the use of all interrupt levels:
in the listings Lesson11e.s and Lesson11f.s, ALL interrupts are redefined,
and ALL levels are enabled, but of course there are only routines in
level 3. This example can be useful as a ‘starting point’ for defining
any interrupt level: you can ‘cut out’ the level you are interested in
and put the routines ‘inside’ it.

· . . . . . ..
 . . . . ..
 . . . ..
 . ,----| . _ _ _ _ _ ..
 . `----|,----| ]-I-I-I-[ . . _ _ _ _ _
_ _ _ _ _ _ ,----| |`----| . \_`_ '__/ . ]-I-I--I-I-[
]-I-I-I-I-[ `----| . | | |. ` |. \_`__ '_/
\ ` '_/ | /^\ . | | /¯\ | . |~_ [],|
[¯] `__| | / ^\ | | |_| | _ _ _ _ _ _ _|______|_
|__ ,| /^\ / ^ \ /^\ | === | I-I-I--I-I-I <=-=-==-=-=>
___| ___ ,|__ /-=-\/=_=_=_=\-=-\ |, `_ | \ ` ` “ ” / \__ _'_/
(__I__I_I__I_ ) (====(_________)___)_| ___ |__ | çÅ$t£e | |. _ |
\-\--|-|--/-/ | I [ ] I ( I|_I I |I ) _|____ ___|_ | _ |
|[] ` “|_ |_ _|`__ ._[ _\ \ | | / / <=-=- øF -=-=> |` ”|
/ \ [] ` .| |-| |-| |_| |_| |_| | [] [] | /\\__ ___ ___/ | “ |
<===> .|-=-=-=-=-=-=-=-=-=-=-| , , / \/ \|. . | /\ |[] |
|[ ]|` ` [] | . _________ . |- , <=======|¦££u$¦øN|<==>|” __|
<===> ` ' |||| | | ||| | [] <=======| || || “ I-|
\T/ -- |||| | çOi! | ||| | . ” \T/--T-T-T-T-T-T|T-T||__. |
__/|\ . .||||| | | |||| |. . ¯¯. /|\__|_|_|_|_|_|||_|/ çO¦!`¶4\_
¯¯ : \ ||||! ! _o , | ||! | / | \ ! ! ! | !.!| / ¦ ¯
¦ \ !||! //\/ | |! | \ | / ! !| / :
: `! '/\ ! ! ! \!/ ! __¦__
___ _|_______________/ /_ /\________________________________________\ //_ ___
¯¯¯ ¯|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯\/ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\//¯¯ ¯¯¯
: ¦

*******************************************************************************
* ADVANCED INFORMATION ON COPPER - USE OF COLOR0 ONLY ($180)-NO BITPLANES *
*******************************************************************************

As the title suggests, we will now look at the possible applications using only a
copperlist without bitplanes. That is, creating drawings or animations using only WAIT and MOVE.
Of course, if you add bitplanes, you can “cross” and “overlap”
these effects, modifying colour2 or colour3 many times for copperlist, in addition to colour0.
these effects, modifying colour 2 or colour 3 many times for each copperlist,
in addition to colour 0.
To begin, however, we need to explain a few things that have not yet been
covered. This concerns the “time” taken by the copper to execute a
MOVE command. We have already seen how to change the entire palette, even 32
colours, at a certain video line, to display a few
hundred colours on the screen, with only ‘32’ or ‘16’ colours officially set in
BPLCON0. Well, in one line we managed to change 32 colours, i.e. to
execute 32 MOVE commands of the copper:

dc.w    $180,xxx	; 1 move in colour0
dc.w    $182,xxx    ; 1 move in colour1
...
            ; etc.

Well, in reality, if we start changing colours from the horizontal position
$07, or even $01, all 32 colours will actually be
changed only towards the middle of the screen, because each move requires
8 lowres pixels to be executed. For this reason, it is always best to change the
colours one line before the drawing actually starts. If we put
forty or so MOVE commands in a row, we would end up with the last one on the line below!
Besides, it would be physically impossible to execute dozens of moves in less
than 1/50th of a second!
However, we can use this apparent limitation for our purposes, for
for example to change colour horizontally every 8 pixels, without using
WAIT, but simply by placing about fifty COLOR0 per line.
Let's see a practical example of this in Lesson11g1.s
One use of this listing could be to change $182, and
not $180, in a 1-bitplane screen: in this way, any ‘writing’
overlapping text would fade from left to right instead of
from top to bottom, as we usually do with the copperlist.

In Lesson11g2.s and Lesson11g3.s there are more colourful versions of this
effect, so much so that they can be used as a basis for ‘PLASMA’ effects.

By the way, if we ‘rotate’ or ‘cycle’ the colours of a line like this
type, what would we get? A well-known effect, used in intros since the early days of the
Amiga: let's see the ‘supercar’ effect in Lesson11g4.s

Perhaps cycling only 2 lines is not very exciting. Let's cycle more, perhaps
creating a ‘knotted’ effect, in Lesson11g5.s

Another ‘fantasy’ that exploits the “crowding” of colorXX placed one after the other,
in the example Lesson11g6.s

Now let's see a somewhat ‘economical’ way way to make a plasma-like effect: instead of
changing the contents of the many color0s, we put a wait at the beginning of each
line, each of which will contain 52 color0s: we can move the line
left and right simply by changing the horizontal position of the
various waits! In practice, this is in Lesson11g7.s

* USE OF COPPER2 (COP2LC/COPJMP2):

You may have noticed that in addition to $dff080 and $dff088 for pointing and starting
copper 1, there are $dff084 and $dff08a for pointing and starting
copper2. But how does copper2 work? And what can it be used for?
At the beginning of each frame, the copper starts copper 1, whose address is
read from $dff080.
We sometimes start it ‘on the fly’, without even waiting for the end of the
frame, by writing in COPJMP1, i.e. $dff088.
If we put a copperlist in $dff084, (COP2LC), we would also have to start it
by writing in COPJMP2 ($dff08a).
But at the end of the frame, copper1 would restart.
Now, this feature can be used to make different copperlists to jump to,
 as we do for 680x0 instructions with ‘JMP’.
For example, if we wanted to run copper1 up to the middle of the screen, then
jump to run the other half from copper 2, we would just point
copper 2 at the beginning and start it from the copperlist using copjmp2:


move.l    #copper1,$dff080    ; COP1LC
move.l    #copper2,$dff084    ; COP2LC
...

section    copperissime,data_C

copper1:...
    ; various instructions...
dc.w    $a007,$fffe    ; Wait for line $a0
dc.w    $8a,0        ; COPJMP2 - start copper 2


copper2:...
    ; various instructions
dc.w    $ffff,$fffe    ; End of copperlist, restart with
; copper1!


The copper, when it reaches ‘dc.w $8a,0’, jumps (like BRA or JMP) to copper2, provided
that this was previously placed in $dff08a. Note that it JUMPS, and does not
behave like a “bsr”, so it never returns to ‘dc.w $8a,0’ of copper1.
Let's now look at a couple of practical uses for copper2. One is to create
so-called dynamic copper, i.e. composed of 2 copperlists exchanged
every frame, like a ‘double buffering’ of the bitplanes. This is used to
make the shades ‘smoother’; in fact, if you exchange 2 colours every
frame, you will get an interlace effect, which will make the intermediate colour ‘visible
’.
Just prepare two copperlists with the same gradient, but slightly ‘offset’, and
swap them continuously.

Let's see a Dynamic Cop in practice in Lesson 11h1.s
Did you notice the difference? It could pass for an AGA gradient!
And to think that dynamic copperlists have been used in only a few games, even though
they are not that difficult to make. Among the games that have dynamic copperlists
I must mention AGONY, and the recent SHADOW FIGHTER, the Italian beat 'em up
by NAPS TEAM.

Now let's look at another application of copper2. Instead of swapping a couple
of copperlists, we can cycle through a few dozen, so we can say that
we can “pre-calculate” a copper effect by calculating 1 copperlist for each
“phase” of the effect: since the effect will then be cyclical, we just need to point
to the “next” copperlist each time.
This way we get the copper effect, but in terms of time we save
TOTAL time that would have been used by the 68000 routines! So we can
say that the copper effect in question is ‘FREE’, and we can run
a routine on it that eats up all the rest of the time.

Let's look at a “normal” routine, in Lesson11h2.s, and the version that precalculates
the ‘copper’ frames, i.e. Lesson11h3.s. The only drawback of the
‘turbated/precalculated’ version is that it requires additional memory
to store all the copperlist frames.

Since you want to pass the copper level 2 exam, you should also know
that you can ‘mask’ the Y coordinate of WAITs. In practice, a wait with
the Y masked looks like this:

dc.w	$0007,$80FE    ; Wait at ‘masked’ Y

This means: do not check the Y line, but wait for position $07 X of the
current line. It is a ‘handicapped’ WAIT, which cannot read the Y position.
In fact, it cannot read the 7 low bits of the Y position, so it works
after line $80. But then, what do we need a masked wait that does not
check the Y position before the Y position $80?
If we had to move a legendary bar, like the ones in Lesson 3,
we would have to change all the waits that make it up. If, on the other hand, we put a normal wait
at the beginning, and all masked waits below it, it would be enough to change the first
wait and the others would ‘follow’. The savings in 680x0 instructions is obvious:
with a single add/sub, an entire bar is moved.

Let's see an implementation in Lesson11h4.s (the legendary bar from Lesson3!).

Note that it also works below the vertical line $FF, since it restarts
the numbering from $00. Now that you know this, if you happen to move something
in that area, you can take advantage of this trick.

Now we could talk about the SKIP instruction, but since I've never seen it
used by anyone, and I myself don't see what it could be used for (you can
easily do everything using copper2 for jumps...), I'll skip
this topic. I hope you believe in the total uselessness of this command.

Now, to finish off the topic of “COPPER ONLY WITHOUT BITPLANES”, I propose six
lists that summarise the most common effects of this type.

Lesson11i1.s is a full-screen colour scroll

Lesson11i2.s is a pseudo parallax with three levels of bars. It can be used as
background for a platform game during a ‘climb’, for example.

Lesson11i3 is a minor COP fantasy...

Lesson11i4.s is a pseudo-random gradient, which mixes the horizontal position values of the electronic brush (usually different values) to make
the colours of the copper gradient.

Lesson11i5.s is a copperlist that cycles colours in a way that looks 3D.

.......
.::::::::::.
_______j::“__ __:::,__
_/¯ /. .-^-.-^-.¯\ ¬\_
/ \_ | ® | © |_/ \
/ __ T `---”\--“! \
/ __/` | ¯¬ _ \¬ \
/ _/ | _/\ ¬_/ _,\ \
( ”\ | ` ¯¯ ¯Y \ \
\ \ l____________/ \
\ 7________________\_ /
\ l ____ ( /
\_____\ ¬T /______/
/ \ | / /
C _ _ ( __ | __ ( _ _(
¯ T ¯ ¬ | ¯ T ¯ ¯
/¯ ¯\ ¯\ xCz
___/_______________\_______\__
(________________)_____________)


*******************************************************************************
*    ADVANCED INFORMATION ON COPPER - BITPLANES ALSO ENABLED     *
*******************************************************************************

Have you seen that with just copper move&wait we can do quite a lot of
things? But what happens if we do complicated copperlists with bitplanes
enabled? We can change the bplmod on each line to lengthen the figures,
or use bplcon1 ($dff102) to wave them, or even change the pointers to the bitplanes on each
line!!!

In the following listings, among other things, a particular system is used to
calculate diwstart/diwstop and ddfstart/ddfstop, namely through some
EQUATE, which are used to calculate values thanks to the shift operators
‘<<’ and ‘>>’, as well as ‘&’ (and), and the common ‘*’,‘/’,‘+’,‘-’.
If you want to make a normal 320*256 screen, it is quicker to enter the
normal values or change them manually. However, if you want to make a screen of a
particular size, for example 256*256, you can save time.


scr_bytes    = 40    ; Number of bytes per horizontal line.
; From this, the screen width is calculated
; by multiplying the bytes by 8: normal screen 320/8=40
; E.g. for a screen 336 pixels wide, 336/8=42
; example widths:
; 264 pixels = 33 / 272 pixels = 34 / 280 pixels = 35
; 360 pixels = 45 / 368 pixels = 46 / 376 pixels = 47
; ... 640 pixels = 80 / 648 pixels = 81 ...

scr_h        = 256    ; Screen height in lines
scr_x        = $81    ; Screen start, position XX (normal $xx81) (129)
scr_y        = $2c    ; Screen start, position YY (normal $2cxx) (44)
scr_res        = 1    ; 2 = HighRes (640*xxx) / 1 = LowRes (320*xxx)
scr_lace    = 0    ; 0 = non-interlace (xxx*256) / 1 = interlace (xxx*512)
ham        = 0    ; 0 = no ham / 1 = ham
scr_bpl        = 1    ; Number of bitplanes

; parameters calculated automatically

scr_w        = scr_bytes*8        ; screen width
scr_size    = scr_bytes*scr_h    ; screen size in bytes
BPLC0	= ((scr_res&2)<<14)+(scr_bpl<<12)+$200+(scr_lace<<2)+(ham<<11)
DIWS	= (scr_y<<8)+scr_x
DIWSt	= ((scr_y+scr_h/(scr_lace+1))&255)<<8+(scr_x+scr_w/scr_res)&255
DDFS	= (scr_x-(16/scr_res+1))/2
DDFSt    = DDFS+(8/scr_res)*(scr_bytes/2-scr_res)

Then, in copperlist we will put:

dc.w    $8e,DIWS    ; DiwStrt
dc.w    $90,DIWSt    ; DiwStop
dc.w    $92,DDFS    ; DdfStart
dc.w    $94,DDFSt    ; DdfStop
dc.w    $100,BPLC0	; BplCon0

However, it is not ‘infallible’; if you want to make screens of unusual sizes
it may not work, and it will be better to do it ‘by hand’.
You can also use it to calculate the value, checking it after
assembly with ‘? DIWS’ or ‘? xxxx’, then write the value by hand.
Here are the listings for this section:

Lesson11l1.s - changes both colour0 and bplcon1 ($dff102) on each line,
causing the bitplanes to ripple.

Lesson11l2.s - Changes 3 out of 4 colours (2 bitplanes) on each line.

Lesson11l3a.s, Lesson11l3b.s and Lesson113c.s are 3 steps to achieve
the waving effect of the AMIGA ET logo in the small demo on
disc 1. We have described it all piece by piece!
The figure waves thanks to the negative modules alternating with the zeroed ones.

Lesson11l4.s - This is another way to wiggle: the
bplpointers are redefined on each line!

Lesson11l5.s - If you had a small image 40*29 pixels wide and wanted to
fill the entire screen with it, what could you do? Try zooming in
8 times, turning it into 320*232. That's what this listing does, using
the module for vertical stretching and a routine
that tests each bit and ‘transforms’ it into a byte (8 bits).

Lesson11l5b.s - is an optimised version of the previous listing, which uses
a table containing the 256 possible combinations of a byte ‘expanded’ to
8 bytes. It takes less than half the time to execute! Learn how to do
this kind of optimisation: routines that seem impossible to
speed up can sometimes be turbocharged like this!

* HOW TO MAKE AN INTERLACED SCREEN (512 lines long)

Interlacing allows you to display twice as much video data.
This is possible by doubling the number of lines displayed.
Normally, 256 vertical lines are possible, while with interlacing you can
reach 512, both in lowres and hires.
However, there are some peculiarities: in fact, it is not enough to point the bitplanes
and setting the interlace bit (bit 2 of bplcon0).
As for the RAW image, simply convert a normal interlaced drawing
with theiffconverter and save it, i.e. an image in 320x512 or
640x512. A smaller brush is also fine, but always bear in mind that
the image must not appear “squashed” due to the double vertical resolution
. As is well known, interlacing ‘flickers’ or ‘wobbles’.
This is a bad thing, but also a good thing, because on normal TVs or monitors
a vertical resolution higher than 256 lines would not be possible; you would need
a “VGA” monitor, i.e. multisync or multiscan.
The "trick‘ is done by displaying the 256 odd lines once and
the other 256 even lines once.
The exchange takes place every frame, so it deceives the eye quite well, apart from
the flickering (which is greatly reduced if the colours are chosen well).
However, this exchange is not entirely “automatic”; we need to do a little something
’by hand".

+-----------------------------------+----------------------------------+
| FRAME 1 (odd lines) | FRAME 2 (even lines) |
+-----------------------------------+----------------------------------+
| LINE 1: ---> xxxxxxxxxxxx | |
| | LINE 2: ---> xxxxxxxxxxxx |
| LINE 3: ---> xxxxxxxxxxxx | |
| | LINE 4: ---> xxxxxxxxxxxx |
| LINE 5: ---> xxxxxxxxxxxx | |
| | LINE 6: ---> xxxxxxxxxxxx |
| LINE 7: ---> xxxxxxxxxxxx | |
| | LINE 8: ---> xxxxxxxxxxxx |
| LINE 9: ---> xxxxxxxxxxxx | |
| | LINE 10: --> xxxxxxxxxxxx |
| [...] | |
| | [...] |
| LINE 311: -> xxxxxxxxxxxx | |
| | LINE 312: -> xxxxxxxxxxxx |
| LINE 313: -> xxxxxxxxxxxx | |
+-----------------------------------+----------------------------------+

For the interlaced mode, you need to redefine the module by setting it to 40 if
you are in low resolution, or to 80 if you are in high resolution. In practice, you need to put the length of a line in the
module to skip it: since the module is a value
that is added at the end of each video line, if you skip the length
of an entire line, this is what happens: the first line is read and displayed
line is read and displayed, the second is skipped at the end, and the
third is displayed below;
 at the end of this, a line is skipped and the fifth is displayed, and so on. In practice, we have made sure that
only the odd lines are displayed.
For hardware reasons, the screen cannot display more than 256 lines, but
no one tells us which 256, nor when to start displaying them.
If we skip the even lines once and then skip the odd lines,
we can display a screen of 512 lines in one of 256 “alternating” lines!

Let's recap: we have a pic, for example, in 640x512 interlaced, which
we have converted to RAW and want to display. We have pointed the pic
appropriately and set the module to -80, as well as setting the interlace bit
(in addition to the hires bit) in bplcon0 ($dff100).
What do we get? THE IMAGE AS IF IT WERE IN LOWRES! 256 LINES HIGH, AS IF
WE HAD LOWERED THE RESOLUTION!

So, now is the time to do that little bit “by hand” to allow
interlacing. There is a special bit that needs to be checked, which tells us
whether to display the odd or even lines in each frame.
This is bit 15 of the VPOSR ($dff004), called LOF, or Long Frame, which indicates
whether we are in ‘long frame’ or not. Here is an example of a routine:

LACEINT:
MOVE.L    #BITPLANE,D0    ; Bitplane address
btst.b    #15-8,$dff004    ; VPOSR LOF bit?
Beq.S    Faidispari    ; If yes, it's the odd lines' turn
ADD.L    #80,D0        ; Or add the length of a line,
; starting the display from the
; second: display even lines!
FaiDispari:
LEA    BPLPOINTERS,A1    ; PLANE POINTERS IN COPLIST
MOVE.W    D0,6(A1)    ; Point to the figure
SWAP    D0
MOVE.W    D0,2(A1)
RTS

As you can see, if the LOF bit is reset, display starts from the first
line, so the module will display lines 1, 3, 5, 7...
and so on, i.e. the odd ones. Otherwise, one line is skipped,
starting display from the second, then 2,
4, 6, 8, etc.: EVEN!

Some people make two copperlists, one pointing one way and one pointing the other,
and then, depending on the LOF bit, they point to one or the other each frame. However, I think
it is “smarter” to point only to the bitplanes... anyway, you can do as you wish,
as long as you understand the method.

Lesson11l6.s - is an example in 640x512 with 1 bitplane

Lesson11l6b.s - is an example in 320x512 with 4 bitplanes

To finish this ‘copper’ degree course, level 2, all we have to do
is make a more complex example for sprites.
Remember how we ‘reused’ them in lesson 7 to make stars?
Well, what happens if we reuse sprites every 2 lines?

Lesson11l7.s - To see a mega reuse of sprites (128 times each)

____::::____
_/::__ ·· __ \_
,|:·( o _, o ) |,
(|· (_ |)
`l. _ .j'
\ \____/ / Zs!
______\ :l/ /____
/:::·· ¬\________/ ::\
/::· ·:\


******************************************************************************
*        THE 2 8520 CHIPS, CALLED CIAA AND CIAB *
******************************************************************************

If you take apart the Amiga, you will find, in addition to Agnus, Paula, Denise, the 680x0, etc.,
a couple of 8520 chips, called CIA. These chips have 16
input/output pins, a serial shift register, three timers, one output-only pin
and one input-only pin. As a result, both have 16 registers that
can be accessed by accessing their respective addresses:

CIAA address map
---------------------------------------------------------------------------
Byte Register Data bits
Address Name 7 6 5 4 3 2 1 0
---------------------------------------------------------------------------
$BFE001 pra /FIR1 /FIR0 /RDY /TK0 /WPRO /CHNG /LED OVL
$BFE101 prb Parallel port
$BFE201 ddra Address for port A (BFE001);1=output (normally $03)
$BFE301 ddrb Address for port B (BFE101);1=output (can be in/out)
$BFE401 talo CIAA timer A low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
$BFE501 tahi CIAA timer A high byte
$BFE601 tblo CIAA timer B low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
$BFE701 tbhi CIAA timer B high byte
$BFE801 todlo 50/60 Hz timer - bits 7-0 (VSync or line tick)
$BFE901 todmid 50/60 Hz timer - bits 15-8
$BFEA01 todhi 50/60 Hz timer - bits 23-16
$BFEB01 Not used
$BFEC01 sdr CIAA serial data register (connected to the keyboard)
$BFED01 icr CIAA interrupt control register
$BFEE01 cra CIAA control register A
$BFEF01 crb CIAA control register B

Note: the CIAA can generate an INT2 interrupt, i.e. level 2, $68.


CIAB address map
---------------------------------------------------------------------------
Byte Register Data bits
Address Name 7 6 5 4 3 2 1 0
---------------------------------------------------------------------------
$BFD000 pra /DTR /RTS /CD /CTS /DSR SEL POUT BUSY
$BFD100 prb /MTR /SEL3 /SEL2 /SEL1 /SEL0 /SIDE DIR /STEP
$BFD200 ddra Direction for Port A (BFD000);1 = output (normally at $FF)
$BFD300 ddrb Direction for Port B (BFD100);1 = output (normally at $FF)
$BFD400 talo CIAB timer A low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
$BFD500 tahi CIAB timer A high byte
$BFD600 tblo CIAB timer B low byte (.715909 Mhz NTSC; .709379 MHz PAL)
$BFD700 tbhi CIAB timer B high byte
$BFD800 todlo Horizontal sync timer - bits 7-0
$BFD900 todmid Horizontal sync timer - bits 15-8
$BFDA00 todhi Horizontal sync timer - bits 23-16
$BFDB00 Not used
$BFDC00 sdr CIAB serial data register (not used)
$BFDD00 icr CIAB interrupt control register
$BFDE00 cra CIAB Control register A
$BFDF00 crb CIAB Control register B

Note: CIAB can generate an INT6, i.e. level 6: $78.

From this ‘map’ you can see how the tasks of the two CIAs range from reading
the keyboard, to managing the serial port (for data exchange between two
computers or between a computer and a modem), to managing the parallel port (for the
printer, for example), to controlling the disk drive heads, and it also
has ‘clocks’ that can count microseconds or hours.
In reality, however, we are not interested in all these features, for various
reasons. First of all, the part concerning the disk drive hardware can
be omitted, since every good game/demo must be
installable on a hard disk (or CD-ROM!), such as Brian The Lion.
As for the management of the parallel port and the serial port,
these could be used to print some instructions for the
game or some phrases spoken by a character, or, in the case of the serial port, to
allow two players to play with computers connected to a network, i.e. connected with a
cable. However, it should be noted that printer management is best left to
the operating system, using the ‘parallel.device’
. The same applies to the serial port: serial.device is certainly safer than routines written
via hardware, especially for future Amigas or multi-serial cards.
As for timers, since the operating system uses
several for its own tasks, we will see if and which ones to use.
So, are we almost exclusively interested in keyboard input?
Yes, in fact, if you take a peek at the code of a video game, you will notice that
only the $6c (coper/vertb/vblank) and $68 (int2 of the
keyboard ciaa): level 3 ($6c) is used to synchronise music or other
routines with the electronic brush, while level 2 ($68) is used to
read the keyboard. Of course, reading the left mouse button or
other things gives access to cia registers, but these are simple checks or
BIT settings, so there is no need for lengthy discussions on ‘btst.b #6,$bfe001’.
In demos, it is even likely that no interrupts are redefined,
or that only $6c is used to play music.
So, let's start the explanation of the CIAA from keyboard management, in
which the registers $bfec01 (sdr), $bfed01 (icr), $bfee01 (cra) and
the level 2 interrupt ($68). First, let's look at the three registers separately, then
we'll give some examples of their correct use. I should point out that when a key
is pressed or released, an 8-bit code is sent from the keyboard
through $bfec01, and a level 2 interrupt ($68) is generated in
which the keyboard must be “told” that the code for that key has been received.
Note that this code is NOT the ASCII code for the character pressed, but
a code with the position of the button pressed on the keyboard.

****************************************************************************
;* BFEC01 sdr CIAA sdr (serial data register - connected to the keyboard)
****************************************************************************

is an 8-bit synchronous shift register connected to the keyboard.
It can operate in two modes: INPUT or OUTPUT, and the selection between these
two modes can be made by acting on bit 6 of $bfee01 (cra).
In INPUT mode, the data received from the keyboard is inserted into the register,
one bit at a time, and when all 8 bits forming the
pressed character have “arrived”, an INT2 ($68) interrupt is generated, from which it is necessary to
see which key it is and note it in some variable.
In this case, the byte corresponding to the character code is read:
E.g.:
move.b $bfec01,d0

In OUTPUT mode, on the other hand, you write to the register, for example ‘clr.b $bfec01’.

****************************************************************************
;* BFED01 icr CIAA interrupt control register
****************************************************************************

This register controls the interrupts that can be generated by the CIAA.
The CIAs generate interrupts on various occasions, for example when
a timer countdown has finished, or when the serial port has
finished a transfer.
We are particularly interested in the INT2 interrupt, level 2, i.e. the vector
offset $68, which is generated when a key is pressed.
The operation of the icrs ($bfed01 for CIAA and $bfdd00 for CIAB) is very
unusual, as they consist of a write-only “mask” for a
read-only data register. But what does this mean? First of all, it means that it is
very easy to make a mistake and cause the CIA interrupts to go haywire, which is not
desirable. Each interrupt is enabled if the corresponding bit of the
mask is set to 1. In fact, each CIAA interrupt, as it would with a
INTREQ ($dff09c), sets its request bit in this register.
At this point, if that interrupt is enabled, bit 7 (IR) is set, which is
a kind of set/clear bit, as in dmacon, i.e. when this bit is cleared
the other 6 set bits are cleared, when bit 7 is set, however, the
other set bits are set, while those at zero are not changed.
What can be confusing is that when the register is read, its contents
are cleared, whether you do a ‘tst.b $bfed01’ or any other
read action; resetting the register also clears the interrupt request,
similar to resetting the INTREQ bits ($dff09c).
Now we are only interested in its function for the keyboard interrupt, so
let's take a quick look at its bits in read mode, with comments only where relevant:

CIAA ICR ($bfed01)

BIT    NAME    DESCRIPTION

07    IR    Bit that indicates, if set, that there is an interrupt in progress
06    0
05    0
04    FLG
03    SP    If set, we are in an interrupt generated by the keyboard
02	ALRM
01    TB
00    TA

Remember that reading the register resets it, so if you want to
know which bits were set, you must copy it to a Dx register and
check that register: when you reread $bfed01, the bits are reset.

****************************************************************************
;* BFEE01 cra CIAA cra (control register A)
****************************************************************************

This register is called a ‘control’ register because its bits control
the function of other registers. Here is a ‘map’ of it, with comments only on the
bits that are of interest to us for keyboard reading:

CIA Control Register A

BIT NAME    FUNCTION
--- ----    --------
0 START    Timer A
1 PBON    Timer A
2 OUTMODE    Timer A
3 RUNMODE    Timer A
4 LOAD    Timer A
5 INMODE    Timer A
6 SPMODE    If it is 1 = register ($bfec01) output (to write to it)
If it is 0 = register ($bfec01) input (to read it)
7 Not used


As you can see, the only bit we are interested in is 6, which ‘decides’ the function
of $bfec01, i.e. whether its direction is ‘towards the keyboard’ (output), so
we can write to it, or ‘from the keyboard to the Amiga’ (input), so
we can read the character corresponding to the key that has been pressed.
To change mode, just do this:

bset.b    #6,$bfee01    ; CIAA cra - sp ($bfec01) output
....
bclr.b    #6,$bfee01    ; CIAA cra - sp (bfec01) input

Or, if you prefer, you can use AND and OR to do this:

or.b    #$40,$bfee01    ; SP OUTPUT (%0100000, set bit 6!)
...
and.b    #$bf,$bfee01‘    ; SP INPUT (%10111111, reset bit 6!)

You could also move ’0000" to a register, multiply it by 5, divide it
by 5, add 20, subtract 10, add 1, subtract 11, set or
clear bit 6, and do an and or an or with $bfee01. The assembler allows
you to use infinite ways to do the same thing. But bset/clr is enough!
However, it should be noted that between input mode and output mode, you need to wait
about 90 microseconds, since the CIAA hardware and the keyboard chip
cannot time themselves in input mode.
The 8 bits of the character corresponding to the pressed key are transferred
serially one bit at a time from the keyboard chip to the CIAA. When all
8 bits have been transferred, WE MUST LOWER THE KDAT LINE FOR AT LEAST
NINETY MICROSECONDS (or 3/4 raster lines) TO CONFIRM TO THE KEYBOARD
THAT WE HAVE RECEIVED THE DATA. The KDAT “wire” is controlled by the SP/SPMODE bit,
and in practice we have to do this:

------------------------------------------------------------------------------
move.b    $bfec01,d0    ; CIAA sdr - Read the current character
bset.b    #6,$bfee01    ; CIAA cra - sp ($bfec01) output, so as to
; lower the KDAT line to confirm that
; we have received the character.

st.b    $bfec01        ; $FF in $bfec01 - yes! I received the data!

; Here we need to put a routine that waits 90 milliseconds because the
; KDAT line must remain low long enough to be ‘understood’ by all
keyboard types. You can, for example, wait for 3 or 4 raster lines.

bclr.b    #6,$bfee01    ; CIAA cra - sp (bfec01) input again.
------------------------------------------------------------------------------

When reading the keyboard via hardware, you need to be very careful with the
90-millisecond delay, for two reasons:
1) The delay routine must wait the same amount of time on all
processors, from 68000 to 68060. For this you can use the electronic brush,
 or even a CIA timer, but NEVER do a simple
dbra executed many times, or a series of NOPs, because on 68020+ due to
the cache it will be executed in a flash.
2) Once our routine “waits” correctly on all 680x0s, we must
also consider the fact that not all keyboards are the same!
For example, 2 raster lines may be enough for one keyboard, while
another may need 4! In fact, keyboards contain
a chip that controls them, and this can be different in different
Amiga models. For example, in the A1200, the keyboard is “economical”,
in fact it differs from normal Amiga keyboards (Mitsumi in general)
in that you cannot register more than one keystroke at
a time... if you hold down one key and press another at the same time,
when you release the first one, the second one does not appear.
The wait routine that has to wait between:
"or.b #$40‘ or ’bset.b #6‘,$bfee01 and ’and.b #$bf‘ or ’bclr.b #6",$bfee01
determines whether your program will read the keyboard correctly or
freeze when a key is pressed on some computers.

In this regard, let's see how to wait correctly, using vblank:

; If you don't want to ‘dirty’ address registers:

------------------------------------------------------------------------------
moveq    #4-1,d0        ; we wait 4 rasterlines (3+random...!)
waitlines:
move.b	$DFF006,d1
stepline:
cmp.b	$DFF006,d1
beq.s	stepline
dbra	d0,waitlines
------------------------------------------------------------------------------

; Se invece volete ‘sporcare’ anche un registro indirizzi:

------------------------------------------------------------------------------
lea    $dff006,a0    ; VHPOSR
moveq    #4-1,d0    ; Number of lines to wait = 4 (in practice 3 plus
; the fraction we are in at the start)
waitlines:
move.b	(a0),d1    ; $dff006 - current vertical line in d1
stepline:
cmp.b    (a0),d1        ; are we still on the same line?
beq.s    stepline    ; if so, wait
dbra    d0,waitlines    ; ‘expected’ line, wait d0-1 lines
------------------------------------------------------------------------------

_ ___
_æøæ,_ ¸æ¤³°¤¤4Øæ,
,Ø° __¬¶_æ³ ¬VØø
__æV Ø°4, Ø' ___ 0Ø
_ØØØØ# #_,²J¹ æ°‘°4, IØ
ÁØ’"ØØØþ_____ØL #__,Ø¹ ØØ
JØF ØØ³°°0ØØØØØ_ ¬~~ JØ#
ØØ1 ¶Ø_ ,Ø°¤ØØØØæ______øØØØ,
#Ø1 °#ØØ# ØØØØØØØØØØØØ¯¬ØQ
¬ØN `¢Ø&æØØØØØØØØØØØØ` ØW
¤Øb °¢ØØØØØØØØØØ³ JØØ
`Øæ ¬`°°°°" _dØØ@
¬¢Ø_ __øØØØØ
0Ø ¸___,øøØØØØØØ³
VØL_ _øØØØØØØØØØØØ² xCz
¬ØØØØØØØØØØØØØØØ¤³°
¬ØØØØØØØ°
°^°°¯

- CHARACTERISTICS OF THE CODE CHARACTER TRANSMITTED IN $bfec01

We have already said that the transmitted code is not an ASCII code, but
information about the key that was pressed. This is also because, depending on
the different keyboards, in English, Italian or other languages, many keys have
a different letter printed on them.
 But if I say: the third key in the second row, there can be no mistake. However, the 8 bits (1 byte) that we take from
$bfec01 contain 7 bits relating to the key identifier, plus one bit
that determines whether the key has been pressed or released.
In fact, the key identifier is sent both when the key is pressed and
when it is released, with the difference that the highest bit, the eighth, is
either reset (released) or set (pressed).
As if that were not enough, all transmitted codes are rotated one bit to the left
before transmission.
The transmission order is therefore 6-5-4-3-2-1-0-7. However, simply use
the instruction ‘ROR.B #1,xxx’ to restore the order 7-6-5-4-3-2-1-0.
The transmission of a bit takes 60 microseconds, so the entire byte that
makes up the character is transferred in 480 microseconds, meaning that
17,000 bits can be transferred per second. But what does that matter? Nothing!
Let's see how to recognise whether the key pressed is A, B or
some other key. In the hardware manual there is a list with a code for each key,
where the peculiarity is that the code $01 corresponds to the key "1‘.
To obtain these codes, you need to perform a NOT on the byte, as well as
rotating the bits with a ’ROR" to restore the order 76543210.
In practice, what we need to do is:

move.b    $bfec01,d0	; CIAA sdr (serial data register - connected
; to the keyboard - contains the byte sent by the
; keyboard chip) READ THE CHAR!
NOT.B    D0        ; adjust the value by inverting the bits
ROR.B    #1,D0        ; and returning the sequence to 76543210.

Now in d0 we have the byte with the bit sequence 76543210 instead of 65432107,
and in addition all the bits are inverted, so that the ‘count’ starts from the
first key at the top left (not ESC, but the one next to 1).
Here is the sequence of codes with the corresponding character (normal and shifted, but
bear in mind that the keyboard described here is a US keyboard). (KEYS PRESSED)

code    $00     ;` - ~
code    $01 ;1 - !
code    $02 ;2 - @
code    $03 ;3 - #
code    $04 ;4 - $
code    $05 ;5 - %
code    $06 ;6 - ^
code    $07 ;7 - &
code    $08 ;8 - *
code    $09 ;9 - (
code    $0A ;0 - )
code	$0B ;- - _
code    $0C ;= - +
code    $0D ;\ - |
code    $0e     ; << empty
code    $0F ;0 numeric keypad
code    $10 ;q - Q
code    $11 ;w - W
code    $12 ;e - E
code    $13 ;r - R
code    $14 ;t - T
code    $15 ;y - Y
code    $16 ;u - U
code    $17 ;i - I
code    $18 ;o - O
code    $19 ;p - P
code    $1A ;[ - {
code    $1B ;] - }
code    $1c	 ; << not used
code    $1D ;1 numeric keypad
code    $1E ;2 numeric keypad
code    $1F ;3 numeric keypad
code	$20 ;a - A
code    $21 ;s - S
code    $22 ;d - D
code    $23 ;f - F
code    $24 ;g - G
code    $25 ;h - H
code    $26 ;j - J
code    $27 ;k - K
code    $28 ;l - L
code    $29 ;; - :
code    $2A ;' - "
code    $2B ;(only on international keyboards) - next to the return key
code	$2c     ; << not used
code    $2D ;4 numeric keypad
code    $2E ;5 numeric keypad
code    $2F ;6 numeric keypad
code    $30 ;< (shift left only on international keyboards)
code    $31 ;z - Z
code    $32 ;x - X
code    $33 ;c - C
code    $34 ;v - V
code    $35 ;b - B
code    $36 ;n - N
code    $37 ;m - M
code    $38 ;, - <
code    $39 ;. - >
code    $3A ;/ - ?
code    $3b     ; << not used
code    $3C ;. numeric keypad
code    $3D ;7 numeric keypad
code    $3E ;8 numeric keypad
code    $3F ;9 numeric keypad
code    $40 ;space
code    $41 ;back space <-
code    $42 ;tab ->|
code    $43 ;return numeric keypad (enter)
code    $44 ;return <-'
code    $45 ;esc
code	$46 ;del
code    $47     ; << not used
code    $48     ; << not used
code    $49     ; << not used
code    $4A ;- numeric keypad
code    $4b     ; <<
code    $4C ;up cursor ^
code	$4D ;down cursor v
code    $4E ;right cursor »
code    $4F ;left cursor «
code    $50 ;f1
code    $51 ;f2
code    $52 ;f3
code    $53 ;f4
code    $54 ;f5
code    $55 ;f6
code    $56 ;f7
code    $57 ;f8
code    $58 ;f9
code	$59 ;f10
code    $5A ;( numeric keypad
code    $5B ;) numeric keypad
code    $5C ;/ numeric keypad
code    $5D ;* numeric keypad
code    $5E ;+ numeric keypad
code    $5F ;help
code    $60 ;lshift (left)
code    $61 ;rshift (right)
code    $62     ;caps lock
code    $63 ;ctrl
code    $64 ;lalt (left)
code    $65 ;ralt (right)
code    $66 ;lamiga (left)
code    $67 ;ramiga (right)


As you can see, the sequence roughly follows the order of the keys, starting
from the row with 1,2,3,4,5... then the row below with q,w,e,r,t,y... and so on.
These codes refer to the PREMUTED keys, where bit 7, which
determines whether a key has been pressed or released, is set to zero. In fact
we have performed a NOT on the byte, which has also inverted bit 8: if a
key is PRESSED, bit 8=0, if a key is released, bit 8=1.
If the key is released, bit 7 (the eighth) is considered set,
so the previous table would become:

cod.    $80     ;` - ~
cod.    $81 ;1 - ! 
cod.    $82 ;2 - @
...

Please note that Amiga600s do not have a numeric keypad, so
if you use the keypad keys on these computers, there is no way to
press them! I therefore recommend avoiding the keypad keys.
In light of these considerations, we can see what the
level 2 ($68) interrupt will look like, which will allow us to save the code of the pressed keys in the "ActualKey"
the code of the keys pressed:

___________
/~~/~~|~~\~~\
\ \ | / /______
__\_________/__oOOo_Z________
|::888°_~_°888 o¯¯¯T::::Y~~~~~|
_ |:::\ °'° / __ ||::::| |
\\/Z |::::\ `-“ /¯]|··|T|::::| |
(\\ )|::::/\`=”/\¯ ¯¯ |::::l_____j
\¯¯/ ~Z \ ¯¯¯ /~~~~~~~/~~~~~~~~~~~
/¯¯\_/ \ _ / _ /
\ / /T (Y) |\__/
\_____/ | ¯ |
| : |
| |
| . | ppX

*****************************************************************************
*    INTERRUPT ROUTINE $68 (level 2) - KEYBOARD management
*************************************************************

;03    PORTS    2 ($68)    Input/Output Ports and timers, connected to the INT2 line

MioInt68KeyB:    ; $68
movem.l d0-d1/a0,-(sp)    ; saves the registers used in the stack
lea    $dff000,a0    ; custom register for offset

MOVE.B    $BFED01,D0    ; Ciaa icr - in d0 (reading the icr causes
; its reset, so the int is
; ‘cancelled’ as in intreq).
BTST.l    #7,D0    ; IR bit, (interrupt cia authorised), reset?
BEQ.s    NonKey    ; if yes, exit
BTST.l    #3,D0    ; SP bit, (keyboard interrupt), reset?
BEQ.s    NonKey    ; if yes, exit

MOVE.W    $1C(A0),D0    ; INTENAR in d0
BTST.l    #14,D0        ; Master enable bit reset?
BEQ.s    NonKey		; If yes, interrupt not active!
AND.W    $1E(A0),D0    ; INREQR - only the bits
; that are set in both INTENA and INTREQ
; remain set in d1, so as to be sure that the interrupt
; that occurred was enabled.
btst.l    #3,d0        ; INTREQR - PORTS?
beq.w    NonKey		; If not, then exit!

; After the checks, if we are here it means that we have to take the character!

moveq    #0,d0
move.b    $bfec01,d0    ; CIAA sdr (serial data register - connected
; to the keyboard - contains the byte sent by the
; keyboard chip) READ THE CHAR!

; we have the char in d0, let's ‘work’ on it...

NOT.B    D0        ; adjust the value by inverting the bits
ROR.B    #1,D0        ; and returning the sequence to 76543210.
move.b    d0,ActualKey    ; save the character

; Now we have to tell the keyboard that we have taken the data!

bset.b    #6,$bfee01	; CIAA cra - sp ($bfec01) output, in order to
; lower the KDAT line to confirm that
; we have received the character.

st.b    $bfec01        ; $FF in $bfec01 - yay! I received the data!

; Here we need to put a routine that waits 90 microseconds because the
; KDAT line must remain low long enough to be ‘understood’ by all
; types of keyboards. For example, you can wait for 3 or 4 raster lines.

moveq    #4-1,d0	; Number of lines to wait for = 4 (in practice 3 plus
; the fraction we are in at the start)
waitlines:
move.b    6(a0),d1    ; $dff006 - current vertical line in d1
stepline:
cmp.b    6(a0),d1    ; are we still on the same line?
beq.s    stepline    ; if waiting
dbra    d0,waitlines    ; ‘waiting’ line, wait d0-1 lines

; Now that we have waited, we can return $bfec01 to input mode...

bclr.b    #6,$bfee01    ; CIAA cra - sp (bfec01) input again.

NonKey:        ; 3210
move.w    #%1000,$9c(a0)    ; INTREQ remove request, int executed!
movem.l (sp)+,d0-d1/a0    ; restore registers from stack
rte

-----------------------------------------------------------------------------

You shouldn't have noticed anything new, it's just a ‘summary’ of the things we
have already explained. Ultimately, it's just a few lines and we only use
the d0 and a0 registers, it's not a COMPLICATED routine!
The only thing you need to remember is to put this interrupt at vector
$68+VBR, and enable it by setting bit 3 of INTENA ($dff09a).
For example, if you are using a level 3 interrupt ($6c) to play
music, using only VERTB (bit 5), you can write:

; 5432109876543210
move.w    #%1100000000101000,$9a(a5) ; INTENA - enable only VERTB
; of level 3 and level 2

Or in other words ‘move.w #$c028,$dff09a’.

We can see the correct use of this interrupt in Lesson11m1.s

In this listing, the keyboard code is entered in colour 0 to
‘show’ the actual functioning of the routine itself.
To exit, press a key: the space bar.

For convenience, Lesson 11m2.s includes a rudimentary routine for
converting keyboard codes to ASCII, which can be useful if you want to
print what is written with the keyboard, for
example if you want to create a utility, or simply write your name
in the high score of your game.

___________
( ¬)
\_ _/
L L
____/___ ___\____
//¯¯¯¯¯¯\\_//¯¯¯¯¯¯\\
(( ___¯¯¯___ ))
\\ _/\___\X/___/\_ //
\ T \ / T /
| T |
__| - o|O - |__
tS / ¬| | | ¬\ tS
\ / / ¯\_____T_____/¯ \ \ /
->----/ /\ / \ /\ \----<-
/ \ \ (_____) / / \
\ \_/\_______/\_/ /
\_________A_________/

*****************************************************************************
;        CIAA AND CIAB TIMERS
*****************************************************************************

These timers are actually used very little in games, and almost never in demos,
 except in certain (complicated) routines that play music, which
however just need to be included and they play on their own.
Among other things, these timers are also used by the operating system, so
using them can risk causing everything to go haywire when our program exits
program.
Furthermore, by waiting for the raster lines with $dff006, you can make all
the necessary waits without risking this happening.
For this reason, the lesson only includes a couple of listings that use
timers, as examples. In more advanced lesson listings, we will find
applications for these timers, and we will look at them on a case-by-case basis.

Lesson11n1.s    - Using the CIAA or CIAB timer A

Lesson11n1b.s    - Using the CIAA or CIAB timer B

Lesson11n2.s    - Using the TOD (Time of day) timer

When using CIA timers, bear in mind that the operating system uses them
for the following purposes: (it is better to use CIAB!)

CIAA, timer A    Used for interfacing with the keyboard

! CIAA, timer B    Used by exec for task exchange, etc.

CIAA, TOD        50/60 Hz timer used by Timer.device

CIAB, timer A    Not used, available for programs

CIAB, timer B    Not used, available for programs

CIAB, TOD        Used by graphics.library to track
the positions of the electronic brush.

If you need to use timers that are also used by the operating system, only do so
if you have disabled multitasking and system interrupts, i.e. if you have
taken complete control of the system. Never use CIAA, timer B!

|||||
||||| _A_ /o O\
_ _ ___.oOo _o_O_ oOo. __ ____ ___ _ _ _____ _ _ _ _ (_^_)_\_/ _oOo. _
*****************************************************************************
;        LOADING FILES WITH DOS.LIBRARY
*****************************************************************************

To conclude this lesson full of refinements and various topics,
there is no better topic than DATA LOADING.
If you want to program something ‘big’, in terms of the amount of
drawings, music and various data, you cannot simply include everything with
the incbin and save the mega executable with ‘WO’, because the file would be
too large to be loaded into memory.
Suppose, for example, that you want to make a slideshow, i.e. a program that
shows a series of images one after the other, and that there are
30 of these images, each 100Kb long. That's 3MB of images. Since you can't make a
series of 30 INCBINs to save a file of over 3MB, we have no choice but to
find a way to “load” them one at a time.
But how? There are two main ways:

1) AUTOBOOT LOADING FROM DISK TRACKS, which is not compatible with DOS.
In fact, you will notice that many game disks,
when inserted into the drive after loading the workbench, are not readable
with commands such as “DIR” and appear as NON-DOS or ERROR... in short, they look like
bad disks! When copied using copiers such as XCOPY or DCOPY,
some of these non-DOS games appear as ‘RED’ tracks, i.e. they are not
recognisable even by the copier, while others, despite being
unreadable by DOS, appear as ‘HEALTHY’, i.e. green tracks.
I should point out that CRACKED games (unprotected and distributed by pirates)
are all of the second type, i.e. GREEN tracks, because the protection
often consists of transforming uncopyable tracks into copyable tracks, but
they often remain unreadable by DOS. TRACKMO are the majority of
demos, and are “copyable” tracks, but not readable via DOS.
One feature is that you need to write code for absolute addresses,
 which cannot be relocated, so usually only the first
megabyte of CHIP RAM is used, or for a1200 the first 2 megabytes, and any
FAST RAM are not used, apart from those that use COMPLEX LOADERS
WITH RELOCATORS, which resemble mini operating systems, but often
malfunction on the 68040 due to excessive programming ‘exuberance’.
This system has the ‘advantage’ of being slightly faster on
floppy disks than normal DOS, but the disadvantage of not being able to install the program on
hard disk, nor can it be converted for CD32, etc.

2) ‘LEGAL’ LOADING USING DOS.LIBRARY, which is very similar to
the method used by any program that uses the operating system,
compiled with any language such as C, AMOS, etc.
In reality, by maintaining our own copperlist and operating on the hardware registers,
 we create a “hybrid” system, i.e. we use dos.library in a
“special” state with our copperlist and our interrupts.
A feature of programmes that use this system is that the
operating system must be left “untouched” and the code must
be totally relocatable (with access to any FAST RAM)
.
This system has the advantage of being able to be used on hard disks, CD-ROMs
and any drive supported by the system, even future peripherals.

Although the first system may seem more appealing to someone who wants to
program at the hardware level, it is actually an OLD,
OFTEN INCOMPATIBLE and limiting method due to the impossibility of installing
the program (or demo) on the hard disk. As long as we are talking about a demo or a game
for Amiga500 that is only 1 disk, the
trackloader option may be acceptable, but with 2 or more disks, the system will only annoy
hard disk owners, who will become more and more numerous.
A game installed on the hard disk will always load faster than one from a disk
with the fastest loader possible.
Then there is the issue of FAST RAM: in order to use it with a trackloader,
 you would need to create a mini operating system that finds where it is and
relocates the code to the right address. I am not going to give you the
listing for one of these loaders+relocators, so as not to lead you down the wrong
path. Think of the satisfaction of being able to convert your game for
the CD32, or seeing it run on the 68060 and on any hard disk, and
then think of the disappointment of seeing the “manual” relocator fail or noticing that
the program does not take advantage of fast RAM.... Have I convinced you?

There is also another thing: it would be good to use the ‘assign’ command for
our productions that need to load files. For example, if we make a
single-disk game and name the disk “Dog”, we can load the
files with ‘Dog:file1’, ‘Dog:file2’, ‘Dog2/objects/obj1’, and so on.
If you want to install it on your hard disk, just create a directory,
copy the contents of the disk into it, and add the following to the startup sequence:

assign    Dog: dh0:giococane    ; for example...

If the game is on multiple disks, just copy all the disks into the directory
and assign each disk:

assign    Dog1: dh0:doggame
assign    Dog2: dh0:doggame
assign    Dog3: dh0:doggame

To ‘automatically’ add the necessary assignments to the startup sequence or user startup
during game installation, you can use the
options of the Commodore installer or other systems, but this is beyond the scope of this course.

Now let's see how to load a ‘path:xx’ file into a destination in
memory. There are several ways. The simplest is this:

LoadFile:
move.l    #filename,d1    ; address with string ‘file name + path’
MOVE.L    #$3ED,D2    ; AccessMode: MODE_OLDFILE - File that already exists
; and can therefore be read.
MOVE.L    DosBase(PC),A6
JSR    -$1E(A6)    ; LVOOpen - ‘Open’ the file
MOVE.L    D0,FileHandle    ; Save its handle
BEQ.S    ErrorOpen    ; If d0 = 0 then there is an error!

MOVE.L    D0,D1        ; FileHandle in d1 for Read
MOVE.L    #buffer,D2    ; Destination address in d2
MOVE.L    #42240,D3    ; File length (EXACT!)
MOVE.L    DosBase(PC),A6
JSR    -$2A(A6)    ; LVORead - read the file and copy it to the buffer

MOVE.L    FileHandle(pc),D1 ; FileHandle in d1
MOVE.L    DosBase(PC),A6
JSR    -$24(A6)    ; LVOClose - close the file.
ErrorOpen:
rts


FileHandle:
dc.l    0

; Text string, ending with a 0, which d1 must point to before
; opening dos.lib. It is best to enter the entire path.

Filename:
dc.b    ‘Assembler3:sorgenti7/amiet.raw’,0    ; path+filename
even

This is perfect if you know the exact length of the file to be loaded.
Since this is our program, we assume that we know how long
our data files are!

Let's look at an example in Lesson11o1.s

However, we are more interested in loading a file while we are
viewing our copperlist, and perhaps playing music in
interrupt. How can we reconcile a ‘legal’ load with an operating system
that is completely disabled? First, let's consider the fact that system interrupts
must all be reactivated, while the system copperlist
is not needed, and we can keep ours. So how can we continue playing
music, or do something else, while a load is in progress?
There are many ways to do this. We could add our own routines
legally to the system interrupt, with an AddIntServer().
Or we could execute our own interrupt, which then JUMPS to execute
the system one. This is a slightly less respectful way, but it works and
I prefer to use it, also because I've seen it used in CD32 games.
Basically, here's what we need to do: restore the old interrupts and the
old DMA/INTENA status, re-enable multitasking, etc., as
we do on exit, but leave our copperlist and ‘insert’ our
$6c interrupt in addition to the system one. Then load the file, and
WAIT A FEW SECONDS TO MAKE SURE THAT THE DRIVE OR
HARD DISK OR CD-ROM LIGHT HAS GONE OUT, then close everything and go back
to hammering away mercilessly.
In short, before and after loading, you need to re-enable and disable the
operating system, leaving our copperlist.
The only detail is the interrupt: how do we execute ours, then
jump to the old one? I want to propose a system for real smugglers,
but it works, provided that you call the routine ‘ClearMyCache’, which
resets the processor's instruction cache (68020+).
In fact, we will use for the first (and last) time, SELF-MODIFYING code!
It should never be used, but I want to show you one of the few cases where
it works and is useful, just for information.
You know that every instruction, when assembled, becomes a
series of hexadecimal values? For example, RTS becomes $4e75, and so on.
We have to JUMP to the old interrupt after executing ours.
So, a ‘JMP $12345’, for example, becomes ‘$49f900012345’, i.e. $4ef9,
followed by the address to jump to, which is a long:

dc.w    $4ef9        ; hexadecimal value of JMP
Crappyint:
dc.l    0		; Address to jump to, to be AUTOMODIFIED...

Now, if we put the system interrupt address in CrappyInt with:

move.l    oldint6c(PC),crappyint    ; For DOS LOAD - we will jump to oldint

We would have the ‘JMP oldint6c’ we were looking for... so the final interrupt is:

: ||| |.
 |||| . oO\ .
: ([oO]) (^) \O/<:
|__\--/__ |\__> |
- - - --+------ - ---- ----- - ---------- ------ ------- - - -----+- - -
*****************************************************************************
; Interrupt routine to be placed during loading. The routines that
; will be placed in this interrupt will also be executed during
; loading, whether from floppy disk, hard disk, or CD ROM.
; PLEASE NOTE THAT WE ARE USING THE COPER INTERRUPT, NOT THE VBLANK INTERRUPT,
; THIS IS BECAUSE DURING LOADING FROM DISK, ESPECIALLY UNDER KICK 1.3,
; THE VERTB INTERRUPT IS NOT STABLE, so much so that the music would jump.
; Instead, if we put ‘$9c,$8010’ in our copperlist, we can be sure
; that this routine will be executed only once per frame.
*****************************************************************************

myint6cLoad:
btst.b    #4,$dff01f    ; INTREQR - is bit 4, COPER, reset?
beq.s    nointL        ; If so, it is not a ‘true’ int COPER!
move.w    #%10000,$dff09c    ; If not, this is the right time, let's remove the req!
movem.l    d0-d7/a0-a6,-(SP)
bsr.w    mt_music    ; Play music
movem.l    (SP)+,d0-d7/a0-a6
nointL:
dc.w    $4ef9        ; hexadecimal value of JMP
Crappyint:
dc.l    0        ; Address to jump to, to be AUTOMODIFIED...
; WARNING: the automodifying code should not
; be used. However, if you call a
; ClearMyCache before and after, it works!

As you can see, just point this interrupt to $6c+VBR to execute mt_music
and the old system interrupt, obtaining music+loading
simultaneously.

Let's see an example in Lesson11o2.s

At this point, you can imagine what the routine that blocks
intuition input: when we load a file, we re-enable multitasking
and system interrupts, so even if our
copperlist is displayed, the workbench works perfectly, so much so that if during a
load you move the mouse ‘blindly’, you can even activate some
menus or click on some icons, or give keyboard commands to the cli.
Think of a gamer who has a habit of moving and clicking the mouse
during loading so as not to get nervous: when exiting the game, they may
realise that they have clicked on the Hard Disk icon and accidentally chosen
the format option from the WB menu that they didn't see, and perhaps by
accidentally pressing the keyboard, they may have given it an obscene name.
So, even if calling the InputOff routine is not essential once the operating system has been disabled, if files are loaded or
other operations are performed, it is best to ensure that no damage can be done!
-    -    -

To finish the lesson, let's see how to load a file whose length we don't
know in advance, taking the opportunity to explain
the AllocMem and FreeMem routines.
To find out the length of a file, just run a special function,
called Examine, provided that you have locked the file. This is not very
difficult, just a few extra JSRs.
Note that Examine simply fills a buffer 104 bytes long
with the various data in the file. Here is an example:


cnop    0,4    ; Warning! The FileInfoBlock must be aligned
; to a longword, it is not enough for it to be at an even address!

fib:
dcb.b    $104,0    ; FileInfoBlock structure: offsets.
; 0 = fib_DiskKey
; 4 = fib_DirEntyType (<0 = file, >0 = directory)
; 8 = FileName (max 30 characters, terminated with 0)
; $74 = fib_Protection, $78 = fib_EntryType
; $7c = fib_Size, $80 = fib_NumBlocks
; $84 = fib_Date (3 longs: Days, Minute, Tick)
; $90 = comment (ends with a 0)

As you can see, at offset $7c we find the length. The other things are not
important... what do we need the date or comment for?
However, since we need to allocate memory for the file, we will also allocate it
for the FileInfoBlock, so as to save ourselves this ‘dcb.b $104,0’.
Once we know the length of the file, we will need to create a buffer in memory
as long as the file, in order to load it into it. This is done with AllocMem,
which requires the number of bytes to allocate and the type of memory,
whether chip or not, in a similar way to sections with ‘_C’ or not.
Unlike sections, however, at the end of the programme we must manually free
all the blocks allocated using the FreeMem function.

AllocMem
--------

This Exec routine is used to request a block of memory to use for
our purposes. Just indicate the type of memory required (basically whether
it should be CHIP RAM or not) and the length of the block in bytes.
The routine ALLOCATES the free RAM for our exclusive use,
as we take possession of it, since the operating system will no longer write
to that piece of memory until we ‘return’ it with freemem.
In fact, the Amiga multitasking system works with this system: each
program requests the memory it needs via AllocMem, the operating system
reserves pieces of free RAM for it, then another program that
loads in multitasking will be allocated other parts of free RAM.
For now, we have used ‘SECTION BSS’ for the zeroed memory spaces we
needed, as we knew their size at the outset.
It is better to use BSS for bitplanes or buffers of a certain size, for
various reasons, such as not having to call routines and being able to put
labels here and there in the buffer, unlike allocated memory, which we would have to
access via offsets from the beginning of the block.
In our listing, we load a file into memory whose length we do not know,
 so here it is mandatory to use AllocMem, after we have
found out how much space the file will occupy.
Let's look at the function in detail:

move.l    Size(PC),d0 ; Block size in bytes
move.l    TypeOfMem(PC),d1 ; Memory type (chip, public...)
move.l    4.w,a6
jsr    -$c6(a6)    ; Allocmem
move.l    d0,FileBuffer    ; Start address of the allocated memory block
beq.s    EndMem        ; d0=0? Then error!
...

If it is not essential to allocate chip memory (i.e. if neither graphics nor sound will be stored in the allocated buffer),
 always allocate ‘MEMF_PUBLIC’, which means:
‘fast memory if available, or chip memory if not’.
I would like to remind you once again that it is a good idea to save chip memory, and that FAST
memory is faster than chip memory.
At the output, d0 will contain the address of the requested memory block, which
will also be aligned to a long word (i.e. aligned to 32 bits).
If, on the other hand, d0=0, it has not been possible to allocate a block of this type!
Always test this, or in case of memory exhaustion you will copy everything to $0!!!

We can also request that the requested memory be cleared, just
set the MEMF_CLEAR bit, 16 ($10000). Here are the most useful parameters to
put in d1, to request the various types of memory:

MEMF_CHIP    =    2    ; Chip Ram request
MEMF_FAST    =    4    ; Fast Ram request (do not use)
MEMF_PUBLIC    =    1    ; Fast request, but if not available, chip is fine!

And, of course, if you want the blocks to be cleared:

CHIP        =    $10002
FAST        =    $10004    ; do not use...
PUBLIC        =    $10001

I do not recommend requesting MEMF_FAST, because fast is not present on
all machines. Always use MEMF_PUBLIC, except when the allocated memory
must be used as a bitplane, copperlist or audio, i.e. MEMF_CHIP.
Note that the length of the block we enter will be rounded by the
operating system to a multiple of the system chunks. This is not
a problem for us, because if we enter 39, it will probably allocate 40,
but the 39 requested are all there, so we don't care.
When exiting the programme, remember to free the memory block!

FreeMem
-------

This is the routine to call to free the allocated memory blocks.
The address of the block is required in a1, and the length in bytes in d0.
WARNING: If you try to free a block that has not been allocated,
 you will cause a crazy mess with Guru Meditation/soft Failure!
Here's how to free the memory block from before:

move.l    Size(PC),d0 ; Size of the block in bytes
move.l    FileBuffer(PC),a1 ; Address of the allocated memory block
move.l    4.w,a6
jsr    -$d2(a6)    ; FreeMem

/T /I
/ |/ | .-~/
T\ Y I |/ / _
/T | \I | I Y.-~/
I l /I T\ | | l | T /
T\ | \ Y l /T | \I l \ ` l Y
__ | \l \l \I l __l l \ ` _. |
\ ~-l `\ `\ \ \\ ~\ \ `. .-~ |
\ ~-. ‘-. ` \ ^._ ^. ’-. / \ |
.--~-._ ~- ` _ ~-_.-‘-.’ ._ /._ .‘ ./
>--. ~-. ._ ~>-’ ‘\\ 7 7 ]
^.___~’--._ ~-{ .-~ . `\ Y . / |
<__ ~"-. ~ /_/ \ \I Y : |
^-.__ ~(_/ \ >._: | l______
^--.,___.-~‘ /_/ ! `-.~’--l_ / ~‘-.
(_/ . ~( /' ’~‘--,Y -=b-. _)
(_/ . \ : / l c’~o \
\ / `. . .^ \_.-~"~--. )
(_/ . ` / / ! )/
/ / _. “. .”: / “
~(_/ . / _ ` .-<_
/_/ . ” .-~‘ `. / \ \ ,z=.
~( / “ : | K ’-.~-.______//
‘-,. l I/ \_ __{--->._(==.
//( \ < ~’~" //
/” /\ \ \ ,v=. ((
.^. / /\ ‘ }__ //===- `
/ / “ ” ’-.,__ {---(==-
.^ ' : T ~‘ ll
/ . . . : | :! \\
(_/ / | | j-’ ~^
~-<_(_.^-~"

At this point, we can also see the programme: Lesson11o3.s
