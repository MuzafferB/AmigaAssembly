
PROJECT FOR THE LESSON ON 3D:

For now, there are only bits and pieces of other people's documents and my own provisional notes, which are not very well organised
but can serve as a STARTING POINT.
Please note that this lesson will be posted after those explaining copper,
blitter, interrupts, etc., so readers will already be familiar
with the hardware manual.


Here is the “plan” for this lesson:

1 - PERSPECTIVE

1) Explanation of perspective, up to a simple routine.
There is already lesson 3d-1, which is an idea: only use translations to make it clear
... at the beginning, only PLOT points, to make it clearer....
1b) Once perspective has been explained, other examples can be given, such as
classic 3D stars coming from the centre; there are reference lists
...
1c) I don't know, a 3D floor, something that only uses perspective without
rotations, only translations.

2 - ROTATIONS

2) Now that perspective is understood, you can do the first rotations, but
at the beginning it is best to do them only around one axis, then around two and
finally around three, but with lots of reference strips for each step and
a decent explanation of WHY the points rotate. At the same time as
the rotations, you can also start using LINES... but for now
just normal WIREFRAME...

2b ) Once the rotations have been done, you could also insert vectorballs, just
explain the sort routine, the blitter one, well, at this
point they already know the blitter.

3- HIDDEN

3) Then you need to explain how to do the hidden line vector, and then also
the filled ones..... keep it simple and show the various steps with various
lists illustrating the evolution...

4 - LIGHTSOURCE or other

4) The aim of the lesson is to make it clear to ANYONE how to make an
old-style filled vector. There is no need for excessive optimisations
that complicate understanding, or mess with intersections or REAL lightsource
etc. However, you could illustrate how to make a faked lightsource
with the average Z position of the faces, or how to make inconvex solids
etc...

As for textures, zoom and pic rotations, or DOOM-style mazes,
 since they have been around since 1992-93, and are therefore more recent than vectors, I would put them
in a separate lesson later on. Here we cover the evolution of vectors from
1987 with line vectors to 1990-91 with light sources.

In the three directories there are various examples, including your listings, just for
reference, in the compilation of examples and theory:

DIR:

3d0 - this lesson, and the listings from dot/linevector to hiddenlinevector
3d1 - vectorballs!
3d2 - filled vectors, including lightsourced.
3d3 - just for filling, shaded vectors and chiunkyvecs by darkman, nothing
new, but at least they fill up the empty part of the disk...!!!

******************* START OF LESSON: **********************************

- representation system

Note: to make a linevector, all you need to know is third-year
maths. (It's different for a filled lightsourced vector).
Anyway, remember never to continue reading until you have
understood EVERYTHING, or at least go back and reread what you
didn't understand before. After all, there are only a few formulas, which once
‘translated’ into 680x0 routines work “ on their own, and you just need to increase the number
of dbra loops to make more complex objects appear.
So try to understand how they work, that way you can make your
own modifications or 'inventions”, otherwise you'll just be changing the
objects and using the example routines, which isn't very useful.
The important thing is to take small steps, without expecting to understand everything in one
afternoon.
You also need to have a lot of imagination in terms of three-dimensionality,
i.e. you need to be able to imagine what a certain object looks like when
viewed from above, from the side, etc. In practice, it would be useful to
know about orthogonal projections, which are a representation system
familiar to those who use 3D programmes such as Imagine or Real 3D.

******************************************************************************
*                PERSPECTIVE                 *
******************************************************************************

Let's imagine we are in an Arizona prairie, riding a motorcycle
,
 and we have stopped to gaze at the horizon.
Suddenly, a cube appears in the sky! A UFO!?
Well, UFO or not, it's a good example to explain how perspective works.
As you know, we have two eyes. Well, let's pretend we only have one,
otherwise we would have to consider too many things that flow into the helmets of
visual reality and stereometry.
So we were alone with the UFO, and since we are tough, we wear an eye patch
over our eye like a pirate (along with a pigtail, earring, etc.), and we see
the UFO with only one eye uncovered.
We are so surprised that it doesn't even occur to us to lift the blindfold to
see better. Meanwhile, the cube approaches, rotating menacingly.
Being tough, instead of running away, we start studying perspective.
Here is an illustration:

___
/__ /|	<-- UFO             !
| | |
|___|/                 -O. <--- US
||
______________________________________________/\_____________

This image is seen from the “side”.

However, we see the image “in perspective”:

_______________________________
|                |
|     ____        |
|     / /\        |
|     /___/ \        |
|     \ \ /        |
|     \___\/        |
|                |
|-------------------------------| <- HORIZON LINE
|                |
|                |
|_______________________________|


This is how the image should appear on the monitor, i.e. similar to what
you see with your eyes. But how do you get it?
The problem is that the SOLID figure has 3 dimensions, while the monitor has
only 2! Height and width! It is missing the Z, i.e. depth.
So, we are trying to transform something that is three-dimensional
into a two-dimensional figure.
 We do this when we take a photograph: a cube would be depicted in two dimensions.
Now we know what we are looking for. Let's take a closer look at the situation:

Let's make a diagram:

|
______________ _        |
/|         /|     _    |
/ |         / |	 _    |
/ |         / |        - _
/ |        / |        | - _ _
/____|________/ |        | _ - _-¢_> EYE
| | | |     _ - _ -
| |_______|____ |_ -    | _ -
| /     | /     _ -
| / | / _ -    |
| /     | / _ -    |
| /     | / _ -        |
|/____________|/-        |
|
|

^            ^
OBJECT X,Y,Z     FRAME


We see the object in space, our eye, and between the eye and the object
a mysterious frame.
So, so. We have defined the object by its points X, Y, Z. And
we see the path these points take to reach the eye: all the rays
go to the eye, and the rays from the eye go to the points, depending on
philosophical interpretations. However, it is certain that a figure is traced on the picture.
Mmmmh... OF COURSE! It's perspective projection! In practice, the
picture is nothing more than our MONITOR, on which the
perspectically distorted figure is formed. In fact, if you notice, if the cube moves away,
 the figure in the picture becomes smaller, if it moves closer, it
becomes larger, just as happens when we see objects approaching or moving away
!
Now,
 we know that the two-dimensional equivalent (printable on the monitor) of our three-dimensional object would be obtained by placing a sheet of glass
between us and the object and “tracing” the figure we see using a marker pen
on the glass. Logical, isn't it? But here we have neither marker pens nor a sheet of glass
on which to trace the image. We have coordinates...

|
/|
/ |
/ |
/ |
/ |
______________ _     / |
/|         /|     _ | |
/ |         / |     _ | |
/ |         / |     |-___ |
/ |        / |     |/__/||- _ _
/____|________/ |     || ||| - _-¢_> EYE
| | | |     _ || ||| -
| |_______|____ |_ - ||__|/|
| /     | /     _|- |
| / | / _ - | |
| /     | / _ - | /
| /     | / _ -     | /
|/____________|/-     | /
| /
| /
|/

^            ^
EYE         FRAME


We have tilted the frame slightly, and we can see that our cube is actually
drawn, and it is IN ONLY TWO DIMENSIONS! X and Y!

Let's make our discussion a little more scientific: we have a
2-dimensional monitor, X and Y, on which we can draw points, lines or
whatever we want by giving the coordinates of the points:


0.0        X axis
o---------------------------------> 320.0
a |
s |
s |
e |
|
Y |
|                 |
|                 ___| 320.256
\/
0.256

The top left corner of the monitor is point 0.0.


Now, we have to design our 3-dimensional object, X, Y and Z, where Z
we can call “depth”:

+
/|
/
/
/
/
/
0,0,0 /        X axis
o--------------------------------->
/|
/ |
Z / |
/ a |
e / s |
s / s |
s /    e |
a /     |
/    Y |
/     |
|/     |
- \/


As you can see, an axis has been added that comes towards us, as if
the X and Y axes were the corners of a window, and Z were an open shutter
:
___        -> X
/| |
/ | |
/ | |
| | |
| |___|
| /
|/

/ |

Z     Y


If we were a point in the window, moving to the right would increase our X,
moving down would increase our Y, and moving out of the house towards
you would decrease the Z, i.e. the depth, and in theory we would come out
of the monitor and into your face.
But this is not possible, so we have to make it “seem” that way.
Note that usually the Z value increases as the object moves
away from the observer, i.e. as it “enters the house”.
.
The observer, i.e. the eye, is usually at point Z=0, and negative Z values
appear when the object passes “behind” us and we therefore cannot see it.

Meanwhile, let's design our cube in the X, Y, Z coordinate system:
To do this, you can use graph paper or millimetre paper, or “in your head”
if you're a genius.
Here is a kind of design for a cube, which, as you know, has 6 faces and
no less than 6 edges, i.e. the points we are interested in.


LESS< X >MORE        LESS            MORE
^            /|
Y         Z
v         |/
MORE         LESS


(P4) -50,-50,+50______________+50,-50,+50 (P5)
/|         /|
/ |         / |
/ |         / |
/ |        / |
(P0) -50,-50,-50/____|________/+50,-50,-50 (P1)
| | | |
| |_______|_____|+50,+50,+50 (P6)
| /-50,+50,+50 (P7)
| /     | /
| /     | /
| /     | /
|/____________|/+50,+50,-50 (P2)
(P3) -50,+50,-50


As you can see, X is the right-left deviation, Y is the “up-down” and Z is the
depth, i.e. “forward-backward”.

If you notice, in this example, point 0,0,0 is at the centre of the cube, just to
make the system clearer: in fact, the 4 points that form the left face
all have the X coordinate = -50, while those that form the right face
all have the X coordinate = +50.
On the other hand, the 4 points that form the upper face all have the Y coordinate
Y = -50, while those forming the lower face have Y = +50.
(Note that here Y increases as you go “up”).
Finally, the four points forming the “front” face have the Z coordinate = -50,
while the 4 points of the ‘back’ face have the Z coordinate = +50, i.e.
deeper.

With this information, we can create a data structure of a cube made up of
points to form our object:

CubeObject:    ; Mega Simple Mythical Cube, 8 Points.
; Here are the 8 points defined by the X, Y, Z coordinates

dc.w    -50,-50,-50    ; P0 (X,Y,Z)
dc.w	+50,-50,-50    ; P1 (X,Y,Z)
dc.w    +50,+50,-50    ; P2 (X,Y,Z)
dc.w    -50,+50,-50    ; P3 (X,Y,Z)
dc.w    -50,-50,+50    ; P4 (X,Y,Z)
dc.w    +50,-50,+50    ; P5 (X,Y,Z)
dc.w    +50,+50,+50	; P6 (X,Y,Z)
dc.w    -50,+50,+50    ; P7 (X,Y,Z)

NPuntiOggetto    = 8

OK, we have the object! The problem now is how to put it in perspective.

******************************************************************************
*    LET'S CALCULATE THE Y COORDINATES OF THE POINTS PROJECTED ON THE SCREEN     *
******************************************************************************

Let's go back to the diagram with the eye from before to see how to find the
Y coordinates of the points projected on the screen; Let's assume that
the eye is on the ground, at position Y=0. I know this is impossible, but
pretend you are in a trench and you can see the cube sticking out of the ground:

“PROFILE” view:

<---------------- Z axis (depth) --------------->
^
|                    |
a             P        |    
s     ______________ _        |    
s     /|         /|     _    |    
e     / |         / |     _    | P¹    
/ |         / |        - _
Y     / |        / |        | - _ _         GROUND
----- /____|________/ |-----------+-----------¢_> EYE -------------
|    | | | |T        |T¹
|    | |_______|____ |        |
|    | /     | /        |
v    . .     . .
^            ^
OBJECT X,Y,Z     FRAME


Points:

EYE    = position of the observer, let's call it O
P    = Point of the object in space XYZ
P¹    = Point P projected onto the frame
T    = Y=0 (ground level) at the point where the cube ‘appears’.
T¹    = Y=0 (ground level) at the point where the picture is ‘planted’.

Let's see how to find the Y coordinate of point P¹ on the screen (the monitor),
i.e. its perspective projection. If you notice, two similar right-angled triangles “appear”,
namely “O-P-T” and “O-P¹-T¹”:

P
|-_ |(picture)
| -_ |
a | -_ |
s | -_|P¹
s |    +_    
e |    | -_
|    | -_
Y |    | -_
|    | -_
|T_______|T¹_______-O (eye)

<---- Z axis ---->


Segments:

PT    = Y coordinate of point P in space (Yogg)
P¹T¹    = Y coordinate of point P¹ in the frame (UNKNOWN Y¹)
OT    = Z distance of point P from the observer (DistZpoint)
OT¹    = Z distance of theobserver from the frame (DistZscreen)

If we know PT, OT and OT¹, to find P¹T¹ we need to consider that
the height of the large triangle is to the height of the small triangle
(the one we need) as the base of the large triangle is to that of the
small triangle. I think it's clear, no?
Therefore, PT is to P¹T¹ as OT is to OT¹, in other words: PT:X=OT:OT¹

To obtain what we are looking for, i.e. P¹T¹ (the Y coordinate of the point
projected onto the screen), we must multiply the extremes of the proportion,
i.e. PT*OT¹, and divide the result by OT:

P¹T¹=(PT*OT¹)/OT

We could “translate” this into:

Yprojected = (Yogg*DistZoffScreen)/DistZPoint

And then, roughly, into:

move.w    Yogg,d0            ; Y coordinate of the object
muls.w    DistZoffScreen,d0	; DistZoffScreen*Yogg
divs.w    DistZPoint,d0    ; In d1 we have the Y coordinate of point P¹

Of course, we will need to create a loop that projects all the points.

******************************************************************************
*    CALCULATING THE X COORDINATE OF THE POINTS PROJECTED ON THE FRAME     *
******************************************************************************

Well, now you should already guess that to calculate the X of point P¹, the
procedure is similar. First, we saw the scene in profile, so
the Y axis was to be considered “upright”, i.e. perpendicular to the ground,
like a lamppost. TheX axis, on the other hand, was facing us, and in theory
only one point was visible, like an arrow pointing at us.
The Z axis, on the other hand, was the horizontal line, identifiable with the ground.
Now let's move to see the scene from above, so that the Z axis
remains unchanged, while the X axis takes the place of the Y axis:

Now let's move to a view from “ABOVE”:

P
|-_ |(picture)
| -_ |
a | -_ |
s | -_|P¹
s |    +_    
e |    | -_
|    | -_
X |    | -_
|    | -_
|T_______|T¹_______-O (eye)

<---- Z axis ---->

In this case, point P is moved to the right of the observer.

Segments:

PT    = X coordinate of point P in space (Yogg)
P¹T¹    = X coordinate of point P¹ in the frame (UNKNOWN Y¹)
OT    = Z distance of point P from the observer (DistZpoint)
OT¹    = Z distance of the observer from the frame (DistZscreen)

Let's see how to find the X coordinate of point P¹.
Once again, we must do the following:

P¹T¹=(PT*OT¹)/OT

We could ‘translate’ this into:

Xprojected = (Xogg*DistZossScreen)/DistZPunto

And then, roughly, into:

move.w	Xogg,d0            ; X coordinate of the object
muls.w    DistZoffScreen,d0    ; DistZoffScreen*Xogg
divs.w    DistZPoint,d0    ; In d1 we have the X coordinate of point P¹

Ultimately, we have to do the ‘same’ thing to find Y and X.

move.w    Xogg,d0            ; X coordinate of the object
move.w    Yogg,d1            ; Y coordinate of the object
muls.w    DistZossScreen,d0    ; DistZossScreen*Xogg
muls.w    DistZossScreen,d1    ; DistZossScreen*Yogg
divs.w    DistZPunto,d0    ; In d1 we have the X coordinate of point P¹
divs.w    DistZPunto,d1    ; In d1 we have the Y coordinate of point P¹

******************************************************************************
*        FINAL PERSPECTIVE PROJECTION ROUTINE         *
******************************************************************************

Now, however, we need to think about how to create an approximate routine that projects
a 3D point XYZ, obtaining X¹ and Y¹ as output.
To do this, we need to add a few considerations to those already made.
Let's start by calculating the X coordinate of P¹.
We have said that the procedure is as follows:

P¹T¹     = (PT * OT¹     )/OT

Xprojected = (Xogg*DistZossScreen)/DistZPunto

However, it must be said that to find the distance Z of point P from the observer,
which we have identified as OT (distZpoint), we need to make an addition:

DistZpoint = Zogg + DistZscreen

That is, we must add the distance of the observer from the screen to the Z coordinate
of point P, in fact:

P
|-_ |(frame)
| -_ |
a | -_ |
s | -_|P¹
s |    +_    
e |    | -_
|	| -_
X |    | -_
|    | -_
|T_______|T¹_______-O (eye)
-50 -60     -366

<---- Z axis ---->

In this case, we have that the frame is at position Z = -60, while
P is at coordinate Z = -50, and the eye is at -316.
Therefore, we have Zogg = -50 and DistZossScreen = 256. However, the distance from O to T
is 366, which can be obtained by doing 21+(-3), i.e. (shit) Zogg+DistZossScreen.

The final formula is therefore:

P¹T¹     = (PT * OT¹     )/OT

Xprojected = (Xogg*DistZossSchermo)/(Zogg-DistZossSchermo) * NO! MORE
* HOW WAS IT BEFORE -?? porkocan

Nothing to worry about. Our ‘Pseudo-Routine’ becomes:

move.w    Xogg,d0
move.w    DistZossScreen,d1
muls.w    d0,d1        ; Xogg*DistZossScreen
move.w	DistZossScreen,d2
sub.w    Zogg,d2    ; Zogg-DistZossScreen = DistZPunto
divs.w    d2,d1        ; (Xogg*DistZossScreen)/DistZPunto
; In d1 we have the X coordinate of point P¹

Note that we need Xogg and Zogg, which are the X
and Z coordinates of point P, and DistZossSchermo, which is the distance of the observer from the
screen, which must have a value similar to the actual distance of the person looking at
the monitor!
__________
ììììììììì                 /     \
ììììììì \            ||     \
ìììììì <O <--- DistZossScreen --->||     \
ììì(     \            ||     |
ììì '    _|            ||     |
ìì        \            ||     /
|        <            ||     /
|    \     /             \__________/
---'

OBSERVER             MONITOR


Finally, we must consider that the observer's eye is aligned with the
centre of the screen...
And that we must centre the object! So we must add (at the end) the
coordinates of the centre of the screen, otherwise the centre would be point 0,0, i.e.
the top left corner, and our cube would only be visible
in that corner:
___
/__/| 0,0
| x---------------
|_|_|/         |
|         |
|         |
|         |
|         |
|         |
|         |
--------------- 320,256

Instead, by adding CentreX and CentreY, i.e. the
X and Y coordinates of the centre, at the end of the calculations, we move the cube itself to the centre.
If the screen is in LowRes 320*256, the centre will be 160.128 (320/2 , 256/2).

0.0
---------------
|         |
|     ___     |
|    /__/|     |
| | x ||     |    -> the centre is 160.128
| |___|/     |
|         |
|         |
--------------- 320.256


Let's look at the FINAL formula:

P¹T¹     = (PT * OT¹     )/OT         \
Xprojected = (Xogg*DistZossScreen)/(Zogg-DistZossScreen) / + CentreX

Here is the final routine:

PERSPECTIVE:
LEA    XYZtranslatedPoints(PC),A0    ; tab address of X, Y, Z to
; be projected (already translated)
LEA    ProjectedXYPoints(PC),A1 ; table where to put the projected
; X¹,Y¹ coordinates.
MOVE.w    #ScreenWidth/2,D3 ; X centre of the screen (to centre)
MOVE.W     #ScreenLength/2,D4 ; Y centre of the screen (to centre)

MOVE.w    #NPointsObject-1,D7    ; number of points to project
PERLOP:
MOVEM.W    (a0)+,d0/d1/d2    ; X coordinate in d0, Y in d2, Z in d2
MULS.W    DistZoss,d0    ; DistScreenOss*Xogg
MULS.W    DistZoss,d1    ; DistScreenOss*Yogg
ADD.W	DistZoss,d2    ; Zogg+DistZoss_quadro in d2
DIVS.w    D2,D0     ; (DistZossScreen*Xogg)/(Zogg-DistZossScreen)
DIVS.w    D2,D1     ; (ScreenZossDist*Yogg)/(Zogg-ScreenZossDist)
ADD.W    d3,D0     ; + X centre of screen (to centre)
ADD.W     d4,D1     ; + Y centre of screen (to centre)
MOVEM.W	D0-D1,(A1) ; Save projected and translated values X¹ and Y¹
ADDQ.W    #2+2,A1	 ; Jump to the next 2 val.
DBRA     D7,PERLOP ; Repeat NumberPoints times for all points.
RTS         ; until you have projected them all

However, we can decide to set the distance between the screen and the observer
to 256, so that we can transform the 2 muls into ‘ASL.L #8’:

PERSPECTIVE:
LEA    XYZpointsTranslated(PC),A0     ; Address of the X, Y, Z table to
; be projected (already translated)
LEA    XYpointsProjected(PC),A1 ; Table where to put the projected
; X¹,Y¹ coordinates.
MOVE.w    #ScreenWidth/2,D3 ; X centre of the screen (to centre)
MOVE.W     #ScreenHeight/2,D4 ; Y centre of the screen (to centre)

MOVE.w    #NPointsObject-1,D7    ; number of points to project
Projection:
MOVEM.W	(a0)+,d0-d2 ; X coordinate in d0, Y in d1, Z in d2
->    ASL.L    #8,d0     ; (MULS #256) DistZossScreen*Xobject
->    ASL.L    #8,d1     ; (MULS #256) DistZossScreen*Yobject
->    ADD.W    #256,d2     ; Zogg+DistZossScreen (find dist. oss<->point)
DIVS.w    D2,D0     ; (DistZossScreen*Xogg)/(Zogg-DistZossScreen)
DIVS.w    D2,D1     ; (DistZossScreen*Yogg)/(Zogg-DistZossScreen)
ADD.W    d3,D0     ; + X coordinate of screen centre (to centre)
ADD.W     d4,D1     ; + Y coordinate of screen centre (to centre)
MOVEM.W	D0-D1,(A1) ; Save projected and translated values X¹ and Y¹
ADDQ.W    #2+2,A1     ; Jump to the next 2 values.
DBRA     D7,Proiez ; Repeat NumberOfPoints times for all points.
RTS         ; until you have projected them all

(beware of division by zero: but this is not necessary if you are careful...)

->    ADD.W    #256,d2	 ; Zogg+DistZossScreen (find dist. oss<->point)
bne.s    NonZero
moveq    #1,d2    ; avoid division by zero
NonZero:
DIVS.w    D2,D0     ; (DistZossScreen*Xogg)/(Zogg-DistZossScreen)

*****************************************************************************
TRANSLAATIONS

In practice, the same value is added or subtracted from all points x, y, z...
*****************************************************************************

Here, with a kind of mushroom (or lollipop), we illustrate the effect of
simple translations:

------------------------------------------------------------------------------

X¹=X+XF
_     __     ___     __     _
-     /\___    / \__    /. \_    / . \    _/ .\    __/ \    ___/\    +
\/    \_/    \__/    \___/     \__/     \_/     \/

LESS    <    <    <     ZERO     >     >     >    MORE

We move further to the right or further to the left... as if we were seeing it from
the window of a moving train.

------------------------------------------------------------------------------

Y¹=Y+YF

-        LESS
___
<___>         /\
|
___
/ \         /\
\___/
|
___
/ \
| |        ZERO
\___/

_|_
/ \
\___/         \/

|
_|_
<___>         \/

+        MORE

* We see the object from a higher or lower position... as if
we were in a lift.

------------------------------------------------------------------------------

Z¹=Z+ZF
___                
-      / \              ___                 +
( )            / \         .-.
\___/            \___/         \_/     <>    .

LESS    <    <    <     ZERO     >     >     >    MORE


* The object gets bigger or smaller: it moves closer or further away

******************************************************************************
*                ROTATIONS                 *
******************************************************************************

explain slowly... first 2D rotation with respect to a single axis, then
gradually until you reach a fast routine, OK?


a = in radians (radians = degrees/57.295779 - e.g. 1 degree = 1/57.xx=0.017453)

360° = 2*Pi

Around

Xnew = X*COS(a)-Y*SIN(a)

z-axis:

Ynew = X*SIN(a)-Y*COS(a)
Znew = Z

Around

Xnew = X

X-Axis:

Ynew = Y*COS(a)-Z*SIN(a)
Znew = Y*SIN(a)+Z*COS(a)

Around

Xnew = X*COS(a)+Z*SIN(a)

Y-Axis:

Ynew = Y
Znew = X*SIN(a)+Z*COS(a)

OR, IN OTHER WORDS:

xr = X rotation angle
yr = Y rotation angle
zr = Z rotation angle

X¹ is the new X, to be used next time; it is calculated 2 axes at a time using
the values from the previous calculation.

Y¹=Y*COS(xr)-Z*SIN(xr)        ;\ X
Z¹=Y*SIN(xr)+Z*COS(xr)        ;/

X¹=X*COS(zr)-Y*SIN(zr)        ;\ Z
Y¹=X*SIN(zr)+Y*COS(zr)		;/

X¹=X*COS(yr)-Z*SIN(yr)        ;\ Y
Z¹=X*SIN(yr)+Z*COS(yr)        ;/

Cos(a) =     X1*X2+Y1*Y2+Z1*Z2
-------------------------------------
sqrt((x1^2+y1^2+z1^2)*(x2^2+y2^2+z2^2)


------------------------------------------------------------------------------

YY = Y*Cos(AX) + Z*Sin(AX)
Z = Z*Cos(AX) - Y*Sin(AX)
Y = YY

XX = X*Cos(AY) + Z*Sin(AY)
Z = Z*Cos(AY) - X*Sin(AY)
X = XX

XX = X*Cos(AZ) + Y*Sin(AZ)
Y = Y*Cos(AZ) - X*Sin(AZ)
X = XX

------------------------------------------------------------------------------

;ROTATIONS: angles r1,r2,r3
;     coordinates x,y,z
; xa,ya,za temporary variables

xa=cos(r1)*x-sin(r1)*z
za=sin(r1)*x+cos(r1)*z
x=cos(r2)*xa+sin(r2)*y
ya=cos(r2)*y-sin(r2)*xa
z=cos(r3)*za-sin(r3)*ya
y=sin(r3)*za+cos(r3)*ya

----------------------------------------------------------------------------

X AXIS:

___     ___     ___     ___
+     _|_     |     _L_    / \    <_ _>     |    <_i_>    -
<_'_>     _|_    <___>     \___/     T     |	 |
MORE                                LESS

Rotates around itself around axis ________ X

This movement is reminiscent of the rotation of a fan or a ship's propeller
seen in profile.

------------------------------------------------------------------------------

Y AXIS:


_          __     ___     __          _
+     ___\    ___/\    _/ \    / \    / \_    /\___    / __    -
\_/     \/     \__/    \___/    \__/    \/    \_/

MORE    <    <    <     ZERO     >     >     >    LESS


Rotates around itself around axis | Y
|
|
|

This rotation may resemble a helicopter propeller!

------------------------------------------------------------------------------

Z AXIS:

___|_         _|_        _|___
+     |     X     |    X     |     -
/      |     \
MORE                        LESS

Rotates around itself around axis · Z    (axis facing you!)

In practice, if the rotation is POSITIVE, the object rotates clockwise,
just like a clock hand, while if it is NEGATIVE, it rotates
counterclockwise.

------------------------------------------------------------------------------

(fare pannello:

+ X TRASL -

+ Y TRASL -

Ecc. con mouse...


******************************************************************************
*            HIDDEN LINES and FILLED                 *
******************************************************************************

(From an article by Slave/Perspex in Grapevine #16.

Filled vectors

The basic principle of vectors is that objects are made up of points that
are connected to each other by lines to form “faces”.
The points can be identified by 3 coordinates in the 3 axes X, Y, Z.
X is the left-right deviation, Y is the “up-down” and Z is the depth,
i.e. “front-back”.


Here is a kind of cube design, which, as you know, has 6 faces and no
less than 6 edges, i.e. the points we are interested in.


-50,+50,+100______________+100,+100,+100
/|         /|
/ |         / |
/ |         / |
/ |     / |
- 50,+100,-50/____|________/+100,+100,-50
| | | |
| |________|____|+100,-50,+100
| /-100,-100,+100/
| /     | /
| /     | /
| /     | /
|/____________ |/+100,-100,-100
-100,-100,-100


With this information, we can create a data structure of a cube made up of
points and faces to form our object:

CubeObject:	; Mega Simple Cube, 8 points and 6 faces.

CubePts:
dc.w    8-1        ; 8 points (we put -1 because we will make a DBRA
; for the loop taking this value.
; as you know, DBRA requires num.loop-1
dc.w    -100,+100,-100	; Here are the 8 points defined by the X, Y, Z coordinates
dc.w    +100,+100,-100
dc.w    +100,-100,-100
dc.w    -100,-100,-100
dc.w    -100,+100,+100
dc.w    +100,+100,+100
dc.w    +100,-100,+100
dc.w    -100,-100,+100

; Here is the information for each face: the first word is the number of
; points-1 (for the dbra), then there are the points that make up that face,
; i.e. which 4 of the 8 points of the cube form that face. Note that
; the order of the points is “clockwise” (i.e. counting them goes in the direction of
; the hands of a clock) when the face is facing the screen, while
; it becomes counterclockwise when the face is behind, i.e. ‘turned’.
; This order will be useful for understanding when a face is visible or
; hidden behind others.

CubeFace1Pts:
dc.w    4-1            ; 4 Points
CubeFace1Cons:
dc.w    0*4,1*4,2*4,3*4,0*4	; 0-> 2-> 3-> 1->0 - The points of this
; face (*4 to quickly find the
; point from the table at the right
; offset by simply adding it to
; where the point table begins.
CubFace1Col:
dc.w    VCol01        ; Face colour ($RGB)

dc.w    4-1
dc.w    4*4,7*4,6*4,5*4,4*4
dc.w    VCol02

dc.w    4-1
dc.w    0*4,3*4,7*4,4*4,0*4
dc.w    VCol03

dc.w    4-1
dc.w    1*4,5*4,6*4,2*4,1*4
dc.w    VCol04

dc.w    4-1
dc.w    0*4,4*4,5*4,1*4,0*4
dc.w    VCol05

dc.w    4-1
dc.w    3*4.2*4.6*4.7*4.3*4
dc.w    VCol06

CubeEnd:
dc.w    0        ; Zero ends the list

The points that must be joined by lines are listed in order; the starting point
is then placed at the end of the list:

Line1 = point0->point1
Line2 = point1->point2
Line3 = point2->point3
Line4 = point3->point0


Now comes the scariest part: the calculations.


AX, AY + AZ = Angle of rotation for X, Y or Z

CX + CY = Centre values for X + Y

CX = 160    ; Dimensions for a 320x200 screen
CY = 100

YY = Y*Cos(AX) + Z*Sin(AX)
Z = Z*Cos(AX) - Y*Sin(AX)
Y = YY

XX = X*Cos(AY) + Z*Sin(AY)
Z = Z*Cos(AY) - X*Sin(AY)
X = XX

XX = X*Cos(AZ) + Y*Sin(AZ)
Y = Y*Cos(AZ) - X*Sin(AZ)
X = XX

Z = 512/(512+Z)
X = X*Z+CX
Y = Y*Z+CY

Now we have everything we need to make a wireframe cube, even in
basic, if you're really sadistic.

; The object is made up of points, connections between those points, and faces.
; The points are ALL the points in the object
; The connections are ‘which points must be joined to make a face’
; The faces are the first 3 points ordered in clockwise order, so you can
; easily implement ‘hidden lines’, i.e. hidden lines.

; Before the face is filled+copied, a small routine calculates the area
(as small as possible) that the blitter will have to fill, clean and
copy. This is done for the X and Y axes.

A precalculated perspective TAB can be used to speed things up,
calculating all possible combinations of Z (Z= 640/
(640+Z)).
; This way, you can remove the slow DIVS, replacing it with a
; routine that finds the right value in the TAB, with the classic:
;
;    lea    PROSPTAB,a0
;    add.l d0,d0
;    move.w (a0,d0.w),d0
;

; The SENO table can be used as a COSENO table thanks to the
; well-known rule COS(n) = SIN(n-90°).

Here is the list of things to do:

1) Locate the object.
2) Take the number of points from the object structure.
3) Rotate all the points of the object in a specially created buffer.
4) Get a pointer to the data block of the first face.
5) Read the number of faces (if = 0, then end of object).
6) Read the points in pairs and send them to the line drawing routine.
7) The line drawing routine draws in a separate buffer.
8) Calculate the X Y area (as small as possible) for the FILL.
9) Fill (with the blitter fill) the face in the buffer.
10) Copy the face from the buffer to the screen (3 bitplanes). With:

; a0 = source
; a4 = dest

move.l    A3,Bltapth(A6)    ; a
move.l    A4,Bltbpth(A6)    ; b
move.l    A4,Bltdpth(A6)	; d
btst.l    #0,D7        ; test if we need this plane
beq.s    PlaneEmpty
PlaneFull:
move.l    #$0DFC0000,BltCon0(A6)	; Minterms For OR
bra.s    BlitPlane
PlaneEmpty:
move.l    #$0D0C0000,BltCon0(A6)    ; Minterms For Mask
BlitPlane:
move.w    D4,Bltsize(A6)		; Size

For a full or empty plane. This must be done for all 3 bitpanes.
The face buffer must be cleared with the smallest X+Y (we have already
calculated this).
Repeat the procedure for all faces of the object.
Calculate the smallest small X+Y rectangle for the screen and clear the screen
before the next loop.

PS: Don't forget to use double buffering.
The double buffer is needed because while a frame is being displayed, you can
clear and write the new one elsewhere, and display it at the end of
the frame. Otherwise, you would see the moment of deletion and
drawing of the solid, due to the slowness of these operations compared
to the video refresh rate. (In practice, it would look like it was done on a crappy PC-MSDOS).


The way the code is put together is that you have a Lev6 running with a double
buffer changer activated by a flag. You have a counter that counts the number
of frames since the double buffer was last activated. And you update the
angle rotation every frame.


Rotate:
move.l    FaceBuffer(PC),A0
lea    STab+$80*2(PC),A5    ; SinTab address
lea    STab+$80(PC),A6        ; CosTab address
move.l    Object(PC),A1        ; Object structure address
lea    XYPoints(PC),A2        ; Where to put the calculated points
;    lea    Perspective(PC),A3    ; Tab with precalculated perspective
moveq    #0,D5
move.w    (A1)+,D5        ; No. of points

; Free = A4

PointLoop:
move.w    (A1)+,D0    ; D0 = X
move.w	(A1)+,D1    ; D1 = Y
move.w    (A1)+,D2    ; D2 = Z

move.w    AngleY(PC),D7
move.w    (A5,D7.W),D6    ; D6 = Sin(AX)
move.w    (A6,D7.W),D7    ; D7 = Cos(AX)

; D0 = X
; D1 = Y
; D2 = Z
; D6 = Sin(AY)
; D7 = Cos(AY)

; YY = Y*Cos(AY) + Z*Sin(AY)
; Z = Z*Cos(AY) - Y*Sin(AY)
; Y = YY

move.w    D1,D3        ; D3 = Y
move.w    D2,D4        ; D4 = Z

Muls.W    D6,D4        ; D4 = Z*Sin(AY)
Muls.W    D7,D2        ; D2 = Z*Cos(AY)
Muls.W    D6,D1        ; D1 = Y*Sin(AY)
Muls.W    D7,D3        ; D3 = Y*Cos(AY)

ADD.L    D4,D3        ; D3 = Y*Cos(AY) + Z*Sin(AY)
Sub.L    D1,D2		; D2 = Z*Cos(AY) - Y*Sin(AY)

ADD.L    D3,D3
ADD.L    D2,D2
SWAP    D3        ; D3 = Y
SWAP    D2        ; D2 = Z

MOVE.W    AngleX(PC),D7
MOVE.W    (A5,D7.W),D6    ; D6 = Sin(AX)
MOVE.W    (A6,D7.W),D7    ; D7 = Cos(AX)

; D0 = X
; D2 = Z
; D3 = Y
; D6 = Sin(AY)
; D7 = Cos(AY)

; XX = X*Cos(AX) + Z*Sin(AX)
; Z = Z*Cos(AX) - X*Sin(AX)
; X = XX

move.w    D0,D1        ; D1 = X
move.w    D2,D4        ; D4 = Z

Muls.W D6,D4        ; D4 = Z*Sin(AX)
Muls.W D7,D2        ; D2 = Z*Cos(AX)
Muls.W D6,D0        ; D0 = X*Sin(AX)
Muls.W D7,D1        ; D1 = X*Cos(AX)

ADD.L	D4,D1        ; D1 = X*Cos(AX) + Z*Sin(AX)
Sub.L    D0,D2        ; D2 = Z*Cos(AX) - X*Sin(AX)

ADD.L    D1,D1
ADD.L	D2,D2 
SWAP    D1        ; D1 = X
SWAP    D2        ; D2 = Z

MOVE.W    AngleZ(PC),D7
MOVE.W	(A5,D7.W),D6 ; D6 = Sin(AZ)
MOVE.W    (A6,D7.W),D7 ; D7 = Cos(AZ)

; D1 = X
; D2 = Z
; D3 = Y
; D6 = Sin(AZ)
; D7 = Cos(AZ)

; XX = X*Cos(AZ) + Y*Sin(AZ)
; Y = Y*Cos(AZ) - X*Sin(AZ)
; X = XX

MOVE.W    D1,D0        ; D0 = X
MOVE.W    D3,D4        ; D4 = Y

Muls.W	D6,D4        ; D4 = Y*Sin(AZ)
Muls.W    D7,D3        ; D3 = Y*Cos(AZ)
Muls.W    D6,D1        ; D1 = X*Sin(AZ)
Muls.W    D7,D0        ; D0 = X*Cos(AZ)

ADD.L	D4,D0        ; D0 = X*Cos(AZ) + Y*Sin(AZ)
Sub.L    D1,D3        ; D3 = Y*Cos(AZ) - X*Sin(AZ)

ADD.L    D0,D0
ADD.L    D3,D3
SWAP    D0        ; D0 = X
SWAP    D3        ; D3 = Y

; D0 = X
; D2 = Z
; D3 = Y

; Z = 512/(512+Z)
; X = X*Z+CX
; Y = Y*Z+CY

ADD.W    Zoom,D2
MoveQ    #8,D7
Ext.L    D0
Ext.L    D3
Asl.L    D7,D0
Asl.L    D7,D3
Tst.W    D2
Bpl.S    ZNotZero
MoveQ    #1,D2
ZNotZero:
Divs.W    D2,D0
Divs.W    D2,D3

;    ADD.W    Zoom(PC),D2    ; D2 = Z+Zoom
;    ADD.L    D2,D2
;    MOVE.W    (A3,D2.W),D2    ; D2 = Z Perspective value

;    Muls.W    D2,D0		; D0 = X*Z
;    Muls.W    D2,D3        ; D3 = Y*Z

;    ADD.L    D0,D0
;    ADD.L    D3,D3
;    SWAP    D0
;    SWAP    D3

ADD.W    #ScreenX/2,D0    ; D0 = X*Z+CX
ADD.W    #ScreenY/2,D3    ; D3 = Y*Z+CY

; D0 = X
; D3 = Y

Move.W    D2,MaxPts*2(A2)    ; Save Z
Move.W    D0,(A2)+	; Save X
Move.W    D3,(A2)+    ; Save Y

DBRA    D5,PointLoop    ; Calculate all points

To know which face is hidden, and therefore which ones not to draw, you need to
take the first 3 rotated points (x+y) of the face and perform the calculation:

If:

((Bx-Ax)*(Cy-By))-((Cx-Bx)*(By-Ay))

If it is positive, then do not draw the face!


; Here is the SINTAB, repeated twice so that it can be used as a COSTAB.

SineTableOfWordsX2:

dc.w	1,$324,$648,$96A,$C8C,$FAB,$12C8,$15E2,$18F9
dc.w	$1C0B,$1F1A,$2223,$2528,$2826,$2B1F,$2E11,$30FB
dc.w	$33DF,$36BA,$398C,$3C56,$3F17,$41CE,$447A,$471C
dc.w	$49B4,$4C3F,$4EBF,$5133,$539B,$55F5,$5842,$5A82
dc.w	$5CB3,$5ED7,$60EB,$62F1,$64E8,$66CF,$68A6,$6A6D
dc.w	$6C23,$6DC9,$6F5E,$70E2,$7254,$73B5,$7504,$7641
dc.w	$776B,$7884,$7989,$7A7C,$7B5C,$7C29,$7CE3,$7D89
dc.w	$7E1D,$7E9C,$7F09,$7F61,$7FA6,$7FD8,$7FF5,$7FFF
dc.w	$7FF5,$7FD8,$7FA6,$7F61,$7F09,$7E9C,$7E1D,$7D89
dc.w	$7CE3,$7C29,$7B5C,$7A7C,$7989,$7884,$776B,$7641
dc.w	$7504,$73B5,$7254,$70E2,$6F5E,$6DC9,$6C23,$6A6D
dc.w	$68A6,$66CF,$64E8,$62F1,$60EB,$5ED7,$5CB3,$5A82
dc.w	$5842,$55F5,$539B,$5133,$4EBF,$4C3F,$49B4,$471C
dc.w	$447A,$41CE,$3F17,$3C56,$398C,$36BA,$33DF,$30FB
dc.w	$2E11,$2B1F,$2826,$2528,$2223,$1F1A,$1C0B,$18F9
dc.w    $15E2,$12C8,$FAB,$C8C,$96A,$648,$324,1,$FCDC
dc.w	$F9B8,$F696,$F374,$F055,$ED38,$EA1E,$E707,$E3F5
dc.w	$E0E6,$DDDD,$DAD8,$D7DA,$D4E1,$D1EF,$CF05,$CC21
dc.w	$C946,$C674,$C3AA,$C0E9,$BE32,$BB86,$B8E4,$B64C
dc.w	$B3C1,$B141,$AECD,$AC65,$AA0B,$A7BE,$A57E,$A34D
dc.w	$A129,$9F15,$9D0F,$9B18,$9931,$975A,$9593,$93DD
dc.w	$9237,$90A2,$8F1E,$8DAC,$8C4B,$8AFC,$89BF,$8895
dc.w	$877C,$8677,$8584,$84A4,$83D7,$831D,$8277,$81E3
dc.w	$8164,$80F7,$809F,$805A,$8028,$800B,$8001,$800B
dc.w	$8028,$805A,$809F,$80F7,$8164,$81E3,$8277,$831D
dc.w	$83D7,$84A4,$8584,$8677,$877C,$8895,$89BF,$8AFC
dc.w	$8C4B,$8DAC,$8F1E,$90A2,$9237,$93DD,$9593,$975A
dc.w	$9931,$9B18,$9D0F,$9F15,$A129,$A34D,$A57E,$A7BE
dc.w	$AA0B,$AC65,$AECD,$B141,$B3C1,$B64C,$B8E4,$BB86
dc.w	$BE32,$C0E9,$C3AA,$C674,$C946,$CC21,$CF05,$D1EF
dc.w	$D4E1,$D7DA,$DAD8,$DDDD,$E0E6,$E3F5,$E707,$EA1E
dc.w	$ED38,$F055,$F374,$F696,$F9B8,$FCDC,2,$66E8,0
dc.w	$240,0,0,0,0,1,$324,$648,$96A,$C8C,$FAB,$12C8
dc.w	$15E2,$18F9,$1C0B,$1F1A,$2223,$2528,$2826,$2B1F
dc.w	$2E11,$30FB,$33DF,$36BA,$398C,$3C56,$3F17,$41CE
dc.w	$447A,$471C,$49B4,$4C3F,$4EBF,$5133,$539B,$55F5
dc.w	$5842,$5A82,$5CB3,$5ED7,$60EB,$62F1,$64E8,$66CF
dc.w	$68A6,$6A6D,$6C23,$6DC9,$6F5E,$70E2,$7254,$73B5
dc.w	$7504,$7641,$776B,$7884,$7989,$7A7C,$7B5C,$7C29
dc.w	$7CE3,$7D89,$7E1D,$7E9C,$7F09,$7F61,$7FA6,$7FD8
dc.w	$7FF5,$7FFF,$7FF5,$7FD8,$7FA6,$7F61,$7F09,$7E9C
dc.w	$7E1D,$7D89,$7CE3,$7C29,$7B5C,$7A7C,$7989,$7884
dc.w	$776B,$7641,$7504,$73B5,$7254,$70E2,$6F5E,$6DC9
dc.w	$6C23,$6A6D,$68A6,$66CF,$64E8,$62F1,$60EB,$5ED7
dc.w	$5CB3,$5A82,$5842,$55F5,$539B,$5133,$4EBF,$4C3F
dc.w	$49B4,$471C,$447A,$41CE,$3F17,$3C56,$398C,$36BA
dc.w	$33DF,$30FB,$2E11,$2B1F,$2826,$2528,$2223,$1F1A
dc.w	$1C0B,$18F9,$15E2,$12C8,$FAB,$C8C,$96A,$648,$324
dc.w	1,$FCDC,$F9B8,$F696,$F374,$F055,$ED38,$EA1E,$E707
dc.w	$E3F5,$E0E6,$DDDD,$DAD8,$D7DA,$D4E1,$D1EF,$CF05
dc.w	$CC21,$C946,$C674,$C3AA,$C0E9,$BE32,$BB86,$B8E4
dc.w    $B64C,$B3C1,$B141,$AECD,$AC65,$AA0B,$A7BE,$A57E
dc.w	$A34D,$A129,$9F15,$9D0F,$9B18,$9931,$975A,$9593
dc.w	$93DD,$9237,$90A2,$8F1E,$8DAC,$8C4B,$8AFC,$89BF
dc.w	$8895,$877C,$8677,$8584,$84A4,$83D7,$831D,$8277
dc.w	$81E3,$8164,$80F7,$809F,$805A,$8028,$800B,$8001
dc.w	$800B,$8028,$805A,$809F,$80F7,$8164,$81E3,$8277
dc.w	$831D,$83D7,$84A4,$8584,$8677,$877C,$8895,$89BF
dc.w	$8AFC,$8C4B,$8DAC,$8F1E,$90A2,$9237,$93DD,$9593
dc.w	$975A,$9931,$9B18,$9D0F,$9F15,$A129,$A34D,$A57E
dc.w	$A7BE,$AA0B,$AC65,$AECD,$B141,$B3C1,$B64C,$B8E4
dc.w    $BB86,$BE32,$C0E9,$C3AA,$C674,$C946,$CC21,$CF05
dc.w    $D1EF,$D4E1,$D7DA,$DAD8,$DDDD,$E0E6,$E3F5,$E707
dc.w    $EA1E,$ED38,$F055,$F374,$F696,$F9B8,$FCDC,2,$66E8
dc.w    0,$240,0,0,0,0

An introduction by Asterix of Movement
==========================================

Written by Carl-Henrik Skårstedt during his holidays.

_ _
/| |\
/|\ / \
| / \
|/_______\
/


1. Preface
=============

To understand this text, it would be good to know basic linear algebra,
 because when reading this text, you should also be able to
understand what you are doing, not just convert given formulas into
680x0 code. If you know the theory behind your routine, you will also know how to
optimise or modify it!

This text is useful not only for programming 3D graphics on Amiga, but on all
computers that support a good graphics interface, fast enough to
make concave objects in a frame (not the PC).

sqr() means SQUARE ROOT in this text.

The meaning of this text is that it will be part of
As Code.txt and that the same rules apply to this
text as to that one.
The rights to this part remain with the author.
Source codes should work with most assemblers except for
Insert Ordering, which needs a 68020 assembler.

*******************************************************************************

2. Introduzione ai vettori
==========================

Cosa è un vettore?
-----------------
If you have seen the demos, those spinning cubes are called vectors.
They can be balls, filled polygons, lines, or other things.
The thing these demos have in common is the vector calculations of the positions
of the objects. It can be in one, two, or three dimensions.

For example, let's take a cube. Each corner on the cube
represents a vector at the centre of rotation.
All vectors go from somewhere to somewhere else. Normally, we use
vectors that go from a point (0,0) to a point (a,b).
This vector has a magnitude (a,b).

Definition of a vector:
A quantity of value and direction

or, in simple terms: a line.
A line has a length that we can call r, and a direction that
we can call t.
We can write this vector (r,t) = (length, angle).
But there is also another way, which is more commonly used for vector objects with
given coordinates.

The line from (0,0) to (x,y) has length sqr(x*x+y*y), and this is the Value
of the vector.
The direction can be seen as the angle between the x-axis and the line described
by the vector.

If we study this in two dimensions, we can have an example vector
like the following:

^ y
| _.(a,b)
| /|
| /
| /
| / V
| /
|/\ - t=angle between x-axis and vector V
---+------------>
(0,0) x


We can call this vector V, and, as we can see, it goes from
point (0,0) to (a,b).
We can denote this vector as V=(a,b).
Now we have both a value for V (the length between (0,0) and (a,b)) and its
direction (the angle in the diagram)

If we look at the diagram, we can see that the length of the vector can
be calculated using Pythagoras' theorem:

r=sqr(a*a+b*b)

And t is the angle (it can be calculated with t=tan(y/x))


Three dimensions?
-----------------
Now that we have seen what a vector is in two dimensions, what is a vector
in three dimensions?

In three dimensions, each point has three coordinates, so the vector must also
have three coordinates.

V=(a,b,c)

Now the length of the vector becomes:

r=sqr(a*a+b*b+c*c)

What happens to the angle now?

Here we can have different definitions, but let's think about it for a moment.
If we start by giving ONE angle, we can only reach a point on a PLANE,
but we want to take a direction in Space.

If we try with TWO angles, we will get a better result.
One angle can represent the angle between the Z axis and the vector, the other the
rotation AROUND the Z axis.

For other problems in this field (there are many), study the calculation of
multiple variables and, in particular, polar transformations in triple integrals,
or at least surface integrals in vector fields.

*******************************************************************************

2.1 Vector operations:
=========================

(If you have two, or one dimension, you have two or one variable instead of three.
If you have more, you naturally have as many variables as there are dimensions)

* The SUM of two vectors (U=V+W) is defined as:

V=(vx,vy,vz), W=(wx,wy,wz)=>

=> U=(vx+wx,vy+wy,vz+wz)

* The negation of a vector U=-V is defined as:

V=(x,y,z) => U=(-x,-y,-z)

* The difference between two vectors U=V-W is defined as:

U=V+(-W)

* A vector between two points (From P1(x1,y1,z1) To P2(x2,y2,z2))
can be calculated:

V=(x2-x1,y2-y1,z2-z1,...)

(V goes from P1 to P2)

* A vector can be multiplied by a constant:

U=k*V

(x*k,y*k,z*k)=k*(x,y,z)

* A coordinate system can be ‘translated’ to a new point using the
translation formula:

x'=x-k
y'=y-l
z'=z-m

Where (k,l,m) is the OLD point where the NEW coordinate system should
have its point (0,0,0)
This is a good operation if you want to rotate around a NEW POINT!

* A vector can be rotated (see Chapter 4)
The vector is always rotated around the point (0,0,0) so you can translate it.

* We can do a scalar product and a cross product on vectors
(see any book on the introduction to linear algebra)

*******************************************************************************

3. PROGRAMMING techniques
====================

******************************************************************************

A way to use real numbers with integers
----------------------------------------------

So far we have only seen several formulas, but how can we use them in
Assembler, where we only have bytes/words/longwords?
(Unless you have an FPU, and you don't want only people with FPU to see
your demo, of course!)

For 68000 programming (compatible with all 680x0 processors), it is
useful to be able to perform multiplication, division, etc. with WORDS.
(68020+ processors can also do this with longwords)

But we also need the FRACTIONAL parts, i.e. the numbers “after the decimal point”, but how do we do this if there is no decimal point?
We can try using numbers that are multiplied by a constant p.
Then we can do the following operation:

[cos(a)*p] * 75 (for example, from a list with cos(x) multiplied by p)

But as you can see, this number grows every time we do another
multiplication, so we have to divide it by p again:

[cos(a)*p] * 75 / p

If you are an expert coder, you will surely say: ‘Oh no! Not a division, that
takes a lot of time!’
But if you choose p carefully (i.e. p = 2 or 4 or 8 ...) you can use SHIFT
instead of division! Look at this example:

mulu.w    10(a0),d0    ; 10(a0) is from a list of values cos*256
asr.l    #8,d0		; and we ‘divide’ by 256!

Now we have multiplied a fixed-point number!
(A trick to get a smaller margin of error:
clear a Dx data register and use an addx after the asr, and you will get a
“rounded”, ‘smoothed’ (round-off) error:

moveq    #0,d7		; We reset the d7 register
:
:
mulu.w    10(a0),d0    ; we take the value from the table (cos*256)
asr.l    #8,d0        ; we ‘divide’ by 256
addx.l    d7,d0        ; we round using only the eXtend flag (d7=0)
:
rts

This halves the error!

The same system can be used for divisions, but in the opposite way:

:
ext.l    d0
ext.l    d1
asl.l    #8,d0        ;‘Multiply’ by 256
divs.w    d1,d0        ; and divide by z*256 ...
:
rts

Additions and subtractions are the same as for normal integer operations
: (no shift needed)

:
add.w    10(a0),d0
:

:
sub.w    16(a1),d1
:


So, with multiplications, MUL first, then LSR.
With divisions, LSL first, then DIV.

If you want higher accuracy with multiplications, the
68020 and higher processors offer an inexpensive way to do floating point
operations (32-bit total).
You can also do 32*32->32 integer multiplications, and use 16-bit cosines and sines,
 which allow you to use “SWAP” instead of “LSR”.

*******************************************************************************

How can I use Sin and Cos in my assembler code?
---------------------------------------------------
The easiest and fastest way is to include a sinus list, more commonly called
SINUS TAB, in the listing.
Write a program that counts from 0 to 2*pi, for example 1024 times.
Save the values and include them in the code.

If you have WORDS and 1024 different sine values, then you can get SINE and
COSINE like this:

lea    sinuslist(pc),a0    ; list (table) of already calculated sine values
and.w    #$7fe,d0        ; d0 is the angle (exclude odd numbers)
move.w    (a0,d0.w),d1 ; d1=sin(d0)
add.w    #(1024/4)*2,d0        ; add 90° (1/4 of a full angle)
; to find the sine. *2 because there are
; words to reach in the table.
and.w    #$7fe,d0
move.w    (a0,d0.w),d0        ; d0=cos (original d0)
:
:

To create the table, you can use the handy ‘IS’ or ‘CS’ command in ASMONE,
or you can calculate it with math libraries or other languages:

pi=3.141592654
vals=1024

with a cycle that always increases L from 0 to 1024:

angle = L/vals*2*pi

You can, of course, write a program that calculates SINE in assembler code,
using the ieee libraries or programming your own floating point routine
the algorithm is... (for sine)

input: v=angle (given in radians)
Laps=number of terms (less=faster, but more errors, integer)

1> Mlop=1
DFac=1
Ang2=angle*angle
Talj=angle
sign=1
Result=0
2> FOR terms=1 TO Laps
2.1> Temp=Talj/Dfac
2.2> Result=sign*(Result+Temp)
2.3> Talj=Talj*Ang2
2.4> Mlop=Mlop+1
2.5> Dfac=Dfac*Mlop
2.6> sign=-sign
3> RETURN sin()=Result

where sin() is between -1 and 1...
The algorithm uses MacLaurin polynomials, and is therefore only recommended for
values that are not very far from 0.

4. Rotation of vectors
==========================

* In two dimensions

Now we know what a vector is, and we want to rotate it.
This is very simple if we have a vector with a given length and angle.
we simply add the angle of rotation to the angle and leave the
length as it is:

rotate V=(r,t) by -> V'=(r,t+a)

But normally we do not have this simple case, we have a vector given by
two coordinates:

V=(x,y) where x and y are coordinates in the xy plane

In this text we highlight the rotation of a vector V=(r,t) with
rot(V,a).
By this I mean the rotation of the vector V by the angle a.

The rotation of this vector can be done by transforming V into a vector
of length and direction, but since this involves squares, tangents,
square roots, etc., it would be better to use a faster method.
This is where trigonometry comes in.

But first, let's imagine we have a vector V=(x,0)
What could be the rotation of this vector?

V
----------->

Now, let's rotate it by an angle a:

_
/|\y' /|
| /
|V'/
| /
|/\a x'
----->

What are the new components of the vector? (x',y') ?

Remember these “definitions”:

Cosine:
hypotenuse/side closest to the angle

Sine:
hypotenuse/side not closest to the angle

,
/|
Length>/ |< Length * sin(a)
/a |
“---+
Length * cos(a)


If we put this into the original rotation formula (V”=rot(V,a)=V(r,t+a))
we can see that we can convert r and t into x and y with:

x=r*cos(t)
y=r*sin(t)

Let's go back to the problem of the rotated vector V=(x,0).
Here, r=x (=sqrt(x*x+0*0)), t=0 (=arctan(0/x)
If we put this into our formula, we have:

V=(r,t) if r=x, t=0

If we rotate this vector by angle a, we have:

V=(r,t+a)

And if we translate back to our indicated coordinate:

V=(r*cos(t+a),r*sin(t+a))=(x*cos(a),x*sin(a))
^Let's insert x=r, t=0

And this is the formula for rotating a vector that has no Y component.

For a vector V=(0,y) we have:


r=y, t=pi/2 (=90 degrees) because we are now on the y-axis, which is at 90
degrees from the X-axis.


V=(r,t) => V'=(r,t+a) => V'=(r*cos(t+a),r*sin(t+a)) =>
V'=(y*cos(pi/2+a),y*sin(pi/2+a))

Now, there are a few trigonometric formulas that say that:

cos(pi/2+a)=sin(a) and sin(pi/2+a)=-cos(a)

So we have:

V'=( y * sin(a) , y * ( -cos(a) ) )


But if we look at the general case, we have a vector V that has both
x and y components.
Now we can use the rotation formulas for individual cases to calculate the
general case with an addition:


Vx'=rot((x,0),a) = (x*cos(a) ,x*sin(a))
+ Vy'=rot((0,y),a) = ( +y*sin(a), -y*cos(a))
----------------------------------------------------------
V' =rot((x,y),a) = (x*cos(a)+y*sin(a),x*sin(a)-y*cos(a))


(Vx' means rotation of V=(x,0) and Vy' is rotation of V=(0,y))
And we have the rotation of a given vector in coordinates!

*****************************************************************************
FORMULA FINALE DI ROTAZIONE IN DUE DIMENSIONI
*****************************************************************************

...
 rot( (x,y), a)=( x*cos(a)+y*sin(a) , x*sin(a)-y*cos(a) )
X component ^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^ Y component

*****************************************************************************

* Three dimensions

In the case of two dimensions, we rotated the x and y coordinates, and we do not
see any change in the z coordinate.
Therefore, we call this a rotation around the Z axis.

Now, the easiest thing to do in three dimensions is to do the same thing again,
 simply rotating around any axis to obtain the new
coordinate.
Leave out the variable representing the coordinate of the current axis
of rotation, and you can use the same expression.

If you only want to rotate one or two coordinates, you can use the normal rotation method
because you don't need to calculate a 3x3 transformation matrix.
But if you have more points, I recommend the optimised version.

There are optimisations in this field, but let's first look at at least one way to
rotate a vector with 3 given angles:

*******************************************************************************
NORMAL METHOD OF ROTATING A VECTOR WITH 3 GIVEN ANGLES IN 3D:
*******************************************************************************

Assume that we want to rotate V=(x,y,z) around the Z axis by angle a,
around y by b and around x by c.

The first rotation we do is around the Z axis:

U=(x,y) (x,y from V-vector) =>
=> U'=rot(U,a)=rot((x,y),a)=(x',y')

Now we want to rotate around the Y axis:

W=(x',z) (x' is from U' and z is from V) =>
=> W'=rot(W,b)=rot((x',z),b)=(x'“,z”)

And finally around the X axis:

T=(y',z') (y' is from U' and z' is from W') =>
=> T'=rot(T,c)=rot((y',z'),c)=(y'“,z”')

The rotated vector V' is the coordinate vector

(x'“,y”',z'') !

With this method, we can extend the rotation command to:


V'“= rot(V,angle1,angle2,angle3) where V is the original vector!
( V”'= rot((x,y,z),angle1,angle2,angle3) )


I hope it doesn't seem too complicated.
As I said, there are optimisations of this method.
These optimisations can be made by skipping one of the rotations
seen above, or by some pre-calculation.

The ORDER is very important. You will not get the same answer if you rotate X, Y, Z by
the same angles as before.

******************************************************************************

Optimizations:
==============
For xyz vectors, we can write the equations to form the rotations:

Consider:
c1=cos(angle1)
c2=cos(angle2)
c3=cos(angle3)
s1=sin(angle1)
s2=sin(angle2)
s3=sin(angle3)

(x*cos(a)+y*sin(a),x*sin(a)-y*cos(a))

x' = x*c1+y*s1
y' = x*s1-y*c1

x'“= x”*c2+z*s2     <- Rotated X coordinate
z' = x'*s2-z*c2

y'“= y”*c3+z'*s3 <- Rotated Y coordinate
z'“= y”*s3-z'*c3 <- Rotated Z coordinate

which gives:

x'“= (x*c1+y*s1)*c2+z*s2= c2*c1 *x + c2*s1 *y + s2 *z
^^^^^^^^^^^=x” ^^^^^ xx ^^^^^ xy ^^ xz

y''= (x*s1-y*c1)*c3+((x*c1+y*s1)*s2-z*c2)*s3=
c3*s1 *x - c3*c1 *y + s3*s2*c1 *x + s3*s2*s1 *y - s3*c2 *z=

(s3*s2*c1+c3*s1) *x + (s3*s2*s1-c3*c1) *y + (-s3*c2) *z
^^^^^^^^^^^^^^^^ yx ^^^^^^^^^^^^^^^^ yy ^^^^^^^^ yz

z''= (x*s1-y*c1)*s3-((x*c1+y*s1)*s2-z*c2)*c3=
s3*s1 *x - s3*c1 *y - c3*s2*c1 *x - c3*s2*s1 *y + c3*c2 *z=

(-c3*s2*c1+s3*s1) *x + (-c3*s2*s1-c3*c1) *y + (c3*c2) *z
^^^^^^^^^^^^^^^^^ zx ^^^^^^^^^^^^^^^^^ zy ^^^^^^^ zz


Now, look at the characteristic, the structure of the solutions:
for x'“ we calculated the original (x,y,z) multiplied by some number,
the same for y”' and z'', What is the connection?

Let's take the example of having to rotate many given vectors with three angles that are
the same for all vectors, then we will have this multiplication scheme.
When you rotated as above, you had to use twelve multiplications to make
one rotation, but now let's precalculate these “constants” to get down
to only nine multiplications!
^^^^

*******************************************************************************
FORMULA FINALE DI ROTAZIONE IN 3 DIMENSIONI CON 3 ANGOLI:
*******************************************************************************

x,y,z is the original coordinate (x,y,z).

c1=cos(angle1)
c2=cos(angle2)
c3=cos(angle3)
s1=sin(angle1)
s2=sin(angle2)
s3=sin(angle3)

If you want to rotate several coordinates by the same angles, you must first
calculate these values:

xx=c2*c1
xy=c2*s1
xz=s2
yx=c3*s1+s3*s2*c1
yy=-c3*c1+s3*s2*s1
yz=-s3*c2
zx=s3*s1-c3*s2*c1;s2*c1+c3*s1
zy=-s3*c1-c3*s2*s1;c3*c1-s2*s1
zz=c3*c2

Then, for each coordinate, you must use the following multiplication to
obtain the rotated coordinates:

x'“=xx * x + xy * y + xz * z
y”'=yx * x + yy * y + yz * z
z''=zx * x + zy * y + zz * z

This way, you only need to calculate the constants once for each new angle, and THEN
you just need to use NINE multiplications for each point you want to rotate to obtain
the new set of points.

See the end of this text for an example of how this can be
implemented in 68000 assembler.

If you want to skip an angle, you can optimise further.
If you want to remove angle 3, set c3=1 and s3=0.
Put them in the constant calculation and it will be optimised as you want.

Which method to use depends, of course, on how much you want to program,
but personally I prefer the optimised version, because you can
be more proud of it.
If you only want to rotate a few points with the same angles, the first version
(unoptimised) might be the choice.

If you wish, you can check whether the transformation matrix has
a determinant equal to 1.

*******************************************************************************

5. Polygons!
============

The word “polygon” means many angles, which also means that it has
several points (angles) with lines drawn between them.
If we have, for example, 5 points, we can draw lines:
from point 1 to point 2
from point 2 to point 3
from point 3 to point 4
from point 4 to point 5
And if we want a CLOSED polygon, we must also draw a line
from point 5 to point 1

Points: 2
.

.3
1
.
5..4

OPEN polygon consisting of the points shown above:


/|
/ |
/ /
/ /
_/


CLOSED polygon consisting of the points shown above:

/|
/ |
/ /
/ /
\_/


‘Filled vectors’ are created by drawing polygons
and filling their interior.
The following algorithm is normally used:

First, we define all the ‘angles’ on the polygon as vectors, which allows us
to rotate it and draw it in the new angles after rotation. then we draw
a line from point 1 to point 2, and so on.
The last line is from point 5 to point 1.
When we are finished, we use a BLITTER-FILL to fill the area.

We will need a special line drawing routine to
draw these lines so that the BLITTER-FILL works properly.
There is an example of a routine suitable for this task in the appendix to the text.
Further theory about the requirements of the line DRAW routine
will be discussed later (Appendix B 2).


Creating objects from polygons
===============================

An ‘object’ is a three-dimensional thing created with polygons.
But what happens to the surfaces that are on the other side of the object?
If there are hidden parts in the object, what can we do?

Let's start with a cube, which is easy to imagine.
We can see that no part of the cube is above another, as seen by the observer
(unlike, for example, a torus).
Some areas are naturally outside the visible range, but we can
calculate which direction the polygon is facing (towards the observer or
hidden behind).

We need to define polygons in objects in the same direction
(clockwise or counterclockwise) throughout the object. It does not matter which point you start with,
the order is important.

Take three points from a plane (point 1, point 2 and point 3).
If all three points are not equal to any of the other points,
these points define a plane.
Then you only need 3 points to define the direction of the plane.
Examine the following calculation:

c=(x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)

(This is after the 3D->2D projection, so there is no Z coordinate.
If you want to know how this works, see Appendix B.)

This formula requires three points, which is the minimum number of coordinates
needed to define a polygon that is not a line or a point.
This involves two multiplications per plane, but it's not much compared
to rotation and 3D->2D projection.

But let's see what this equation gives us:

If c is negative, the normal vector of the plane determined by the three points
is ‘directed’ towards the observer ( = The plane is in front of the observer =>
the plane should be drawn )...

If c is positive, the normal vector of the plane is “directed” away from the observer
( = The plane cannot be seen by the observer =>
Do not draw the plane) ...

But for objects whose parts cover other parts
of the object itself, a distinction must be made between concave and convex.

Convex and concave objects
===========================

‘Definitions’

A convex object has no parts that cover other parts of the
same object when viewed from all angles.

A concave object has parts that cover other parts of the same object
when viewed from some angles.


For convex objects, you can draw a straight line from any point
inside the object to any other point on the object without any line
passing outside the ‘domain’ of the object.

With a CONVEX object, you can draw all the lines around
the visible planes and then fill with the blitter, because no polygon
you draw will ever cover another polygon.
With a few tricks, you can also find a way to omit some lines,
if they are drawn twice.

CONCAVE objects pose additional problems. The easiest way to use
CONCAVE objects is to divide them into smaller CONVEX objects.
This works for all objects, although you may encounter some problems
doing so.

Of course, you can skip several planes that will be ‘inside’
the concave object.

Once you have divided the object, simply draw each convex object in
a temporary memory buffer and treat these objects as
VECTORBALLS, with SORTING (Sorting) routines that find which parts
are in front of the others.

The Z coordinate can be taken from the average of all Z values in the object
(i.e., the sum of all Z values in the object divided by the number of
coordinates).

When sorting objects, there may be problems with
concave parts of the object being selected in the wrong order,
because a random point OUTSIDE the convex object has been taken, which
the current object is sharing with another convex object.
One way to solve this problem is to take a midpoint that is
in the convex object, adding all the Z values around the object and
dividing by the number of coordinates added.
In this case, points should be taken from at least two planes in the object.

Object Optimisation
============================

Let's assume we have a CONVEX object.
If it is closed, you have almost as few points as you have planes.
(If it is closed, we have as few points as there are planes???)
If we have a list containing every existing coordinate (no points should
be repeated), this shows for each polygon which points need to be taken
for this coordinate, and we can greatly reduce the number of rotations.

For example:

/* A cube */
/* The order is important! Here it is clockwise */

end_plane=0

pointlist:

dc.l    pt4,pt3,pt2,pt1,end_plane
dc.l    pt5,pt6,pt2,pt1,end_plane
dc.l    pt6,pt7,pt3,pt2,end_plane
dc.l    pt7,pt8,pt4,pt3,end_plane
dc.l    pt8,pt5,pt1,pt4,end_plane
dc.l    pt5,pt6,pt7,pt8,end_plane

pt1:    dc.w -1,-1,-1
pt2:    dc.w 1,-1,-1
pt3:    dc.w 1,-1,1
pt4:    dc.w -1,-1,1
pt5:    dc.w -1,1,-1
pt6:    dc.w 1,1,-1
pt7:    dc.w 1,1,1
pt8:    dc.w -1,1,1

Now, just rotate points pt1-pt8, which are eight points.
If we had processed four points for each plane, we would have had to calculate
24 rotations!

6. planes in three dimensions
=============================

Lightsourcing
--------------------------------

Lightsourcing is a way to find out how much light a plane receives from either a
point light (spherical) or a plane light (planar). If the colour of the plane
represents the light falling on it, the object will look a little more realistic.

What we are interested in is the angle of the vector from the normal of the plane to the
LIGHTSOURCE (=light point).
(This is for a spherical light source, such as a lamp.)
For planar lighting, such as that of the sun, we need the angle between the
normal of the plane and the vector of the LIGHTSOURCE.

We need the cosine of the given angle.

However, to obtain the normal of the plane, we can take three points in the
polygon and create two vectors from them.

Example:

* Let's take (x1,y1,z1) , (x2,y2,z2) and (x3,y3,z3)

Let's create two vectors V1 and V2:

V1=(x2-x1,y2-y1,z2-z1)
V2=(x3-x1,y3-y1,z3-z1)

To obtain the normal of these vectors, we take their cross product:

| i j k |
N = V1xV2 = |x2-x1 y2-y1 z2-z1| =
|x3-x1 y3-y1 z3-z1|

n1 n2
* = ((y2-y1)*(z3-z1)-(y3-y1)*(z2-z1),-((x2-x1)*(z3-z1)-(x3-x1)*(z2-z1)),
* ,(x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))
n3

Now we have N. We also have the coordinates of the LIGHTSOURCE (given).

To find the COS of the angle between two vectors, we can use the scalar product
between N and L (=lightsource vector) divided by the length of N and L:

<N,L>/(||N||*||L||) =

* (n1*l1+n2*l2+n3*l3)/(sqr(n1*n1+n2*n2+n3*n3)*sqr(l1*l1+l2*l2+l3*l3))
|
* (can be (n1*l1+n2*l2+n3*l3)/k if k is a precalculated constant)

If you don't understand something, look at the formulas with an “*” in the margin.
n1 means ‘X coordinate of N’, n2 ‘Y coordinate’ and so on, and the
same applies to L.

This number is between -1 and 1 and is the COS of the angle between vectors L and N.
Square roots are very time-consuming, but if we keep the object intact
(by only performing rotations/translations, etc.) and always take the same points
in the object, then ||N|| is intact and can be precalculated.

If we ascertain that the length of L is always 1, there will be no need to divide, and
this saves many cycles.

The number can, as mentioned, be between -1 and 1. You will need to multiply the
number by something before dividing so that you have a wider range
of colours to choose from for the “shade” of the face.
If the number is negative, you need to reset it to zero.

The number may be negative when it should be positive, because
you took the points in the wrong order, but then you just need to negate the result.

Special Techniques - Sorting Algorithms
=======================================================

When sorting is required, we usually start with ‘Bubble Sorting’, which
is rather slow, although easy to understand.
It is better to use ‘Insert Sorting’ or ‘Quick Sorting’, or other faster methods
.

Method 1) Bubble Sorting
-------------------------

Let's assume we have a list of Values associated with Weights (of metal!).
The heaviest weights must fall to the bottom, taking the Values with them.
The values in this case can be the x¹ and y¹ coordinates or other
things, such as the bob of vectorballs.
The Weights can be the Z coordinates before projection.

We start with the first two elements, checking which element is the heaviest
‘heavy’, and if it is ABOVE the ‘lightest’ element, moving all the data
associated with the Weight and the Weight itself to the place of the ‘lightest’ element,
and consequently putting the data of the “light” element where those
of the ‘heavy’ element were.
This procedure is called a “swap” operation.

Then go down one element and check elements 2 and 3...
Repeat these steps until you reach the bottom of the list.

However, the first cycle will not perform the “final” sorting. you will need to
sort the list the same number of times as there are objects -1!
So, if there are 30 objects, you need to do 29 loops like the one described.

A slightly “smarter” version is one where each time
a swap occurs, a flag is set, so that if the list has been sorted
before completing all the loops, the routine stops.
If the list were: 2,1,3,4,5,6,7,8,9,10, only 1 loop would be needed to
sort it, not 9!

Here is an example of this algorithm, which sorts a table of words from
smallest to largest:

Bubble:
lea    Positions(PC),a0 ; List of words to sort
moveq    #0,d0        ; reset d0 (swap flag)
Loop:
move.w    (a0),d1        ; element 1
cmp.w    2(a0),d1    ; element 2
ble.s    NoSwap        ; is element 2 smaller than element 1? If yes, OK
move.w    2(a0),(a0)	; otherwise swap the elements
move.w    d1,2(a0)
st    d0        ; and mark that we have swapped
NoSwap:
addq.w    #2,a0        ; next comparison
cmp.l    #EndPos-2,a0    ; Are we at the end?
bcs.s    Loop        ; If not, finish the ‘round’
tst.w    d0        ; Are we done with the swaps?
bne.s    Bubble        ; If not, give it another go
rts

Positions:
dc.w    8,3,4,5,6,7,8,1,-1,2,6
EndPos:

Method 2) Insert sorting
-------------------------

Let's consider the same Values and Weights as before.
For this system, you need to select a length (byte, word, long)
for each sorting table (sorting-table or checklist)
and a size for the checklist.
The wordlength depends on the number of entries you have, and the size of each entry.

The word length depends on the number of entries you have
and the size of each entry. Normally, it is convenient
to use words. The size of the checklist is the range
of Z-values to be sorted, or transformed Z-values.
If, for example, you know that your Z-values are within
512-1023, you can first decrease each Z-value by 512,
and then lsr' it once, which will give you a checklist size
of 256 words.
You will also need a second buffer to put your sorted
data in. This 2ndBUF will be like a copy of the original
list but with the entries sorted.

For this method, I will only present an algorithm, as it is
easier to see how it works than from some
strange text.

checklist(x) is the x'th word in the checklist.

Algorithm:
1> Clear the checklist (set all words to 0)
2> Transform all weights if necessary.
3> For L=0 To the number of items
3.1> Add ENTRYSIZE To checklist(transformed weight)
4> For L=0 To checklist size-1
4.1> Add checklist(L),checklist(L+1)
5> For L=0 To the number of items
5.1> Put Entry in 2ndBUF(checklist(transformed weight))
5.2> Add ENTRYSIZE to checklist(transformed weight)

Now, your data is nicely sorted in the 2ndBUF list, the
original list is left as it was (except for Z-transformation).
(ENTRYSIZE is the size of the entry, so if you have x, y, z coordinates
in words, your size is 3 words = 6 bytes.)
Also try to think a little about what you are taking when you
transform. Subtraction is useful as long as it minimises
loops, but lsr-ing the weights takes time and makes the
result worse. Of course, you don't have to examine the list every time,
just make sure you know what the lowest possible and
highest possible weight is.


Method 3) Quick Sort
------------------------
This is another type of sorting, and it is more efficient
____ Use pointers, so that each entry has a pointer to the next entry.

You can store an entry like this:

Next Offset=word
x,y,z=coordinates.

(offsets are from the starting address of the sortlist...)

To access this routine, you will need to give a first entry
and number of entries. In the original implementation, the first entry
is naturally 0 (=first entry) and the number of entries is
naturally the total number of entries.
You must assign all previous/next pointers to link a chain.

Quicksort is recursive, which means that you will need to
call the routine from within itself. This is not
at all complicated, you just need to put some of your
old variables on the stack for safe-keeping.

What it does is this:
+> The first entry in the list is the PIVOT Entry.
| For each of the other entries, we put it either before or after
| the PIVOT. If it is lighter than the PIVOT, we put it before,
| otherwise we put it After.
| Now we have two new lists, All entries Before the PIVOT,
| and all entries After the PIVOT (but not the pivot itself,
| which is already sorted).
| Now we quicksort All entries Before the pivot separately
+< and then we quicksort all entries After the pivot.
(We do this by calling the routine we are already in)
This can cause problems with the stack if there are too
many things to sort.

The recursion loop is broken when there is <=1 entry
to sort.

Contrary to some people's beliefs, you don't need any extra
lists to solve this.

Algorithm:

Inparameters: (PivotEntry=first element of list
List size=current list size)
1> If list size <= 1 then exit
2> PivotWeight=Weight(PivotEntry)
3> for l=2nd Entry ____ list size-1
3.1> if weight(l) > PivotWeight
3.1.1> insert entry into list 1
3.2> Otherwise
3.2.1> insert entry into list 2
4> Sort list 1 (bsr quicksort(first entry in list 1, list size 1))
5> Sort list 1 (bsr quicksort(first entry in list 2, size of list 2))
6> Link list 1 -> PivotEntry -> list 2

(PivotEntry = FirstEntry, it doesn't have to look like this, but I prefer
it as I find it easier.)



Special techniques - Vector balls
=================================
Vector balls are simple. Just calculate where the
balls are (with rotations, translations or whatever
they may be). Sometimes you also calculate the size
of the ball and so on.

You don't have to have balls. You can have the convex parts
of a filled concave object, or you can
have images of whatever you like. In three dimensions
you will have the problem with images (balls or whatever)
that should be in front of others because they are
further away from you. This is where sorting
comes in. If you start blitting the image that
is furthest away from you, and move closer for
each object, you get a 3D-like screen.
The closest image will be the closest.

Normally, you start by clearing the screen you're not
showing at the moment (parts of it anyway. A person
in Silents only cleared every second line...).

Then (while the blitter is working you start rotating,
sorting and preparing to finally bob the images out

and when you have checked that the blitter is
finished, you start bobbing out all the images,
and when the frame is displayed, you swap
screens so you show your finished screen
the next frame.






Appendix A: Example sources.

1 Optimised rotation matrix calculation
2 A line drawing routine for filled vectors
3 Quicksort in 68000 assembler
4 Insert Sort in 68020 assembler


Optimised rotation matrix calculation

1. An example of an optimised rotation matrix calculation
============================================================

* For this routine, you need a sine table of 1024 values,
* and three words with angles and one place (9 words) ____ to store
* the transformation matrix.
* __ .
* /( |( )|\/ '(|)
* / )|(|\|/\ |)

Calculate_Constants

lea Cores_Sines(pc),a0
lea Angles(pc),a2
lea Sintab(pc),a1

move.w (a2),d0
e.w #$7fe,d0
move.w (a1,d0.w),(a0)
add.w #$200,d0
e.w #$7fe,d0
move.w (a1,d0.w),2(a0)
move.w 2(a2),d0
e.w #$7fe,d0
move.w (a1,d0.w),4(a0)
add.w #$200,d0
e.w #7fe,d0
move.w (a1,d0.w),6(a0)
move.w 4(a2),d0
e.w #$7fe,d0
move.w (a1,d0.w),8(a0)
add.w #$200,d0
e.w #$7fe,d0
move.w (a1,d0.w),10(a0)

;xx=c2*c1
;xy=c2*s1
;xz=s2
;yx=c3*s1+s3*s2*c1
;yy=-c3*c1+s3*s2*s1
;yz=-s3*c2
;zx=s3*s1-c3*s2*c1;s2*c1+c3*s1
;zy=-s3*c1-c3*s2*s1;c3*c1-s2*s1
;zz=c3*c2

lea Constants(pc),a1
muovere.w 6(a0),d0
muovere.w (a0),d1
move.w d1,d2
muls d0,d1
asr.l #8,d1
move.w 2(a0),d3
muls d3,d0
asr.l #8,d0
move.w d0,(a1)
;neg.w d1
move.w d1,2(a1)
move.w 4(a0),4(a1)
move.w 8(a0),d4
move.w d4,d6
muls 4(a0),d4
asr.l #8,d4
move.w d4,d5
muls d2,d5
muls 10(a0),d2
muls d3,d4
muls 10(a0),d3
add.l d4,d2
sub.l d5,d3
asr.l #8,d2
asr.l #8,d3
move.w d2,6(a1)
neg.w d3
move.w d3,8(a1)
muls 6(a0),d6
asr.l #8,d6
neg.w d6
move.w d6,10(a1)
move.w 10(a0),d0
move.w d0,d4
muls 4(a0),d0
asr.l #8,d0
move.w d0,d1
move.w 8(a0),d2
move.w d2,d3
muls (a0),d0
muls 2(a0),d1
muls (a0),d2
muls 2(a0),d3
sub.l d1,d2
asr.l #8,d2
move.w d2,12(a1)
add.l d0,d3
asr.l #8,d3
neg.w d3
move.w d3,14(a1)
muls 6(a0),d4
asr.l #8,d4
move.w d4,16(a1)

rts

Coses_Sines dc.w 0,0,0,0,0,0
Angles dc.w 0,0,0
Constants dc.w 0,0,0,0,0,0,0,0,0

;Sintab is a table of 1024 sine values with a radius of 256
;which I have further down in my code...




A line drawing routine for filled vectors

A 2. A line drawing routine for filled vectors in assembler:
============================================================

* written for kuma-seka ages ago, works great and
* can be optimised for special cases...
* the line is (x0,y0)-(x1,y1) = (d0,d1)-(d2,d3) ...
* Remember that you must have DFF000 in a6 and
* the starting address of the screen in a0.
* Only a1-a7 and d7 are left unchanged.
* __ .
* /( |( )|\/ '(|)
* / )|(|\|/\ |)

Screen_width=40 ;40 byte wide screen...
fill_lines: ;(a6=$dff000, a0=bitplane start ____ draw in)

cmp.w d1,d3
beq.s noline
ble.s lin1
exg d1,d3
exg d0,d2
lin1: sub.w d2,d0
move.w d2,d5
asr.w #3,d2
ext.l d2
sub.w d3,d1
muls #Screen_Width,d3 ;can be optimised here..
add.l d2,d3
add.l d3,a0
e.w #$f,d5
move.w d5,d2
eor.b #$f,d5
ror.w #4,d2
o.w #$0b4a,d2
swap d2
tst.w d0
bmi.s lin2
cmp.w d0,d1
ble.s lin3
move.w #$41,d2
exg d1,d0
bra.s lin6
lin3: move.w #$51,d2
bra.s lin6
lin2: neg.w d0
cmp.w d0,d1
ble.s lin4
move.w #$49,d2
exg d1,d0
bra.s lin6
lin4: move.w #$55,d2
lin6: asl.w #1,d1
move.w d1,d4
move.w d1,d3
sub.w d0,d3
ble.s lin5
e.w #$ffbf,d2
lin5: move.w d3,d1
sub.w d0,d3
o.w #2,d2
lsl.w #6,d0
add.w #$42,d0
bltwt: btst #6,2(a6)
bne.s bltwt
bchg d5,(a0)
move.l d2,$40(a6)
move.l #-1,$44(a6)
move.l a0,$48(a6)
move.w d1,$52(a6)
move.l a0,$54(a6)
move.w #Screen_Width,$60(a6) ;width
move.w d4,$62(a6)
move.w d3,$64(a6)
move.w #Screen_Width,$66(a6) ;width
move.l #-$8000,$72(a6)
move.w d0,$58(a6)
noline: rts




Quicksort in 68000 assembler

A 3. Quicksort in 68000 assembler
=====================================

* Sort a list that looks like:
* Next entry offset.w, (x,y,z).w.
* All offsets must be assigned except for the first entry's previous offset
* and the last entry's next offset.
* Offsets are from the first address of the list to be sorted
* a5=first address of the list to be sorted!
* __ .
* /( |( )|\/ '(|)
* / )|(|\|/\ |)


WghtOffs=6
NextOffs=0

QuickSort ;(a5=start of sortlist,
; d0=0 (pointer to first entry, first time=0)
; d1=number of entries)


cmp.w #1,d1
ble.s .NothingToSort ;do not sort if <=1 entries
moveq #0,d4 ;list size 1
moveq #0,d5 ;list size 2
move.w d0,d6 ;first Nentry=d0

move.w WghtOffs(a5,d0.w),d2 ;d2=Pivot weight
move.w NextOffs(a5,d0.w),d3 ;d3=2nd entry
subq.w #2,d1 ;Dbf-loop+skip first

Permute cmp.w WghtOffs(a5,d3.w),d2 ;entry weight<pivot weight?
ble.s .Lower

move.w d6,NextOffs(a5,d3.w) ;Insert First Nentry
addq.w #1,d4 ;increase list size 1
move.w d3,d6 ;Assign new Nentry

bra.s .Done ;Continue loop...

.Lower move.w NextOffs(a5,d0.w),NextOffs(a5,d3.w)
move.w d3,NextOffs(a5,d0.w) ;insert After first entry
addq.w #1,d5 ;list size 2

.Done move.w NextOffs(a5,d3.w),d3 ;Take next entry
dbf d1,.permute

move.w d0,-(a7) ;save Fentry..

move.w NextOffs(a5,d0.w),d0 ;Sort to entry after first
move.w d5,d1 ;List size 2

movem.w d4/d6,-(a7) ;Save important registers
bsr QuickSort ;and sort list 2
movem.w (a7)+,d4/d6 ;d1 is now First Entry...
move.w (a7)+,d1

move.w d0,NextOffs(a5,d1.w) ;Put first entry of
;list 2 after Fentry...
move.w d6,d0 ;Sort to Nentry
move.w d4,d1 ;list size 1

bsr QuickSort ;no important registers
;left...
.NothingToSort
;Now the offset to the first entry is in d0!
;____ take the other values in the correct order
;simply go down the list (using nextoffs.)
;First object is the heaviest...

rts



Insert Sort into 68020 assembler

A 4. Insert Sort into 68020 assembler:
========================================

* This is not exactly like the algorithm described above,
* it starts by creating a list and then stores the addresses of the
* sorted data in 2ndBUF instead...
* This sorts all lists, simply specify the offset ____ weight (word) and
* size of each entry. You don't need any pre-formatting.
* Note that you must change one line if you want this ____ to work
* on 68000.. I have an index scaled to one point. Replace it
* with the lines after the semicolon.
* __ .
* /( |( )|\/ '(|)
* / )|(|\|/\ |)

WghtOffs=4
EntrySize=6

InsertSort
;(a5=start of data
; a4=start of checklist
; a3=start of 2ndBUF
; d0 is the lowest value of entries
; d1 is the highest value
; d2 is the number of entries

movem.l a4/a5,-(a7)

sub.w d0,d1 ;max size of checklist for this sort.
subq.w #1,d2
subq.w #1,d1 ;Dbf-loop...

move.w d1,d3 ;clear used entries
.ClearChecklist clr.w (a4)+
dbf d3,.ClearCheckList

move.w d2,d3 ;transform...
.Transform sub.w d0,WghtOffs(a5)
addq.w #EntrySize,a5
dbf d3,.Transform

movem.l    (a7),a4/a5

move.w d2,d3 ;Insert next line instead for
.AddisList move.w WghtOffs(a5),d0 ;68000 compatibility...
addq.w #4,(a5,d0.w*2) ;add.w d0,d0 addq.w #4,(a5,d0.w)
addq.w #EntrySize,a5
dbf d3,.AddisList

moveq #-4,d0 ; #-lwdsize
.GetMemPos add.w d0,(a4)
move.w (a4)+,d0
dbf d1,.GetMemPos

movem.l (a7)+,a4/a5
.PutNewList move.w WghtOffs(a5),d0
move.w (a4,d0.w),d0
move.l a5,(a3,d0.w)
addq.w #EntrySize,a5
dbf d2,.PutNewList

;In this case you have a list of addresses for
;each object. I did it this way to
;make it more flexible (you may have more
;data in each entry than I do?).

rts



Further Information

Appendix B: Additional Information

B 1: “Test” of hidden-plane elimination equation
================================

I presented the following equation:
c=(x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)
as a calculation of the normal vector of the plane
that the polygon in question spanned.

We had three points:
p1(x1,y1)
p2(x2,y2)
p3(x3,y3)

If we select p1 as the base point, we can construct the following
vectors for the rest of the points:

V1=(x3-x1,y3-y1,p)
V2=(x2-x1,y2-y1,q)

Where p and q in the z-value indicate that we are not interested in
this value, but we must take it into account in our calculations anyway.
(These values are not the same as the original z-values
after the 2D->3D projection)


Now, we can take the normal vector of the plane that these vectors
span from a simple cross-product:

V1 x V2 =

| i j k|
= |(x3-x1) (x2-x1) p| (if i=(1,0,0), j=(0,1,0), k=(0,0,1))
|(y3-y1) (y2-y1) q| (p and q are unimportant)

But we are only interested in the Z-direction of the
result vector of this operation, which is the same as
taking only the Z-coordinate out of the cross-product:

Z of (V1xV2) = (x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)

Now if Z is positive, this means that the resulting vector
is pointing into the screen (positive z-values)
QED /Asterix

B 2. How to make a fill line out of the line blitters-drawing
==============================================================
You cannot use the line blitter-drawing as it is and
draw lines around a polygon without a few special changes.

To make a fill-line routine out of a normal-lineroutine:

First, make sure it draws lines as it should.
Many line drawers I have seen draw lines at the wrong places.
Make sure you use Exclusive or instead of or-minterm.
Always draw lines downwards (or upwards, if you prefer).
Before drawing the line and before blit-checking, eor the first
point on the screen that the line will pass through.
It will use the fill-type line mode.




B 3: An alternative approach to rotations in 3-space by M. Vissers
================================================================

/* This is text provided by Michael Vissers, and it was a bit
longer. I removed the part about projection from 3D to 2D,
which was identical to parts of my other text in Chapter 3.
If you know some basic linear algebra, this text may be
easier to understand than the longer version discussed in chapter 4.
If you don't understand how you were supposed to use the result in
chapter 4, then try this part instead. */

[ ] All you need to do is use these 3D matrices:

(A/B/G are Alpha, Beta and Gamma.) /* A, B, C = Rotation angles */

| cosA -sinA 0 | | cosB 0 -sinB | | 1 0 0 |
| sinA cosA 0 | | 0 1 0 | | 0 cosG -sing |
| 0 0 1 | | sinB 0 cosB | | 0 sing cosG |

These are the rotation matrices around the x, y and z axes. If you use these, you will get 12 muls. Four for each axis. But, if you multiply
these three matrices with each other, you will only get 9 multiplies. Why 9?
Simple: after multiplying, you will get a 3x3 matrix, and 3*3=9!

It doesn't matter if you don't know how to multiply these matrices. It's not important here, so I'll just give you the 3x3 matrix after multiplying:

(c = cos, s = sin, A/B/G are Alpha, Beta and Gamma.)

| cA*cB -cB*sA sB |
| cG*sA-sB*cA*sG cA*cG+sG*sA*sB cB*sG |
|-sG*sA-sB*cA*cG -cA*sG+sA*sB*cG cG*cB |

I hope I've written everything correctly :) OK, how can we find some
coordinates using this matrix? Again, the trick is all in the multiplication.
To find the new (x,y,x) we need the original points and multiply these by
the matrix. I'll work with a simplified matrix. (for example H = cA*cB etc...)

x y z ( <= original coordinates)
-------------
New X = | H I J |
New Y = | K L M |
New Z = | N O P |

So...

New X = x * H + y * I + z * J
New Y = x * K + y * L + z * M
New Z = x * N + y * O + z * P

Ha! That's much more than 9 muls. Well, actually no. To use the matrix
you will have to precalculate the matrix.

Always rotate with your original points and keep them somewhere else.
Simply change the angles in the table ____ rotate the shape.
If you rotate the points rotated in the previous frame, you will lose all detail
until nothing is left.

So, each frame looks like this: - Pre-calculate new matrix with
given angles.
- Calculate point with saved
matrix.
[ ]
The resulting points are relative to (0,0). So they can be negative.
Simply use an add ____ to take it to the middle of the screen.

Note: Always use muls, divs, asl, asr, etc. Data can be both positive and
negative. Also, assign the original coordinates as large as possible,
and after rotating, divide them again. This will improve the
quality of the movement.

(Michael Vissers)


B 4: A small math hint for more accurate vector calculations
=============================================================

When doing a multiply with a value and then downshifting the value, use
“addx” ____ to take roundoff error instead of truncated error, for
example:
moveq    #0,d7
DoMtxMul
:
muls    (a0),d0        ;Do a muls with a value of sin *256
asr.l    #8,d0
addx.w    d7,d0        ;roundoff < trunc
:

When you do an “asr”, the last outshifted bit goes to the x-flag.
If you use an addx with source=0 => dest=dest+“x-flag”.
This halves the error and makes complicated vector objects
less “hacky”.


/) __ .
(( /( |( )|\/ '(|)))
 / )|(|\|/\ |)
(/




3D


NB: Knowledge of lines made with the blitter, filling, cookie cut
(cookie cutting), filling, is useful for better understanding certain parts
of the lesson

INTRODUCTION:

The fundamental and synthetic form of any object we wish to 
represent on the screen is expressed as a series of x, y, z coordinates.
Each triad (the trio, vah) of coordinates corresponds to the distances from an
origin (located at coordinates 0,0,0) from the x, y, z axes.
Consequently, each trio of coordinates corresponds to a unique position
within the 3D system.
The WORLD COORDINATES (coordinates relative to the world) of an object are
simply its coordinates in this axis system.
In other words, the WORLD COORDINATES represent the world we are creating.

BASIC CONCEPTS:

There are three main stages in generating an object on the screen, once
we have the WORLD COORDINATES of the various objects:

1:    World coords (coordinates relative to the world) - True shape of an object

2:    View coords (current view coordinates) - The coordinates of the
object after any rotation or translation.

3:    Display coords (projected coordinates) - The screen coordinates
representing the object, after the 3D coordinates have been
projected (converted) perspectively from 3D to 2D (since the
monitor has 2 dimensions!).

4:    Draw the object according to the coordinates transformed into 2D.

During the lesson, objects will be considered as made up of “faces”
or “planes”. (Note that I do not mean ‘planes’ as infinite surfaces!)
So, for example, a cube has 6 faces.

These polygonal surfaces, made by connecting together groups of object coordinates,
 can be “stuck” or ‘joined’ together to form
complex objects, such as a helicopter or a cathedral (well, sort of).

A plane (face-surface) that can only be seen from one side, and is
currently hidden, is called a HIDDEN surface.
Working out which
faces are visible and which are HIDDEN is one of the
main tasks of the most complex 3D routines, those of FILLED VECTORS,
i.e. solids with ‘filled’ faces.
As a result, many methods have been invented to find hidden faces,
even specialising routines for particular types of objects.
This is, of course, in the interests of maximum speed.
However, we will start with 3D routines in WIREFRAME, which we could translate as
‘WIREFRAME’, in which the solid is made up of lines only, so even the hidden lines are visible.
 However, this makes things easier to start with.

MANIPULATION:

As already mentioned, to view our object at the VIEW COORDINATES, i.e.
at the view coordinates, we will have to translate (move) and rotate its
coordinates according to various angles (or the solid stays there, the
beauty of 3D is movement!).
Well, the general formulas for transforming the WORLD coordinates (i.e. of
our “static” object) into VIEW coordinates (rotated in various ways) are:

----------------------------------------------------------------------------

;ROTAZIONI: angoli r1,r2,r3
;	 coordinate x,y,z
; xa,ya,za variabili temporanee

xa=cos(r1)*x-sin(r1)*z
za=sin(r1)*x+cos(r1)*z
x=cos(r2)*xa+sin(r2)*y
ya=cos(r2)*y-sin(r2)*xa
z=cos(r3)*za-sin(r3)*ya
y=sin(r3)*za+cos(r3)*ya

----------------------------------------------------------------------------

;TRANSFORMATION: translation variables mx, my, mz
x=x+mx
y=y+my
z=z+mz

(EASY!!! Just add mx to x, my to y and mz to z!)

----------------------------------------------------------------------------

;PROJECTION: d = distance from the screen
; scx,scy = centre of the screen (e.g. 160.128 for a 320*256 screen)
sx=(d*x/z)+scx
sy=(d*y/z)+scy

----------------------------------------------------------------------------

I hope no one panics. I admit that some people hate trigonometry
and maths in general, but all you have to do is apply the formulas and nothing else!

The first manipulation performed is rotation - taking into account the
roll, pitch, and yaw of the object. (Are we in Italy?)

By ROLL,
 I mean rotation like that of a wheel seen from the side of a
car, or rotation like a disc seen from above (the rotation axis)
Shit, all wrong
(ROLL axis - i.e. in
aeronautics, it is the rotational motion of the aircraft around the X axis, called
the ROLL axis in the Cartesian coordinate system of the body.
Or in ships, the oscillation around a longitudinal axis, whereby the ship
tilts to the right and left.



PITCH refers to “slope” or “inclination” (PITCH axis) in
ships, which is the oscillating movement around its transverse axis, with
alternate lowering of the bow and stern. In short, the ship's “nose”
, i.e. the bow, under water and the propellers, on the other side (at the stern), emerge.


PITCH!            PITCH!

|\                     /|
| \                     / |
| \                     / /
\ \_             _/ /
-- - \ \/ - - - - - -         - - - \/ /- - - - -
\ \             / /
\ \             / /
\ \             ---
\---

YAW is an aeronautical term, meaning nothing less than “yawing”, i.e.
the rotation of an aircraft around the axis perpendicular to the plane
identified by the pitch and roll axes and passing through the centre of gravity
of the aircraft itself. (Z??)

R1 corresponds to the rotation of the object with respect to a vertical axis (Y)

R2 relative to an axis positioned as if we had Pinocchio's nose, i.e.
of which we only see one point, since it is moving away from us at 90° (Z).

R3 relative to a horizontal axis (X)

Translation is fairly self-explanatory, since it simply consists of
adding a fixed quantity to the different coordinates.

The projection formulas are derived from similar triangles, assuming that a
2D (flat) screen has been placed between you and the object, at a distance d.
The image can be calculated by considering two triangles with the same
angles, one for the x coordinate and one for the y coordinate.

Note that if d is not assigned correctly, the image of the object
will appear distorted (aberrated) - the object will appear too flat and not “3D” or,
 in the opposite case, too distorted.
This is due to the fact that you are trying to display too large a part 
of the object on the screen - compare this to walking at the foot of
a bell tower or a skyscraper: if you are too close, you cannot see the whole
building, so to see the whole building (object) you would have to
take a few steps back, moving away.
Similarly, the angular distortion on the screen is due to the fact that you are
trying to show what you would not see on the screen given your
distance from the object!
Fortunately, this value is not particularly critical - just
try changing it until you find an acceptable “view”.

; load WIREFRAME examples here...

So now we are able to place a series of points on the screen
to represent our object in 3D, joining these points together with
lines, forming a WIRE FRAME view of that object.
Although the representation is correctly three-dimensional, it is not good
for representing particularly complicated objects, as it is not clear
which points are in front and which are behind, because we lack clear information
about the depth of the image. We need to remove the hidden lines,
 i.e. make our object non-transparent.

*******************************************************************************

SUPERFICI NASCOSTE (HIDDEN SURFACES):

Prima facciamo wireframe, solo linee, ma con superfici nascoste...


*******************************************************************************

HIDDEN SURFACES and ‘SOLID’ FACES (FILLED VECTORS):

Obviously, we need to “fill” our object to create a solid
that looks truly ‘SOLID’.
To do this, we need to make sure that when we fill the faces
of the object, we only fill the correct faces, i.e. those
FRONT, VISIBLE ones; we certainly don't want to see the “back” of a cube when
we are looking at its “front”.

I will describe two methods for realistically visualising “filled” 3D objects,
i.e. FILLED: CONVEX and ICONVEX vectors


1) REMOVING BACK FACES. (CONVEX VECTORS)

This method only works on CONVEX objects.
A CONVEX object is one where it is not possible for one surface to be
partially obscured by another.
Examples: polyhedra, cubes, tetrahedra, prisms, and even some types of ‘spaceships’
that are not too complicated.
The definition of a convex object provides a starting point - we
can simply draw the faces that are in front of us and ignore
the rest, as long as they must be completely hidden by definition.

It is possible to calculate whether a flat plane is in front of us by calculating the
‘normal’ vector to this plane and seeing whether it has a positive
or negative Z component.

A vector “normal” to another is simply a vector that ‘comes out’
of the plane perpendicular to its surface (or face).
“NORMAL” can also be defined as PERPENDICULAR, at 90°...
For example, with regard to the leg of a table, it can be said that it is “normal”
to the table it is supporting, because it is (at least hopefully) perpendicular
to the flat table top, which may also be set.

However, there is a better method. Consider the orientation of the points at the
edge of the surface...
Imagine numbering the corners of a disc in anti-clockwise order,
around its edge.
Now turn the disc upside down and look at the order of the numbers: they are now
in clockwise order!
We can use this change in order to decide which direction
the face is pointing in.

Given three point numbers and coordinates, it is possible to derive their order:

;orientation:    p1,p2,p3 - points in the face (2D coords!)
;        v1,v1 - temporary 2D vectors for p1>p2 and p2>p3

v1.x=p2.x-p1.x
v1.y=p2.y-p1.y

v2.x=p3.x-p2.x
v2.y=p3.y-p2.y
orientation=sign(v1.x*v2.y-v1.y*v2.x)
;orientation is +/- 1 in relation to the orientation.
;The cross product of the 2D vector is faster than a normal 3D vector,
;because fewer multiplications are needed for the calculation

So, to draw our FILLED CONVEX VECTOR OBJECT, we transform its
coordinates as described, and then draw only the polygons in a clockwise direction,
using a list of points defined in our object.
As long as we are sure that all polygons have point numbers such that when
the polygon is visible they are in clockwise order, and that the object is fully
convex (CONVEX), we will have no problems.

At this point, all that remains is to load the source v_convex.s, which is a
basic convex vector routine. There are enough comments in the source.


*******************************************************************************

2) The ‘PAINTER’ colouring algorithm. (INCONVEX VECTORS)

The name of this technique explains everything.
The idea is that a painter, when painting, starts from the background
of the scene, with the mountains, then gradually draws the various levels of the
drawing, moving forward until he draws the things closest to him.
Therefore, nothing in front of other things will be covered; only the things that are actually covered will be covered, giving the correct image.
This idea is easily applicable to our 3D system.
We filter out all hidden planes by their orientation (as
above), and then we draw them all in order from the most negative as a Z coordinate
to those closest to Z=0.
The negative Z coordinates are in front of the observer, i.e. us, while
Z=0 is where the observer is positioned. The positive Z coordinates are behind
the observer, and as you know, we cannot see things behind us!!!

How can we do this in practice?

Well, when we consider a plane (a face), having decided that it is visible
if it is oriented correctly, we then find out how far away it is in the
scene, i.e. its depth.
There are several ways to do this, but for reasons I will explain later,
 we can only calculate the average Z coordinate of the angle
of the face (or plane).
Then we put this value and a pointer to the definition of the face in a
table (or array, in short, a table).
We'll do this for every face (or plane), then sort the table (or
array) in order from the most negative Z average to the closest to 0.
At this point, we simply take the values from the array (from the TABLE)
and draw the faces in the order of the table.

But if you have seen the convex source, you will notice that the faces are drawn
directly on top of “what has been done before” - this is OK in the convex case
because faces never overlap!

In the INCONVEX case, however, faces can overlap, which is why there is
the “painter” algorithm and depth sorting (SORT).
We can simply draw our faces in a temporary buffer, and
“cut+copy” them with the blitter (cookie cut) to the display screen.
(Of course, “double buffered”!).

To see an ICONVEX vector in practice, the source is v_inconvex.s.

It was said earlier that only by taking the average of each Z coordinate
of the faces' angles will decent depths be generated.
The reason for using this method, rather than Pythagoras' theorem,
calculating x^2+y^2+z^2 (forget the root), and taking the average, is
 
simply that I do not think the “effort” is necessary.
The “painter” algorithm has one drawback: it does not take into
account the fact that a face can extend over a considerable
range of z values, so representing it only with an average value does not
give a true picture of the situation.
You can try to get around this problem by being careful
with large planes and faces that are too extensive, perhaps dividing them in two, or
also taking into account the minimum and maximum Z values


*******************************************************************************

Multiple Objects:

Not long ago in the demo scene, there was a huge fuss about
being able to display a large number of independent objects at
once... So the “how many cubes scene” was born, where people
competed by presenting screens full of cubes, and the winner was whoever had put
one more, which often turned out to be an animated sprite (HAHAHAHA!).
However, this isn't the hardest thing to do, you just need to make
code arrangements suitable for a single object, modifying it.

What needs to be done is to position and rotate all the objects, which
will need to have a table with “customised” information, but the “engine”
that moves everything is the same.
A fast and powerful SORT (sorting) routine for the depth will be important,
 as it will ensure that only what is needed is drawn.
In addition, many tables and structures will need to be created to contain the
definitions of all objects.

*******************************************************************************

Lines/Bobs:

To implement VECTORBALLS, we simply need to set the
coordinates as with the faces, sort their Z values with a SORT routine,
then draw the scene with the bobs at the correct depth.
The bitmaps for the bobs can be simply copied with the blitter's ‘cookie cut’
on the screen.

Lines can be easily inserted by calculating the average of the
Z coordinates (both of them), and then inserting that average as a pointer to the
line structure in the depth table (DEPTH ARRAY), and
proceeding in a similar way to the bob.

By the way, it might help to put some form of identification marker
in these line/bob/plane definitions, so
when we jump through the sorted depths listed, the code
understands what it is dealing with (a line or a bob...).

*******************************************************************************

SHADING:

METHOD OF ‘MESHING’ OR ‘DOTTING’ SOME FACES
To show the dotted colours, we need to alternate the colour of
adjacent pixels... To do this, we can assign a mask in memory
(01010101010 etc), and use it as a mask to throw down the faces.
What we can do is check the two colours we are going to
dash, and the pair of bits for each respective bit plane.
If both are set to 1, this means that for this bit plane
we must discard our face as usual (cookie with our
face drawn using it as its own mask).
Similarly, if both are set to 0, we do the same, deleting
the area of the screen where the face is.
If they are different (e.g., colour 1 is set and colour 2 is not), we copy the face with the blitter's ‘cookie,’
but using the 010101 mask as our source plane,
and the face as the mask.
This lowers the bits in the order 010101 where the plane is on the screen.
If the other possible situation occurs, with colour 1 reset and colour 2 set,
we need to use a mask starting with 1010...
To do this, we use the blitter in a different way, inverting the mask.

Although fast, this method has the disadvantage of using a lot of
memory for the mask, which must be the same size as a
bitplane, or at least as large as the largest face you want to display.
To avoid this, you can disable the blitter channel through
which the 1010 data passes; this way, you can simply put
these alternating values in the BLTxDAT register.
Now, however, two blits per bitplane are necessary, because only one line
every 2 uses the same mask:

Line 1: 10101010 \
Line 2: 01010101 | Only the masks for lines 1, 3, 5... are the same.
Line 3: 10101010 / Lines 2, 4, 6... are inverted.

That is: Blit every even line of the face, invert the value
of BLTxDAT, do the lines skipped on the first blit (odd!)....
This implies using half the height for BLTSIZE, and adding
modulus values to the blitter, so that only one line in every two is touched.

*******************************************************************************

LIGHT SOURCING:
 ‘Light sourcing’ consists of making the colours of the faces
represent the reflection of the light source on them.
Two methods are frequently used:

Z-Value only - This simply consists of drawing the plane closest
to the observer with the brightest colour, while the furthest ones with
darker colours. It is simple, as you only need to consult the Z value of the 
distance, but it is not the most convincing method from an illusionistic point of view.
It can be done entirely by averaging the Z coordinates of the faces,
simply by implementing a table containing the colours according to the Z values, or in
other ways. (For example, the colour can be calculated with z/128, i.e. the 
distance divided by 128, if the colour generated is a valid RGB colour).

Lambert's Cosine Rule - This little rule states that the amount
of light reflected from a surface follows the cosine of the angle
between the normal to the surface and the direction of the reflected ray.
To avoid lengthy explanations, here is the method:

Calculate the normal to the surface.

This is calculated by finding two vectors on the surface and obtaining the normal
through the cross product of the two vectors. The two vectors can come
from any of the three points on the face - So a=p2-p1, b=p3-p1
where p1-3 are the xyz coordinates of three points on the face.
a-b are vectors.

The normal is given by: a*b= (a2*b3-a3*b2,a3*b1-a1*b3,a1*b2-a2*b1)

The “normal” vector must be reduced to a unit vector by dividing it
by its modulus... Similarly, the vector from the observer to the plane must
be transformed into a unit vector.

The cosine of the angle between these two unit vectors is now
simply the ‘dot’ product, i.e. the product ‘*’ of them
That is, a1*b1+a2*b2+a3*b3

This value between 0 & 1 (therefore an arithmetic fixed point here)
gives the illumination factor of the surface, and therefore its colour, using
a method similar to the single Z-value technique.

*******************************************************************************

‘FLEXIBLE’ or “GELATINOUS” VECTORS (FLEXY, JELLY & RUBBER VECTORS):

Some demos have vectors that ‘bend’ and flex, as if they were made
of rubber or jelly.
‘Twisting’ our 3D vectors is not as complex as it seems, since the
deformation is often done using either simple horizontal wiggles
via the BPLCON2 ($dff102) repeated every copper line, or in a manner
similar to a sinescroller, whereby the ‘right’ vector is drawn in a buffer
and blitted in strips to make it wiggle.
If we then combine these two methods, it will look even more realistic.
However, there are many methods to make these solids “look” like
jelly, but most of them are either pre-calculated or 90% fake.
It would take a Ray-Tracing program such as Real3d or Imagine to make
a real one, or one of you if you are a genius.

*******************************************************************************

STENCIL VECTORS (decorated stencil vector):

To decorate the faces with a geometric pattern, use a technique similar
to SHADING using rasterisation/dotting.
Note that the graphics on the faces of the STENCIL VECTORS are not distorted
perspectively, but remain “fixed” on the moving faces.
We need to have a repetitive, or rather repeatable, graphic pattern in memory,
similar to bathroom tiles, or rather a mosaic.
When we throw down the faces, we need to use these graphic bitplanes
as the source instead of the face in the temporary buffer. We will then use another
temporary buffer for a mask (as usual).
To avoid having pieces of raw graphics that are too large in memory, we can
perform the ‘cookie’ copy operation with the blitter in smaller pieces, in short
dividing the operation ‘into rates’.

*******************************************************************************

WRAPPED vectors on the faces of other vectors:

These vectors are usually cubes that have a kind of
‘monitor’ on one or more faces on which you can see another vector rotating, and in turn
there may be another vector on the face of the vector in the vector.
An exemplary ITALIAN case is the demo ‘TRIPLE HERMAPHRODITE CUBE’ by DIVINA,
programmed by LUYZ, which shows a lightsourced cube with a “monitor” face
with another small cube, on one face of which there is another ‘monitor’ with
a small cube, also lightsourced.

*******************************************************************************


OPTIMISATION:

Looking at v_convex.s and v_iconvex.s, you will have noticed some optimisations.

-Clean or bleed only part of the screen or temporary buffer.
It sounds obvious, and it's true, but to do this we examine a ‘window’ that
consists of minimum & maximum x/y coordinates, so that we copy/clear
only the minimum number of words necessary.

-Do not lock the processor in a WaiBlit wait cycle for the blitter, if
it is not really necessary. The CPU and the BLITTER can work at the
same time, so stopping the CPU in a loop to wait for the blitter,
when the CPU itself could do the same job as the blitter, or do
other calculations, is a waste of time.
You only need to wait for the end of the blit before doing another
blit. However, it is also important to organise the routines so that the blitter
works when the processor is doing multiplications and divisions, avoiding
the processor waiting for nothing, is very important.
You could use an interrupt that blits when needed.
A simple example of optimisation is in clearing the screen.
Instead of using only the blitter, you can clean half with the blitter
and half with the processor in ‘multitasking’. Balancing the work between the CPU
and the blitter is very important. In reality, on 68020+ processors, it is better to
let the processor do almost everything, but on 68000 the problem remains.

-Another example is extrusion. Extrusion is what happens
to toothpaste when the tube is squeezed:
 it comes out in the shape of the tube itself. If the tube is star-shaped, a star-shaped solid comes out; if it is a
circle, a cylinder comes out, etc.
In terms of vectors, this means that we have a constant cross-section
in an object.
This also means that the points at each end of the object are all
connected by a common vector. To save the calculation of many points,
only one end can be calculated, and this common vector.
Then, to generate the coordinates at the other end, simply add this
vector with the coordinates of the points at the other end.

-Sort depth. If the scene is complex, the SORT routine will be
crucial for the overall speed

*******************************************************************************

CLIPPING:

In some cases, you will need to draw lines on the screen that
have coordinates ‘outside’ it, for example when you get very close
to an object and some of its parts go ‘outside’ the screen.
Load the ‘polygon clipper’ source...
Several methods can be used, typically intersection faces, but
I'll leave it up to the authors to figure it out

Landscapes (LANDSCAPE):

Well... I don't know how to do it...

*******************************************************************************

References:

If you can find these books and you're a real fanatic, you can consult them:

COMPUTER GRAPHICS - Steven Harrington. ISBN 0-07-100472-6
A very thorough treatment of
both 2D and 3D graphics techniques, VERY TECHNICAL (beginners, say goodbye!)
and not specific to Amiga, therefore an
‘abstract’ treatise on 2D-3D graphics.
If you want to design stuff for virtual reality
based on A4000 turbo, it'll do...

Thanks to:

The authors of ACC (Amiga Coders Club), especially 

Paul Kent


