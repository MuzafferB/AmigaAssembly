_
_|_ / \.¼¼/\_/\¼._
| / ¯\/ \/ \ _
| Y _____¯\/¯_____ Y ___ /¯\ ___ .--.
.--------- |/¯¯¯¯¯\ /¯¯¯¯¯\| ----- .Y¯¯¯Y¾Y Y:Y¯¯¯Y. ___ ------.\/.--.
| ¬ f | YY | Y ¬.¾¾l___j¾l___j¾l___j¾Y¯¯¯Y ¬ \/ ¬ |
|. l -¼- jl -¼- j /¯/\¼f _ Y¼f _ Y¼f _ Y¾l___j |
|¡ |\ | _/¯¯\_ | /| ( < >l/ \j¼l/ \j¼l/ \j./__ / .|
|: j \__/ /¯¯\ \__/ l \_\/ `\ /¼¼¼\ /¼¼¼\ /¼l/ /j :|
|. ( ¯¯ / \ ¯¯ ) V `¼¼¼V¼¼¼¼¼V¼' \/ .|
| \__ \_/\_/ __/ .:::::::“ |
|. ¯\ /¯ ««=-- DISK 2 - LESSON 8 --=»» .|
| /\ Y : . . Y · . . . tS |
`--”/\`------- (_| | :| ) ---------- · . ----------------“
`--” \\j_j_ll// . · .
~:¯:¯::~ .

ASSEMBLER COURSE - LESSON 8

Author: Fabio Ciucci

In this lesson, we will deepen our knowledge of the 68000 and
clarify various topics already covered.
A note for those installing the course on a hard disk: I recommend creating
directories with the name of the relevant course disk:

Assembler1
Assembler2
Assembler3
...

Where you will copy the entire diskettes. Then add to s:startup-sequence:

assign Assembler1: dh0:Assembler1
assign Assembler2: dh0:Assembler2
assign Assembler3: dh0:Assembler3
...

(dh0: is just an example... you will put the appropriate drive, of course!).
Then I would recommend unpacking all the sources and data, which are in
powerpacker format. To do this, copy the c:PP file to your hard disk and
check if you have PowerPacker.library in LIBS. If not, copy it
from this disk. Now, run ‘PP’ from the shell to enable
automatic unpacking. Now create a ‘temporary’ directory, for
for example, call it ‘buffer’. If you copy ALL the files from the
Assembler1 directory to the Buffer directory, all the files will be unpacked, in fact
they will ‘lengthen’. Now you can copy them all back to Assembler1 (perhaps with
a MOVE from DiskMaster or DirOpus, which also deletes them from the buffer).
In the same way, you can copy everything from Assembler2 to the buffer, then copy it back
to Assembler2. To save this quick operation, you can load
the PP before copying the files from the diskette to the directories on the hard disk, so that
the files in AssemblerX are unpacked.
The 3 assign commands are used to ensure that instead of searching for the disk
with the name ‘AssemblerX:’ it searches in the directory ‘dh0:AssemblerX’.
In some of the next listings, in fact, it searches for ‘Assembler2:’, and so
it will also be for ‘Assembler3:’.


P.S: I intend to translate the entire course into English. However, this would
force me to stop writing new lessons for MONTHS...
So, if you find someone who has already read disc 1,
knows English reasonably well, and is willing to translate at least
one lesson, I would be very happy. Anyone who helps me with the
translation will of course receive a very high percentage of the
profits made abroad (how about 30%? Maybe that's too much..)
If anyone can help me (I'm talking about a LOT of translation work),
please contact me as soon as possible.

P.S2: Please copy disc 1 of the course to ALL your friends (and others), give it to shopkeepers in your town, put
advertisements on notice boards or in newspapers to see if anyone is interested,
 and find new contacts for programming. In particular, you could spread the CyberAssemblica philosophy of the scene, a summary of which can be found in the SCENA.TXT file. Even the Pope, when he appears at the window of his study, reads the CyberAssemblica philosophy.
and find new contacts to plan with. In particular,
 you could spread the CyberAssemblica philosophy of the scene,
a summary of which can be found in the SCENA.TXT file.
Even the Pope should have disc 1
of the course when he appears on the balcony! (freely copyable).
As for disc 2, i.e. this one, it is not
freely copyable, otherwise I wouldn't even take the
(not much) money sent to me by those who only have
disc 1. Imagine if they had both discs!
Anyway, when (and if) I make discs 3, 4, etc., I will probably
make disc 2 freely copyable (shareware, though),
so that newcomers can get discs 1+2 right away, and then I'll
make a few pennies with discs 3, 4...


Let's continue the lesson, whether the file is on the hard disk or on a floppy disk.
First of all, it is necessary to complete the lesson on the 68000, since
so far we have only used it in a simplified way. In the previous lesson, you
saw that it is very often necessary to operate on individual bits of
numbers or registers, and the further you go in programming, the more
you will tend to insert instructions such as AND, OR, NOT, ROL, ASL... etc., i.e.
Boolean logic and bit shifting operations.
Ah! In the LESSONS directory there is a text explaining what the AMIGA SCENE is.
AMIGA. Now that you are becoming coders, it is appropriate that you know who
to thank for the birth of the culture of demo programming
in that “illegal” way, which, as you have seen, works, and
very well at that. The text is SCENA.TXT. Read it when you don't feel like
smoking your brain with asm lessons!
Before continuing with the course, you need to make a startup list,
i.e. save and restore the system copper, which is more efficient
than the one used so far. Furthermore, this startup must be
included in all future lists, so it will certainly be more useful to
load it using the ‘INCLUDE’ directive already seen to include the routine
that plays the music.
 We will ‘build’ this startup in the lesson step by step, as a result of various clarifications.
Let's analyse the startup procedure used in previous lessons:

Start:
move.l    4.w,a6        ; Execbase
jsr    -$78(a6)    ; Disable
lea	GfxName(PC),a1    ; Lib name
jsr    -$198(a6)    ; OpenLibrary
move.l    d0,GfxBase
move.l    d0,a6
move.l    $26(a6),OldCop    ; save the old COP

; This is where our copperst is pointed and where the routines are located

move.l    OldCop(PC),$dff080    ; Point to the system COP
move.w    d0,$dff088        ; Start the COP
move.l    4.w,a6
jsr    -$7e(a6)    ; Enable
move.l    gfxbase(PC),a1
jsr    -$19e(a6)    ; Closelibrary
rts

In practice, we stop multitasking and system interrupts using
Disable, then we open the graphics library, through which we can
find the address of the old copperlist, knowing that it is located $26 bytes
after the GfxBase address. Knowing how to put the old
copperlist back in place and having immobilised the WorkBench, we can act directly on the
custom chips without fear of incompatibility. At the end of the routines, it will be
necessary to execute Enable to reactivate multitasking and point to the
old copperlist to redisplay the operating system windows.
These operations are the bare minimum required to work, but
some improvements could be made to the code. For example, you could
run routines from the graphics library that reset the video mode,
in order to also reset video modes for VGA/Multisync/Multiscan monitors
or others. A specific function exists for this, called LoadView. Let's take a look:

; We have GfxBase in register A6

MOVE.L    $22(A6),WBVIEW    ; Save the current system WBView
SUBA.L    A1,A1        ; Null view to reset the video mode
JSR    -$DE(A6)    ; LoadView null - video mode reset

The LoadView function requires that the address of the view structure be specified
in a1, but in this case A1 is RESET, since we add a1 to itself,
 obtaining a1=0. When A1 is NULL, the function resets the video mode
, returning it to a non-interlaced LOWRES mode without special frequencies for
monitors. At this point, we are more confident that we have the 
copperlist situation under control. We have also saved the old pointer to the
WBVIEW structure in a label, which will allow us to restore it at the end of the listing,
 along with any special frequencies for monitors:

MOVE.L    WBVIEW(PC),A1    ; Old WBVIEW in A1
MOVE.L    GFXBASE(PC),A6    ; GFXBASE in A6
JSR    -$DE(A6)    ; loadview - restore the old View

To make sure that the interlaced mode is also reset and restored
correctly, you can wait for two frames by executing the
WaitOF routine, also from graphics.library:

MOVE.L    WBVIEW(PC),A1    ; Old WBVIEW in A1
MOVE.L    GFXBASE(PC),A6    ; GFXBASE in A6
JSR    -$DE(A6)    ; loadview - restore the old View
JSR    -$10E(A6)    ; WaitOf (Resets any interlacing)
JSR    -$10E(A6)    ; WaitOf

To be on the safe side, let's add a couple of WaitOFs after the first
loadwiew that resets the video mode, and while we're at it, let's check if the
reset has actually taken place by testing if WBVIEW is reset as expected:

; We have GfxBase in register A6

MOVE.L    $22(A6),WBVIEW    ; Save the current system WBView
SUBA.L    A1,A1        ; Null view to reset the video mode
JSR    -$DE(A6)    ; LoadView null - video mode reset
JSR    -$10E(A6)    ; WaitOf ( These two calls to WaitOf )
JSR    -$10E(A6)    ; WaitOf ( used to reset the interlace )

Having used operating system routines, we are sure that in future machines
the video mode will still be reset.
To ‘exaggerate’ compatibility, we can call at the end of the listing
the intuition.library functions that ‘redraw’ the screens and
windows:

move.l    4.w,a6        ; ExecBase in A6
LEA    IntuiName(PC),A1 ; Name of library to open (intuition)
JSR    -$198(A6)    ; OldOpenLibrary - open the lib
TST.L    D0        ; Error?
BEQ.s    EXIT        ; If yes, exit without executing the code
MOVE.L    D0,A6        ; IntuiBase in a6
jsr    -$186(A6)    ; ReThinkDisplay - Reorder the characteristics of the
; screens...

This operation is similar to that performed with WBView.
We haven't used the blitter yet, but in the next few lessons there will be
many “blittats”, and since we will be using this startup, it will be useful to
set it up for this purpose. Just make sure that the blitter is not being used
by the operating system while we are using it, and there is a function
in GfxLib that can stop the WorkBench from using the blitter
:

jsr    -$1c8(a6)    ; OwnBlitter, which gives us exclusive access to the blitter
; preventing the operating system from using it.

At the end of the listing, simply call the function that does the opposite, i.e.
re-enables the use of the blitter by the graphics library:

jsr    -$1ce(a6)    ; DisOwnBlitter, the operating system can now
; can use the blitter again

These two functions are similar to Disable and Enable, which, as we have
seen, stop multitasking and system interrupts and then re-enable them.
In reality, there is also a less drastic function than Disable, namely
Forbid, which disables multitasking while leaving
system interrupts No one forbids using Forbid and Disable together, perhaps
it makes the system shutdown less abrupt, let's try them together:

move.l    4.w,a6        ; ExecBase in A6
JSR    -$84(a6)    ; FORBID - Disables Multitasking
JSR    -$78(A6)	; DISABLE - Also disables operating system interrupts
;
; routines

MOVE.L    4.w,A6        ; ExecBase in a6
JSR    -$7E(A6)    ; ENABLE - Enables System Interrupts
JSR    -$8A(A6)	; PERMIT - Enable multitasking

Now the Amiga can't complain with a Guru Meditation or a Software Failure
saying that we didn't warn it that we were programming the hardware!

/ \ //\
|\___/| / \// .\
/O O \__ / // | \ \
/ / \/_/ // | \ \
@___@“ \/_ // | \ \
| \/_ // | \ \
| \/// | \ \
_|_ / ) // | \ _\
”/,_ _ _/ ( ; -. | _ _\.-~ .-~~~^-.
,-{ _ `-.|.-~-. .~ `.
'/\ / ~-. _ .-~ .-~^-. \
`. { } / \ \
.----~-.\ \-' .~ \ `. \^-.
///.----..> \ _ -~ `. ^-` ~^-_
///-._ _ _ _ _ _ _}^ - - - - ~ ~--, .-~
|_/~
 

Since we save the status of everything, why not save the values of the
data and address registers? There is an instruction that is mainly used
for this purpose, and that is MOVEM. However, the registers are
saved in the STACK, i.e. the A7 register, also known as SR, which we have
avoided using for now. Let's see what the stack is: think of it as a
register similar to an address register, not for nothing is it the A7 register,
so the value it contains is an address, i.e. it POINTS to an address.
The fact is that if we change the address contained in A7 (or SP), the Amiga
goes completely crazy. But who puts that address in the Stack Pointer?
Since modifying it causes a Guru/Software Failure, you can guess
that it is the operating system that decides this number at each reset, and it is the operating system that
modifies it when necessary. However, knowing how to use it can be very useful.
We have seen in the course how it is possible to indicate a memory area with
indirect addressing, for example by writing:

lea    bitplane,a0
move.l    #$123,(a0)+
move.l    #$456,(a0)+

We have entered the values $123 and $456 in the bitplane by acting on the a0 register,
since we have made a0 POINT to the bitplane. From this listing, we can also see
how it is possible, with indirect addressing with post-increment,
to enter data consecutively, one after the other, in the memory area.
What would happen if, after those instructions, we wrote:

move.l    -(a0),d0
move.l    -(a0),d1

The last value entered, i.e. $456, would be copied to d0,
while the first, $123, would be copied to d1, and a0 would point to the bitplane again.
In practice, we have “gone back”.
Now, imagine doing the opposite of this: in the case we
have seen, there is a memory area, which we have called BITPLANE, and
we write from that address onwards with move.l #xxx,(a0)+

Bitplane
o------------>

Then, after a certain number of instructions, a0 points to bitplane+x, i.e. much
further ahead in memory.
We can ‘retrieve’ the values we ‘seeded’ in this field with
move.l -(a0),xxx which take us back until we reach
the starting address BITPLANE again. But be careful! We have collected the data
in reverse order to that in which it was entered, so the last one entered
is the first one retrieved. The stack points to an address in memory, which serves as a
“field” in which to sow, i.e. an area where data can be saved and retrieved.
Be careful, though, because it is used ‘backwards’, unlike
the bitplane example. The need for a stack arose with the first CPUs, and
it is organised in this way: a computer's memory is usually
filled from the lowest locations to the highest. For example, if
we have a computer with 512k of memory and we need to load a file that is
256k long, the first 256k will be filled and the Kb from 257 to 512 will remain free.
If you want to reserve a STACK space to save generic data, it was
decided to start this space from the end of the memory, and to
save the data “backwards” towards the first memory location, in order to
make the best use of the memory:


ZERO ---------------------------------------END OF MEMORY
Programmes ----->>        <<-----STACK


In this way, the stack is not overwritten unless the memory is
completely full, and in any case, programmes under the operating system avoid such
conflicts! We need to make demos or games that can be run from the operating system,
so we must use the stack in a standard way to avoid conflicts or
overwrites. If we were to create an autoboot programme without the need to
exit, we could define our own area for the stack, but this can
cause compatibility issues, so for now I recommend not doing so.
Finally, let's see how to enter and retrieve data from the STACK, starting
with a very simple example: saving the contents of register D0 and
then restoring it.

MOVE.L    d0,-(SP)    ; save d0 in the stack. NOTE: if we only need to
; save one register, we use MOVE and
; not MOVEM, which is used for multiple registers.

;    Routines that modify D0

MOVE.L    (SP)+,d0    ; restore the old value of d0
; taking it from the STACK

Note that writing MOVE.L d0,-(SP) or MOVE.L d0,-(A7) is equivalent, as
the same binary sequence is assembled in memory. Note that the contents
of d0 are copied to the address pointed to by SP, and SP itself points
one long further back. Then d0 is modified by various routines, and when
we want to obtain its old value, we just need to retrieve it from the address
in SP, and note that with (SP)+ we return SP to point to the address it
pointed to before saving d0, i.e. we went back one long,
then we went forward again, retrieving the value.
Now let's try to save the value of several registers:

MOVE.L    d0,-(SP)    ; save d0 in the stack
MOVE.L    d1,-(SP)    ; save d1 in the stack
MOVE.L    d2,-(SP)    ; save d2 in the stack
MOVE.L    d3,-(SP)    ; save d3 in the stack

;    Routines that modify d0, d1, d2, d3

MOVE.L    (SP)+,d3    ; restore the old value of d3
MOVE.L    (SP)+,d2    ; restore the old value of d2
MOVE.L    (SP)+,d1    ; restore the old value of d1
MOVE.L    (SP)+,d0    ; restore the old value of d0
; taking them from the STACK

Note that the last value saved is the first one that can be retrieved,
precisely because we go backwards and then forwards, reading
from the last value entered backwards to the first:

STACK starting address
ENTRY:    -(SP)    <--------------o    - backward -


STACK starting address
READING:    (SP)+    ---------> o    - forward -


This is a structure called a “stack”, which can be imagined as follows
: imagine you have a collection of comics and want to sort them from
number one to number 50. Once you have found number 1, you put it on a table.
Once you have found number 2, you put it on top of number 1. Then you put number 3 on top of number 2, and so on
make a ‘stack’ of comics until you have placed number 50 on
top of the pile. Now, if you wanted to take the comics back, the first one you
would find is 50, then underneath you would find 49, 48, and so on, and lastly
you would find 1. The stack is in fact of the ‘first in, last out’ type, i.e. "the
first in is the last out".
You will understand that by modifying the stack improperly, values are taken from
memory at random and considered as values saved previously.
So be careful when you execute a:

MOVE.L    xxxx,-(SP)    ; save xxxx in the stack

The next time you read with (SP)+ from the stack, you will get xxxx.

You can save and retrieve any data in the stack, but one of the most
obvious uses is to save the state of the registers, and to do
this you can use the simple MOVE.L, in the case already seen of saving
a single register, or MOVEM (MOVE Multiple) for multiple registers.
Let's see how MOVEM works: to save all registers (except a7,
obviously, which is the SP, therefore d0, d1, d2, d3, d4, 5, d6, d7, a0, a1, a2, a3, a4, a5, a6),
you must execute this single MOVEM instead of 15 MOVE:

MOVEM.L    d0-d7/a0-a6,-(SP)    ; saves all registers in the STACK

And to restore them all, just type:

MOVEM.L    (SP)+,d0-d7/a0-a6    ; retrieve all registers from the STACK

Basically, MOVEM moves a list of registers to the destination, in the
case of ‘MOVEM.L d0-d7/a0-a6,destination’, or copies a source to various
registers, in the case of ‘MOVEM.L source,d0-d7/a0-a6’.
The source and destination are in ‘standard’ format, so you can
copy to and from LABELS/ADDRESSES or indirect addresses:

MOVEM.L    d0-d7/a0-a6,-(SP)
MOVEM.L	d0-d7/a0-a6,LABEL
MOVEM.L	d0-d7/a0-a6,$53000

MOVEM.L	$53000,d0-d7/a0-a6
MOVEM.L	LABEL(PC),d0-d7/a0-a6
MOVEM.L    (SP)+,d0-d7/a0-a6

The list follows this standard: registers can be indicated separately,
separating them with a slash ‘/’, so we can say that:

MOVEM.L    d0-d7/a0-a6,-(SP)

is equivalent to:

MOVEM.L    d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6,-(SP)

However, since consecutive series of registers can be indicated by placing
the first register in the series and the last register separated by a ‘-’, only the data registers are separated from the address registers by the slash.
In reality, the assembler also accepts:
MOVEM.L    d0-a6,-(SP)

Considering it as the very long instruction above, but since not all assemblers accept this form, it is better to put the ‘/’ between the series of data registers and the series of address registers.

Considering it as the very long previous instruction, but since not
all assemblers accept this form, it is better to put the ‘/’ between
the series of data registers and that of address registers.
Let's look at some examples: we want to save registers d0, d1, d2, d5 and a3:

MOVEM.L    d0-d2/d5/a3,-(SP)

We have simplified d0/d1/d2 with d0-d2.
Now let's try to save d2, d4, d5, d6, a3, a4, a5, a6:

MOVEM.L    d2/d4-d6/a3-a6,-(SP)

Clearly, to restore these registers, we would write:

MOVEM.L	(SP)+,d2/d4-d6/a3-a6

I think the syntax of MOVEM is clear. This instruction allows
multitasking. Have you ever wondered how
it is possible to run two programs together, using the same registers
data and addresses, without them interfering with each other? The answer is simple!
At the beginning of each routine there is a MOVEM that saves the state of the registers,
the routine is executed, and at the exit the registers return to their original state
as if the routine had never been executed.
Many routines are structured in this way:

Routine:
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
rts

In this way, a ‘BSR.W ROUTINE’ does not cause the registers to be modified, so
if there was $dff000 in a5 and ExecBase in a6, we can be sure that after
executing the routine, these values will always be present.
When using MOVEM, it often happens, the first few times, that you lose ‘THE THREAD’ of the
movem already done, so something like this can happen:


Routine:
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
rts

In this case, there is a HUGE ERROR, because first of all, the stack has
gone too far, so all the data that will be retrieved from the stack
later will be wrong. Secondly, the registers will already have values
different from those at the input. To fix everything, you could do the following:


Routine:
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
....
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
rts

This way, when the routine exits, the registers have the input value
and the stack is back at the input address. (input into the routine!)

At this point, we can equip our startup with initial register saving
and final restoration, similar to this last example.
This is what our startup looks like at this point:

MAINCODE:
movem.l    d0-d7/a0-a6,-(SP)    ; Save the registers to the stack
move.l    4.w,a6            ; ExecBase in a6
LEA    GfxName(PC),A1        ; Name of library to open
JSR	-$198(A6)        ; OldOpenLibrary - open the lib
MOVE.L    d0,GFXBASE        ; Save the GfxBase in a label
BEQ.w    EXIT2            ; If yes, exit without executing the code
LEA    IntuiName(PC),A1    ; Intuition.lib
JSR    -$198(A6)		; Openlib
MOVE.L    D0,IntuiBase
BEQ.w    EXIT1            ; If zero, exit! Error!

MOVE.L    IntuiBase(PC),A0
CMP.W    #39,$14(A0)    ; version 39 or higher? (kick3.0+)
BLT.s	OldIntui
BSR.w    ResetSpritesV39
OldIntui:

MOVE.L    GfxBase(PC),A6
MOVE.L    $22(A6),WBVIEW    ; Save the current system WBView

SUBA.L    A1,A1        ; Null view to reset the video mode
JSR    -$DE(A6)    ; Load null View - video mode reset
SUBA.L    A1,A1        ; Null View
JSR    -$DE(A6)    ; LoadView (twice to be safe...)
JSR    -$10E(A6)    ; WaitOf ( These two calls to WaitOf )
JSR    -$10E(A6)    ; WaitOf ( needed to reset the interlace )
JSR    -$10E(A6)    ; Two more, come on!
JSR    -$10E(A6)

MOVEA.L    4.w,A6
SUBA.L    A1,A1        ; NULL task - find this task
JSR	-$126(A6)    ; findtask (d0=task, FindTask(name) in a1)
MOVEA.L    D0,A1        ; Task in a1
MOVEQ    #127,D0        ; Priority in d0 (-128, +127) - MAXIMUM!
JSR    -$12C(A6)	;_LVOSetTaskPri (d0=priority, a1=task)

MOVE.L    GfxBase(PC),A6
jsr    -$1c8(a6)    ; OwnBlitter, which gives us exclusive access to the blitter
; preventing its use by the operating system.
jsr    -$E4(A6)    ; WaitBlit - Waits for the end of each blit
JSR    -$E4(A6)    ; WaitBlit

move.l    4.w,a6        ; ExecBase in A6
JSR    -$84(a6)    ; FORBID - Disables multitasking
JSR    -$78(A6)    ; DISABLE - Also disables operating system interrupts
;
**************
bsr.w    HEAVYINIT    ; Now you can execute the part that operates
**************            ; on the hardware registers

move.l    4.w,a6        ; ExecBase in A6
JSR    -$7E(A6)    ; ENABLE - Enable System Interrupts
JSR    -$8A(A6)    ; PERMIT - Enable multitasking

SUBA.L    A1,A1        ; NULL task - find this task
JSR    -$126(A6)    ; findtask (d0=task, FindTask(name) in a1)
MOVEA.L    D0,A1        ; Task in a1
MOVEQ    #0,D0        ; Priority in d0 (-128, +127) - NORMAL
JSR    -$12C(A6)    ;_LVOSetTaskPri (d0=priority, a1=task)

MOVE.W    #$8040,$DFF096    ; enable blit
BTST.b    #6,$dff002    ; WaitBlit...
Wblittez:
BTST.b    #6,$dff002
BNE.S    Wblittez

MOVE.L    GFXBASE(PC),A6    ; GFXBASE in A6
jsr    -$E4(A6)    ; Wait for the end of any blitting
JSR    -$E4(A6)    ; WaitBlit
jsr    -$1ce(a6)    ; DisOwnBlitter, the operating system can now
; use the blitter again
MOVE.L    IntuiBase(PC),A0
CMP.W    #39,$14(A0)    ; V39+?
BLT.s    Vecchissima
BSR.w    RimettiSprites
Very old:

MOVE.L    GFXBASE(PC),A6    ; GFXBASE in A6
MOVE.L    $26(a6),$dff080    ; COP1LC - Point to the old system copper1
MOVE.L    $32(a6),$dff084    ; COP2LC - Point to the old system copper2
JSR    -$10E(A6)    ; WaitOf ( Reset any interlace)
JSR    -$10E(A6)    ; WaitOf
MOVE.L    WBVIEW(PC),A1    ; Old WBVIEW in A1
JSR    -$DE(A6)    ; loadview - restore the old View
JSR    -$10E(A6)    ; WaitOf ( Reset any interlace)
JSR    -$10E(A6)    ; WaitOf
MOVE.W    #$11,$DFF10C    ; This does not restore it by itself..!
MOVE.L	$26(a6),$dff080    ; COP1LC - Point to the old system copper1
MOVE.L    $32(a6),$dff084    ; COP2LC - Point to the old system copper2
moveq    #100,d7
RipuntLoop:
MOVE.L    $26(a6),$dff080	; COP1LC - Point to the old system copper1
move.w    d0,$dff088
dbra    d7,RipuntLoop    ; For safety...

MOVEA.L    IntuiBase(PC),A6
JSR    -$186(A6)    ; _LVORethinkDisplay - Redraw the entire
; display, including ViewPorts and any
; interlace or multisync modes.
MOVE.L    a6,A1        ; IntuiBase in a1 to close the library
move.l    4.w,a6        ; ExecBase in A6
jsr    -$19E(a6)	; CloseLibrary - intuition.library CLOSED
Exit1:
MOVE.L    GfxBase(PC),A1    ; GfxBase in a1 to close the library
jsr    -$19E(a6)    ; CloseLibrary - graphics.library CLOSED
Exit2:
movem.l    (SP)+,d0-d7/a0-a6 ; Restore the old register values
RTS             ; Return to ASMONE or Dos/WorkBench

There are only four details added: one is the check after
opening the Graphics.library; in fact, if for some reason it cannot be opened,
instead of the GfxBase address, we would find ZERO in d0.
All you have to do is a pseudo ‘TST.L D0’ and a jump to the EXIT label if
it does not open. You will see, when studying Condition Codes, why it is enough to
do a “beq” after a move, without using ‘tst’, to know if d0 is zeroed.
Another detail is the appearance of the system COPPER2 (GfxBase+$32)
which is nothing more than the value entered in $dff084, COP2LC, by the operating system
; for now, we have never used copperlist 2, but in certain lessons
later on, we will be sure to illustrate its useful cases.
Another ‘subtlety’ is to reset the sprites, but only if we are on
kickstart 3.0 or higher, since the sprite reset function is
available from this version onwards. The subroutine that resets the sprites
is a classic example of ‘legal’ programming, with calls to the
operating system.As you can see, it is more complicated to use the operating system than to program via hardware (isn't that right?).
Finally, there is the task priority setting. As you know, every program
that is executed in multitasking has its own ‘priority’ 
relative to the others.
Well, let's set it to the maximum! That is, 127. In reality, this would not be necessary, since
we will disable multitasking completely, but we will see later that it is
useful to set the priority to the maximum and re-enable multitasking to
load data files from floppy disk, hard disk or CD-ROM.

With this startup, we are doing everything possible to ensure that the operating system can
be ‘overridden’ without any problems. Let's now see what we can do to
take more complete control of the Amiga hardware.
First of all, we need to introduce the DMACON, INTENA, ADKCON and INTREQ registers, which
are dedicated to ‘closing’ or ‘opening’ the DMA CHANNELS, as well as
enabling interrupts and other things. For now, in the listings we have assumed
that COPPER, BITPLANES and SPRITES are enabled, in fact
we can see both the ASMONE (BITPLANE) texts and menus and the mouse pointer arrow
(SPRITE). This means that these channels are enabled.
However, it is best to change the status of these registers yourself to
make sure that the channels we are interested in are enabled, and that those we
are not interested in are not. As we did for the copperlists, we just need to
save the status of these registers at the beginning, then run our code
that enables and disables them at will, and finally reset the registers to their
initial state, as if nothing had happened.
But first, let's see what these DMA channels are.
DMA stands for ‘Direct Memory Access’.
In fact, in the Amiga, memory access is very complex, since it must be accessed
not only by the processor, but also by the copper to display images,
the blitter to copy and move them, and the audio to play them. To prevent
‘accidents’ from happening to all these processors that want to get their hands
on the memory (at least the CHIP memory) all at the same time, a
system of ‘traffic lights’ and viaducts has been put in place, which could be described as urban planning and
traffic management. In fact, the AGNUS chip has a DMA channel manager, the
which coordinates operations, allowing the custom chips and the 68000 to access the
memory “in turn” when the channel is free. This access can be either
read or write (the copper READS the copperlists, the audio READS the
music, but the blitter also WRITES the images, and so on).
There are various DMA channels, each dedicated to a particular purpose. Let's take a look at them:

1) DMA COPPER:     Through this channel, the copper reads the COPPERLIST.
If it is disabled, the copperlist is no longer read,
and as a result, both the bitplanes and sprites disappear,
as well as any shades created by modifying the background colour
several times by placing WAITs in the copperlist.
In practice, the screen remains a solid colour, the colour
COLOR0. In this case, you can change the colour of the
screen only with the processor, with ‘MOVE.W #xxx,$dff180’.

2) DMA SPRITE:     This channel transfers the sprite structures
pointed to in the SPRxPT registers in the copperlist.
However, we have already seen how it is possible to display
sprites by writing directly to the SPRxDAT registers, doing
the DMA work manually. By disabling only the
DMA SPRITE channel, the sprites disappear as if they were pointed
to zero, and the bitplanes and shades obtained with the WAIT and MOVE commands of the copperlist remain on the screen. Note that
if DMA BITPLANE is disabled, even if DMA
SPRITE is enabled, the sprites disappear.
3) DMA BITPLANE:

3) DMA BITPLANE: Disabling this channel causes the bitplanes pointed to in BPLxPT
are no longer displayed. However, if
the copper DMA channel is active, any gradients
created with COLOR0 are displayed. Turning off this
channel is equivalent to setting ZERO bitplanes in BPLCON0,
i.e. ‘dc.w $100,$200’ in the copperlist.
Note that if DMA BITPLANE is disabled, the
sprites disappear along with the bitplanes, even if the
DMA SPRITE channel is active. This also happened when we put
zero bitplanes in BPLCON0.

4) DMA DISK:     Used to transfer data from the drive to the
CHIP during reading or writing.

5) DMA AUDIO1     These are 4 separate channels that control the 4 stereo voices
DMA AUDIO2     of the Amiga. For example, to emit a sound from
DMA AUDIO3     voice 1, you need to open the DMA AUDIO1 channel, and to mute
DMA AUDIO4     mute that channel, simply close the DMA channel. Obviously,
 the 4 channels are always closed when the Amiga is silent, for example
when using WorkBench without background music.

6) DMA BLITTER: This DMA handles read and write access to the blitter.
We will analyse the blitter's DMA channels in the
lesson dedicated to this processor.

But how is memory access time divided between the processor and
the custom chips? It depends a lot on the video resolution and which channels are
enabled. Basically, the fewer channels are turned on, the faster the 68000 and
the other CHIPS in operation will be.
Let's look at the relationship between video resolution and DMA: the video image is made up
of raster lines, i.e. lines drawn by the electronic brush, which is
called, precisely, a raster. 
We already know how to wait for a given vertical line
by reading $dff006 (VHPOSR), or with the copperlist via a WAIT.
Well, in each raster line, 227.5 memory accesses are possible, and the
DMA uses only 225. A memory access cycle, if you are interested,
lasts 0.00000028131 seconds on a 320x256 PAL screen at 50Hz.
Since the 68000 would not have time to access the memory every
BUS cycle, it is only allowed access during even cycles,
 therefore 113 times per raster line. 
The problem is that the Blitter and Copper can also
access during even cycles, stealing cycles from the poor 68000.
Odd cycles are used by the DMA manager for AUDIO,
DISK, and SPRITE accesses.
In summary, there are 227/228 cycles per raster line, divided into even and
odd cycles. In the 113 odd cycles, only
AUDIO, DISK, and SPRITE can access the CHIP memory, in turn. In the 113 even cycles,
the IL BLITTER, COPPER and 68000 can access the memory in turn, but the poor
68000 has low priority.
You will understand that if the DMA blitter is disabled, the 68000 will be able to access the
memory more often, as it has more even cycles available.
Consider that the copper DMA has priority over the BLITTER DMA, which in turn
has priority over the 68000, which would do better to work in FAST RAM.
In fact, if the code that the 68000 is executing is in FAST RAM instead of
CHIP RAM, the processor does not suffer the slightest slowdown. This is why
it is better to put the code in fast RAM with SECTION CODES.
Let's take an example: if the copper were occupying the bus, both the blitter
and the 68000 would have to wait for the next even cycle. The problem is
that, while with a resolution of 320x256 LOWRES at 6 bitplanes, the 68000 must
allow ‘only’ half of the cycles equal to the copper to display the 6
bitplanes, totalling 56 per line, in the case of a 640x256 HIRES at 16
colours, i.e. 4 bitplanes, the copper ‘steals’ almost all the even cycles from the 68000,
as a result, the program slows down (if there is no FAST RAM on the computer).
DMA accesses during the raster line follow a precise pattern: we have
seen that the even cycles are divided between the COPPER, the BLITTER and the 68000.
In the case of odd cycles, accesses for DISK, AUDIO, SPRITE and BITPLANE
follow this order: from horizontal line $7 to $c, accesses
to DISK DMA occur, from line $D to $14 those to AUDIO, from $15 to $34 those
to SPRITE, and finally from $35 to $e0 for BITPLANE.
Let's summarise:

- MAP OF DMA ACCESSES IN EACH RASTER LINE - 

EVEN CYCLES: There are 113, divided between Copper, Blitter and 68000, where
the copper has the highest priority, so if we are in a
high resolution, e.g. 640x256 at 4 bitplanes, the 68000
can almost never access the memory, causing a very noticeable slowdown
. Theonly remedy is to place the code in fast RAM,
so there are no slowdowns to the processor. Among other things, in
68020 and higher processors, code in fast RAM is always
much faster than code in CHIP RAM.

ODD CYCLES: There are 113 of these, and they are divided between Audio, Disk and Sprite in this
order:
horizontal line:

$07 - $0C    Access to DISK DMA
$0d - $14    Access to the 4 AUDIO DMA channels
$15 - $34    Access to the 8 SPRITE DMA channels
$35 - $e0    Access to bitplanes in memory


In reality, for programming purposes, it is not necessary to know these technical details,
 but they can help you understand how important it is to economise on DMA channels
in order to achieve maximum operating speed.
For example, if in your production you have a screen in HAM or HIRES
at the top of the screen, while below you are running other things in low
resolution, consider that for the period from the first line to the end of the
“demanding” screen such as DMA (e.g. 16-colour HIRES), both the processor and
the blitter will slow down and may not be able to complete the task in the time remaining
under the image. To gain speed, you could first activate the
16 colours only where they are actually needed, for example:


----------- start of screen, BPLCON0 set to 16 colours HIRES
\ BLACK space
/
*** ###*** ##***## ##** ##* #* # # # *#*# ### * ***#*##
*** ###*** ##***## ##** ##* #* # # # *#*# ### * ***#*## > FIGURE
*** ###*** ##***## ##** ##* #* # # *#*# ### * ***#*##
\ BLACK space
/
----- bplcon0 set for lower resolution

**
**    > ROTATING 3D BALLS AND CUBS
**
----- black space


----- end of screen, dc.w $ffff,$fffe

In this case, you see the log of a copperlist. Let's assume that the
3D routine below the figure is just a little bit short of being executed in time
for the fiftieth frame. Just change the copperlist slightly and the routine
could run at one frame per second. Let's see what to do:

COPPERLIST
dc.w    $100,$200    ; 0 bitplanes in the initial ‘BLACK’ area
dc.w    $3507,$fffe    ; wait for the line where the figure begins
dc.w    $100,$c200	; activate 16-colour hires
dc.w    $a007,$ffe    ; wait for the line where the figure ends
dc.w    $100,$200    ; 0 bitplanes in the BLACK area below the pic
dc.w    $b007,$fffe    ; wait for the end of the black area
dc.w    $100,$3200	; 3 lowres bitplanes for vector routine
dc.w    $e007,$fffe    ; no figures arrive below this line
dc.w    $100,$200    ; so let's turn off the BITPLANE dma
;    and maybe do some shading with COLOR0 and WAIT,
;    to fill the lower part of the monitor without using
;	the DMA
dc.w    $ffff,$fffe


To exaggerate, we could also narrow the video window where the figures
do not fill the entire screen horizontally. Let's take this case:
we have a 3D solid rotating in the centre of the screen, and we have already closed
the dma bitplane above and below it:

---------- start of screen, dc.w $100,$200



---------------- /\    ---- start of solid, dc.w $100,$3200
/ |\
/ | \
/ | \
\___|__/
--------------------------- end of solid, dc.w $100,$200

------------- end of screen, dc.w $ffff,$fffe


As you can see, the solid rotates in the centre of the screen and never occupies
the extreme right and left areas of the screen. At this point,
we could also act on DIWStrt and DIWStop to “close” the screen a little,
making it only as wide as necessary, then we could “widen” it as much as needed
for any wider drawings above or below it:


dc.w    $8E,$2c81    ; DiwStrt WIDE normal for wide figure
dc.w    $90,$2cc1    ; DiwStop WIDE normal

WAIT

dc.w    $8E,$2c91    ; DiwStrt restricted in the solid area
dc.w    $90,$2cb1    ; DiwStop


In fact, by restricting the video window, we save DMA time, since the
bitplane transfer only takes place in the area inside the defined video window
.

Let's close this parenthesis and see how to open and close these channels.
In the Amiga there is a hardware register ($dff096), called DMACon
(=DMA Controller), which manages the activation of each individual DMA channel.
The DMAConW ($dff096) is only used to WRITE any changes, while the
DMAConR ($dff002) is used only to READ the various bits.
Here is the map of the two registers $dff096 and $dff002: (identical but one for reading and
one for writing). The register is BITMAPPED like $dff100 (BPLCON0)
so it counts which bits are on or off, individually:

(NOTE: bits 13 and 14 are read-only (R), 15 is write-only (W))

DMACON ($dff096/$dff002)

bit- 15 DMA Set/Clear		(W)    (can only be written from $dff096)
14 BlitBusy (or BlitDone)    (R)    (can only be read from $dff002)
13 Blit Zero        (R)    (read-only)
12 X            (not used)
11 X            (not used)
10    BlitterNasty (BlitPri) (R/W)    (R/W = Both readable and writable)
9    Master    (DmaEnable)    (R/W) - ‘general switch’
8    DMA BitPlane (RASTER)    (R/W) - also called BPLEN
7 Copper DMA        (R/W) - also called COPEN
6 Blitter DMA        (R/W) - also known as BLTEN
5 Sprite DMA    (R/W) - also known as SPREN
4 Disk DMA        (R/W) - also known as DSKEN
3 Audio3 DMA (voice 4)    (R/W) - i.e. AUD3EN
2 Audio2 DMA (item 3)    (R/W) - i.e. AUD2EN
1 Audio1 DMA (item 2)    (R/W) - i.e. AUD1EN
0 Audio0 DMA (item 1)    (R/W) - i.e. AUD0EN

*SET/CLR
-Bit 15 is very important: if it is on, then the bits set to 1 in
write mode in $96 are used to turn on the corresponding DMAs; if bit 15 is 0,
then the other bits set to 1 in the register are used to turn off the corresponding channels.
Let me explain: to turn one or more channels on or off, you must
set the corresponding bits to 1; what determines whether those
channels should be turned off or on is bit 15: if it is 1, they turn on,
while if it is 0, they turn off (always regardless of their previous state).
Let's say you choose which ones to OPERATE on, then you decide whether to turn them off (0) or
turn them on(1) based on bit 15.
Let's take an example:
;5432109876543210
move.w #%1000000111000000,$dff096    ; bits 6, 7 and 8 are ON
;5432109876543210
move.w #%0000000100100000,$dff096    ; bits 5 and 8 are OFF.


N.B.: BITS 14-10 RELATE TO THE BLITTER AND THE CHIP CLOCK CYCLES,
A TOPIC THAT WILL BE DISCUSSED IN DETAIL LATER.
THEY WILL NOT BE USED IN THIS LESSON.

*BlitBusy
-Bit 14 is read-only (it can ONLY be read from $dff002), and is used to
know if the blitter is ‘blitting’ (i.e. working) at that moment.
This bit is used to know if the blitter is working or not,
in fact, as we will explain later in the course, it is not possible to modify the
blitter registers while it is still blitting... actually, it is possible, but
it would be disastrous! Therefore, you must wait for this bit to be 0 with
a btst before reusing the blitter.

*Blit Zero
-Bit 13 is only set when the result of a blit is 0, i.e.
when the RAM modified by any blit has been completely
set to 0. This can occur in many situations, although it is useful
to read this bit only in rare circumstances (e.g., to check
if two objects -bob- collide without modifying the RAM), but we will go into more detail
later.

-Bits 12-11 are not used by the machine at this time.

*BlitPri
-Bit 10, if set, causes the blitter to use all available chip bus cycles,
 even “stealing” the few that are available to the
poor 68000. If this accesses the Fast or ROM, it will not be slowed down,
otherwise it will even be stopped from accessing the Chip.
In practice, when this bit is set to 1, the blitter has full, rather than
complete, priority over the 680x0

*DmaEn/Master
-Bit 9 is the general switch: it must be set to 1 to
enable the DMA of the various devices. It can be turned off, for example, to
temporarily disable all channels without resetting
the entire register.

-Bits 8-0 are used to turn the DMA channels of the various devices on/off.

Essentially, only bits 10-0 are switchable (interchangeable) using bit 15.
For example, let's now try to turn on only the DMA of the planes, copper and
blitter. To do this, you first need to reset the register to
turn off all channels, thus disabling any unwanted DMA;
then set the desired DMAs:

move.w    #$7fff,$dff096            ; $7fff = %0111111111111111
; i.e.: everything off: the
; bit 15 is ZERO, so
; all 1s mean
; in this case OFF.
; 5432109876543210
move.w    #%1000001111000000,$dff096    ; bits 6,7,8,9 set, i.e.
; BLITTER,COPPER,BITPLANE
; and general switch
; bit 15 to 1, therefore all
; the 1s mean TURN ON

The value $7fff is %0111111111111111, therefore all DMA bits are reset.
Then the DMA of the Copper, Plane and blitter are set, plus the
master, thanks to bit 15 set to 1!

THE OPERATION OF THIS VERY IMPORTANT REGISTER IS SIMILAR TO THAT OF THE
“INTENà AND 'INTREQ” REGISTERS, SO DO NOT CONTINUE UNTIL YOU ARE
CLEAR ABOUT THE FUNCTION OF BIT 15 AS AN ‘ON/OFF’ BIT.

In the listings we have seen so far, the registers
$dff096 (DMACON) and $dff002 (DMACONR) registers have never been used, because we assumed that
the DMA channels of the copper, bitplanes and sprites were enabled.
In fact, if you can see the
asm screen when the program is running, it means that both the COPPER and BITPLANE DMAs are
enabled. The presence of the pointer arrow indicates that it is displayed
with the SPRITE DMA. But when programming at the hardware level, you can't make
compromises, you can't ‘hope’ that everything will be as you want it to be. We have already
seen how important it is to set ALL the copperlist registers such as
BPL1MOD,
 DIWSTART/STOP, etc., to avoid finding them with strange values. 
We will do the same with the DMA channels: we will save their status at the beginning
of startup, then turn them all off and turn on only the desired ones,
and finally put the DMA channels back to their initial state, just as
we do for the copperlist.
We said that to read the status of the DMACON, we need to read from DMACONR,
i.e. $dff002. A "save" routine could be:

move.w    $dff002,OLDDMA    ; DMACONR - save the DMA status

Now we can change it as we wish by acting on $dff096, the register for
writing:

move.w    #$7fff,$dff096    ; DMACON - reset all channels

; 5432109876543210
move.w    #%1000001110100000,$dff096 ; Enable Copper, Bitplane and Sprite

Nothing could be easier. Now we have to put the old value back in place before
exiting. But BE CAREFUL! We cannot put OLDDMA directly in
DMACON ($dff096) as we read it from DMACONR ($dff002), because
bit 15, the SET/CLR bit, is write-only and always reads as zero,
so if we put the value back with bit 15 set to zero, the bits would be turned off instead of
turning on the DMA channels. Therefore, we first need to
set bit 15 of the value saved in OLDDMA, so that the bits
set would be turned ON. But how do we set bit 15 of a
word? There are countless ways. One would be to use the BSET instruction,
for example:

move.w    $dff002,d0    ; Save DMACONR in d0
bset.l    #15,d0        ; Set bit 15 (SET/CLR)
move.w    d0,OLDDMA    ; and save the value in OLDDMA
...
bsr.w    routines
...
move.w    #$7fff,$dff096        ; reset all channels
move.w    OLDDMA(PC),$dff096    ; reactivate only those that were
rts                ; active at the beginning.

Otherwise, you can use the OR instruction. Let's recall its effect on bits:

0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1

The previous example would become:

or.w    #$8000,OLDDMA    ; $8000 = %1000000000000000, i.e. bit 15 to 1

As you can see from the table above, the bits that are reset leave the destination unchanged.
 In this case, the first 14 bits are reset, so the first 14
bits of OLDDMA remain unchanged after the OR (0 OR 0=0, 0 OR 1=1).
Since bit 15 is set, we have 1 OR 0=1, so
bit 15 is set and the other 14 bits remain unchanged. The same as with BTST #15,d0.
In startup, it is best to use OR, because other registers
are also saved in addition to DMACON. These are INTENA ($dff09a in write and $dff01c in
read), INTREQ ($dff09c in write and $dff01e in read) and ADKCON ($dff09e
in write and $dff010 in read). For now, I can only tell you that these
registers are botmapped like DMACON, and work similarly with bit
15 serving as SET/CLR. INTENA and INTREQ are used for interrupts, while
ADKCON is used for various tasks for the DISK DRIVE and AUDIO. We will see how to use these
registers when we discuss interrupts and audio. For now, let's save
their status together with DMACON. Now let's see how to save these 4 registers:

LEA    $DFF000,A5        ; Base of CUSTOM registers for Offsets
MOVE.W    $2(A5),OLDDMA        ; DMACONR - Saves the status of the DMA
MOVE.W    $1C(A5),OLDINTENA    ; Saves the old status of INTENA
MOVE.W    $10(A5),OLDADKCON    ; Saves the old status of ADKCON
MOVE.W	$1E(A5),OLDINTREQ    ; Save the old status of INTREQ

Now we need to set bit 15 of all 4 words marked by the
labels OLDDMA,OLDINTENA,OLDADKCON,OLDINTREQ, in order to restore the value
at the exit. Note that the 4 labels are placed consecutively:

OLDDMA:            ; Old DMACON status
dc.w    0
OLDINTENA:        ; Old INTENA status
dc.w    0
OLDADKCON:        ; Old ADKCON status
DC.W    0
OLDINTREQ:        ; Old INTREQ status
DC.W    0

This is where OR comes into play. If an OR.w #$8000,dest is sufficient for one word,
we can fix two words with a single OR, using OR.L #$80008000,dest!!!
In this case, a couple of these ORs are sufficient for four words:

MOVE.L	#$80008000,d0        ; Prepare the high bit mask
; to be set in the words where
; the registers were saved
OR.L    d0,OLDDMA    ; Set bit 15 of all saved values
OR.L    d0,OLDADKCON    ; of the hardware registers, essential for
; putting these values back into the registers.

With just a few instructions, we have saved and ‘set’ all 4 registers,
 which we will reset immediately afterwards:

MOVE.L    #$7FFF7FFF,$9A(a5)    ; DISABLE INTERRUPTS & INTREQS
MOVE.L    #0,$144(A5)		; SPR0DAT - kill the pointer!
MOVE.W    #$7FFF,$96(a5)        ; DISABLE DMA

At this point, we can enable only the DMA channels we need.
When exiting, simply reset all registers and restore them:

MOVE.W    #$7FFF,$96(A5)		; DISABLE ALL DMA
MOVE.L    #$7FFF7FFF,$9A(A5)    ; DISABLE INTERRUPTS & INTREQS
MOVE.W    #$7fff,$9E(a5)        ; Disable ADKCON bits
MOVE.W    OLDADKCON(PC),$9E(A5)    ; ADKCON 
MOVE.W    OLDDMA(PC),$96(A5)    ; Restore the old DMA status
MOVE.W    OLDINTENA(PC),$9A(A5)    ; INTENA STATUS
MOVE.W    OLDINTREQ(PC),$9C(A5)    ; INTREQ

Nothing could be simpler! Now we have complete control of the DMA channels, and
we are sure that we can enable and disable them as we please, since
they are reset at the exit.

To finish our startup, we could define an EQUATE. Remember what
EQUATES are? They are the EQU or = assembler directives, which define equalities
between arbitrary words and numbers, e.g.:

DOG    EQU    10
CAT    EQU    20

MOVE.L	#DOG,d0    ; is assembled as MOVE.L #10,d0
MOVE.L    #CAT,d1    ; assembled as MOVE.L #20,d1
ADD.L    d0,d1        ; RESULT = 30
rts

Equates are similar to labels, but do not end with :. Instead of EQU,
 you can use the equal sign (=):

DOG    =    10

We could define an EQU for the DMA channels to be set:

;5432109876543210
DMASET    EQU    %1000001110000000    ; copper and bitplane DMA enabled
;         -----a-bcdefghij

;    a: Blitter Nasty (Not important for now, leave it at zero)
;    b: Bitplane DMA     (If not set, sprites will also disappear)
;	c: Copper DMA     (If set to zero, the copperlist is not executed either)
;    d: Blitter DMA     (Not relevant for now, let's set it to zero)
;    e: Sprite DMA     (If set to zero, only the 8 sprites disappear)
;    f: Disk DMA     (Not relevant for now, let's set it to zero)
;	g-j: Audio 3-0 DMA (Let's reset them, leaving the Amiga silent)

As you can see, bits 15 and 9 must ALWAYS be SET, since one is the
SET/CLR and the other is the Master, the general switch.
In the listing you can put:

MOVE.W    #DMASET,$96(a5)        ; DMACON - enables bitplane and copper

This way, at the beginning of the listing, we have the EQU to be modified with
a brief summary below explaining the meaning of the bits.

But let's look at the startup. Load Lesson8a.s into a text buffer and study it.
The final comment contains some notes on certain minor changes.

· ·
¦ . .__ :
: ·^·¯¯\ __¡__
_ _|__ _______ ____________ /\ \______________ _________ ____\ //____ _
¯ ¯|¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯\/ \ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯\//¯¯¯¯¯ ¯
: _ø , \__. . ¦
¦ //\/ ¯¯·^· /\__. . :
· '/\ / ¯¯·^· :
_ _|___ ____________/ /_____ _________ / /\________ ______ ____|______ _
¯ ¯|¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯\/ / ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯|¯¯¯¯¯¯ ¯
¦ . . .__ / ·
: ‘COi! Ðe$¦gN’ ·^·¯¯\/ :
.
 ·
· .
.

Now that we have the ‘universal’ startup, we can also put it aside in
a file and include it at the beginning of the next listings using the
INCLUDE directive, which we have already used to include the music routine.
Just start each listing with:

Section    UsoLaStartUp,CODE

*****************************************************************************
include    ‘startup1.s’    ; with this include, I don't have to
; rewrite it every time!
*****************************************************************************

Note that Startup1.s is the startup without the SECTION, so we must
put the SECTION name,CODE or CODE_C directive each time before the include.
The Startup does a ‘BSR.S START’, so we will start the listing with:

START:
MOVE.W	#DMASET,$96(a5)        ; DMACON - enables bitplane, copper
; and sprites.

move.l    #COPPERLIST,$80(a5)    ; Point our COP
move.w    d0,$88(a5)        ; Start the COP
move.w    #0,$1fc(a5)        ; Disable AGA
move.w    #$c00,$106(a5)        ; Disable AGA
move.w    #$11,$10c(a5)        ; Disable AGA

Note that $dff000 is present in a5. In this case, I took advantage of it.

It would seem like a perfect startup, but it still needs the icing on the cake.
This icing is the ability to launch the program from the
WorkBench icon without any problems. In fact, as long as we start from cli/shell
our programs, this startup is sufficient, but if we want to draw
icons to launch them from WorkBench with a double click of the mouse, we need to
add a few instructions. It's just a bureaucratic formality, but if you don't
do it with large programs, which also allocate memory, it can happen that
when you exit, not all the memory is freed, or even worse.
Here is what you need to add at the beginning:

ICONSTARTUP:
MOVEM.L    D0/A0-A1/A4/A6,-(SP)    ; save the registers in the stack
SUBA.L    A1,A1
MOVEA.L    4.w,A6
JSR    -$126(A6)    ; _LVOFindTask(a6)
MOVEA.L    D0,A4
TST.L    $AC(A4)        ; pr_CLI(a4) are we running from the CLI?
BNE.S    FROMCLI        ; if so, skip the formalities
LEA    $5C(A4),A0    ; pr_MsgPort
MOVEA.L    4.W,A6        ; Execbase in a6
JSR    -$180(A6)    ; _LVOWaitPort
LEA    $5C(A4),A0    ; pr_MsgPort
JSR    -$174(A6)	; _LVOGetMsg
LEA    RETURNMSG(PC),A0
MOVE.L    D0,(A0)
FROMCLI:
MOVEM.L    (SP)+,D0/A0-A1/A4/A6    ; restore registers from stack
BSR.w    MAINCODE    ; run our programme
MOVEM.L    D0/A6,-(SP)
LEA    RETURNMSG(PC),A6
TST.L    (A6)        ; Did we start from CLI?
BEQ.S    ExitToDos    ; if so, skip the formalities
MOVEA.L    4.w,A6
JSR    -$84(A6)    ; _LVOForbid - note! No permit needed
MOVEA.L    RETURNMSG(PC),A1
JSR    -$17A(A6)    ; _LVOReplyMsg
ExitToDos:
MOVEM.L    (SP)+,D0/A6        ; exit code
MOVEQ    #0,d0
RTS

RETURNMSG:
dc.l    0

I won't comment in depth on the calls to the operating system libraries
; suffice it to say that these are the formalities I was referring to.
If you run a program from Workbench that does not have this code at the beginning,
the biggest problem is that when you exit the program,
the memory it occupied is not freed!
!!
As you can see, at the beginning, the program checks whether it has been run
from the CLI or from WorkBench by checking a special system flag.
If the program has been launched from the CLI, the formalities to be followed
in case of execution from WB are skipped. Otherwise, these formalities are performed.
Instead of merging this piece with the other startup, it is better to keep it separate
so that you can choose whether or not to include it, since some assemblers, including
the modified ASMONE version of the course, cause
an infinite loop at runtime, since it "
it would appear‘ to be loaded from WorkBench, but then, when the ’formalities" are executed, it would appear to be the opposite. Other
versions of Asmone or other assemblers execute this code without any problems,
 but for compatibility with all assemblers, it is preferable to put it
as

;    Include    ‘DaWorkBench.s’    ; remove the ; before saving with ‘WO’

This way, during assembly and testing with “J” we do not include it,
while before saving the final executable with ‘WO’ we do include it.

Load Lesson8b.s, the first listing that uses the universal startup
included with INCLUDE. It includes the use of both bitplanes and sprites,
so you can test to see whether the
DMA channels are enabled or not.
__ __ __ __ __ __ __ __
/\_/_/\__ __ / /\__ __ / /\ /\ \ __ __/\ \ __ __/\_\_/\
/ / \_\/_/\_/_/\_/_/ / /\_/_/\_/_/ \_/ \_\_/\_\_/\ \ \_\_/\_\_/\_\/_/ \ \_
\/ \_\/ \_\/ \_\/_/ / \_\/ \ \ / \ / / \/_/ \ \_\/_/ \/_/ \/_/ \/_
-:-----:------------\_\/--------\_\/---\/_/--------\/_/---------------------

Are you scared by the NEW routine waiting for the vertical line?
Well, there's nothing scary about it, in fact it's much better.
Let's analyse the old ‘routine’:

cmp.b    #$xx,$dff006    ; VHPOSR

Well, all we do is check the byte $dff006, which contains the vertical position
of the electronic brush, bits 0 to 7, i.e. from $00 to $ff.
But as you know from managing WAIT in copperlist, the electronic brush
goes beyond the $FF line, which is actually just 200 on a normal screen.
To reach positions beyond $FF with COPPER WAIT, we have seen
that we have to wait for the end of that zone:

dc.w    $FFDF,$FFFE	; wait for the NTSC zone limit

After that, the counter restarts from $00

dc.w    $0007,$FFFE    ; wait for line $100
dc.w    $0107,$FFFE    ; wait for line $FF+$01=$101

Up to $38. Well, the byte in $dff006 also behaves in this way: once it reaches position $ff, it restarts from $00, indicating $100, and
continues up to $138 (with $38), after which it restarts from $00, the true ZERO, to
then arrive again at $ff, to do the other $38, and so on.
This is why in the listings we always wait for the $FF line, or the $80 line, because
waiting for the $00 line or the $20 line with $dff006 would mean executing
the routine twice per frame, as $00 occurs at line $00
and at line $100.
But then, how can we wait patiently for the first 38 lines and the
lines after $ff? In short, we need a routine that waits without errors for
any of the 312 lines of the scan.
This is not difficult, since the HIGH bit, the eighth, is very close to
$dff006, exactly at $dff005, the byte before.
We have to do as we did with the vertical position of the sprites,
in fact we have the high bit separately.
In this case, however, it is not located somewhere in the memory, but right before
the byte in question. Let's analyse the situation:


$dff004 byte, which is not of interest to us now, contains the LOF bit for the interlace
$dff005 is of interest to us! Bit 0 is V8, i.e. the high bit of the vertical position.
$dff006 we already know! Bits V7-V0, the 8 low bits of the vertical position.
$dff007 contains the horizontal position (H8-H1). The resolution is 1/160
of the screen. We don't care about this at all!

$dff004/$dff005 is the VPOSR register, while $dff006/$dff007 is the VHPOSR
each register is in fact one WORD long. However, we can access them as
single bytes in certain cases. To wait for line $100, we can do this:

WaitVbl:
btst.b    #0,$dff005
beq.s    WaitVbl

This routine waits for the high bit, V8, to be set. If it is set,
 it means that we are at line $100, or in any case after it.
To create a UNIVERSAL routine, we can do the following: (a5=$dff000)

Waity1:
MOVE.L    4(A5),D0    ; $dff004 and $dff006, i.e. VPOSR and VHPOSR
LSR.L	#8,D0        ; move the bits 8 positions to the right
AND.W    #%111111111,D0    ; Select only the bits of the vertical position
CMP.W    #300,D0        ; line 300? ($12c)
bne.s    Waity1

In this case, we have copied $dff004/5/6/7 into d0, then we move everything
8 bits to the right, since the first 8 bits on the right are occupied by the
horizontal position of $dff007, which we are not interested in, bringing the
vertical position to the far right. At this point, with an AND, we select only
the first 8 bits, i.e. those of $dff006 plus the highest bit of $dff005.
In this way, we have the actual line number from 0 to 312 in d0!
Remember that the AND command has this effect:

0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1

In fact, AND only returns 1 when both the bit of the first operand
and that of the second operand are 1. The command could be translated as
"ARE BOTH THE FIRST AND SECOND BITS 1? IF YES, I RESPOND WITH 1, IF NO
RESPONSE WITH A ZERO". An AND is useful for clearing certain bits
of a number. In our case, we have cleared the high bits:

AND.W    #%0000000000000000000000111111111,d0

Perhaps it is clearer in hexadecimal:

AND.W    #$000001FF,D0    ; only the low byte plus bit 8.

The only drawback is that it requires 4 instructions. Let's write a
routine that uses only 3:

WBLANNY:
MOVE.L    4(A5),D0    ; VPOSR and VHPOSR - $dff004/$dff006
AND.L    #$0001FF00,D0    ; Select only the bits of the vertical position
CMP.L    #$00013000,D0    ; wait line $130 (304)
BNE.S    WBLANNY

In this case, we work on the entire long without shifting the bits.
Just remember that the line number to wait for is shifted 2 digits
to the left. For example, to wait for line $FF:

CMP.L    #$0000ff00,D0    ; wait line $130 (304)

is definitely better and faster. I recommend always using this
routine. Otherwise, if you don't mind ‘dirtying’ a couple of extra registers,
 there is a turbo version in Lesson 8b.s:


MOVE.L    #$1ff00,d1    ; bit for selection via AND
MOVE.L	#$13000,d2    ; line to wait for = $130, i.e. 304
Waity1:
MOVE.L    4(A5),D0    ; VPOSR and VHPOSR - $dff004/$dff006
ANDI.L    D1,D0        ; Select only the bits of the vertical position
CMPI.L    D2,D0        ; wait for line $130 (304)
BNE.S    Waity1

As you can see, nothing really changes, except that the operations are performed
between registers instead of between constants, which is faster.
Speed is important because, for example, if you make line 50 wait
with the first routine we saw, which also has LSR, when the processor
has finished all the tests and realised that we are at line 50, we are now
halfway through line 50!

I would just advise you to make sure that in a5 or a6, depending on the
register you are using as a base, there is always $dff000, i.e. that it is not
overwritten by any subroutine. To avoid this, you can save the registers
with MOVEM as explained above, or you can put a LEA $dff000,a5 under
the "MOVE.L #$1ff00,d1". The same applies to registers d0, d1 and d2, you must
make sure that they are not in use by other programs, as you are modifying them.

Finally, never wait beyond line $138, as this is the last line,
or the routine will get stuck in an infinite loop.

If the video is set to NTSC frequency (by clearing $dff1dc), the maximum limit
is line $106.

ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ
ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ
ØØØØ ÍØØØØ
ØØØØ ___ ÍØØØØ
ØØØØ __øØ@**#__ ____ææææ_ [ØØØØ
ØØØØ gØ°¯ °4æ_ __øØ@¤°¨¯¯¯¯¶& ÌØØØØ
ØØØØ ,ØP ¬0þ¸ ,gØ¤°¯ 0Q [ØØØØ
ØØØØ Ø~ _______ °Ø_ _Ø° ___ææØØØ, ÌØØØØ
ØØØØ ØØØØØØØØm_ °Ø_ _ ,_/Ø´ _æØØØØØØØØ
ØØØØ°°¤ØØØØØØØQ__ °#_Ø IØÞ _ÆØØØØØØØ@° ÍØØØØ ØØØØ _ `ØØØØØ
ØØØØ °°¤ØØØØØØØQ__ °#_Ø IØÞ _ÆØØØØØØØ@° ÍØØØØ
ØØØØ _ `ØØØØØØØØæ_ ¬¢² dØØØÑØØØØ³ ]ØØØØ
ØØØØ `Øæ¸ ØØØ1 "¢ØØØQ__ ÆØØØ´ ¶ØØØ¸ ÌØØØØ
ØØØØ VØ#_ #ØØò (æ °ØØØØø ØØØ° æ) ¶ØØ# ,® ]ØØØØ
ØØØØ Ø#Ø_ ¬ØØØQ___ØØØØØØ «ØØØæ__ JØØØ ¸ØF ÍØØØØ
ØØØØ ¬Ø_`N_ ¢ØØØØØØØ²°°¯___¬°0ØØØØØØØØ _Ø° [ØØØØ
ØØØØ °ØµØÑ&_ ¨°°°~ ¸ØØØØØ, ¯~°°°°‘_.øØ¹ ]ØØØØ
ØØØØ #Ø ¬ØQ_ ¬Ø' ¬¤° ___ææØ¤°ØP IØØØØ
ØØØØ `W_ØP4MøææææææææææææØØØ¤°’Ø _Ø° ]ØØØØ
ØØØØ ¬ØØ_ 0F¯¯7#¯¯¯¬Ø¯¯¯¯TØ ØØ@´ ÌØØØØ
ØØØØ ¬#ØØØæ._àW___jØ____jØ_æøØ³ [ØØØØ
ØØØØ ¢#ØF¨°¶Ø^^¤4Ø¤¤°°¢ØØØ^ [ØØØØ
ØØØØ °«N__IN_ Ø___æØ»° [ØØØØ
ØØØØ °^¤*#ØØØØ@¤°" xCz IØØØØ
ØØØØ ÍØØØØ
ØØØØL__________________________________________________IØØØØ
ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ
ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ


Now that we have seen the usefulness of AND/OR/LSR instructions for saving
DMAs and for better control of the VBLANK line, let's look at some new uses
for these logic instructions. It is certainly worth analysing how to create
a fade routine, i.e. fading a figure from black, gradually blending
towards a full, bright colour (and vice versa).
First, let's see where we need to work:

CopColors:
dc.w $180,0,$182,0,$184,0,$186,0
dc.w $188,0,$18a,0,$18c,0,$18e,0
....

In copperlist, where the colour registers are located. What we need to do is
replace those zeros with the correct RGB values (exactly the word: $0RGB),
 “increasing” them so that with several steps, one per frame,
they rise until they reach the colours of our figure:

CopColors:
dc.w $180,$000,$182,$fff,$184,$200,$186,$310
dc.w $188,$410,$18a,$620,$18c,$841,$18e,$a73
...

First, we need to have the list of colours from the figure in a table
to refer to, otherwise we won't know when we've “arrived”:

ColourTablePic:
dc.w $fff,$200,$310,$410,$620,$841,$a73,...
...

(NOTE: colour 0, $dff180, has not been included in this table, since
it is black, $000, it always remains black and we do not include it in the routine.
Instead, we start from colour 1, $dff182, which in this case is $FFF).

To create this table, simply remove $180, $182, and $184 ‘by hand’ from the
copperlist copied with the editor, and the colours will remain.

Now that we have the table with the “destination” colours, how do we create a routine
that ‘increases’ the colours to the correct ones in the table?
We definitely need to work separately for each of the three RGB components,
and to separate them we can use AND, which, as we have seen, ‘selects’ only
a part of the bits, resetting the others. Having the address of the table with the
colours in a0, let's see, for example, how to separate only the blue component:

MOVE.W	(A0),D4        ; Put the colour from the colour table in d4
AND.W    #$00f,D4    ; Select only the blue component ($RGB->$00B)

Now in d4 we only have the value of BLUE... if the colour was $0123, in d4 after
the AND.w #%000000001111,d4 (only the 4 bits, or nibble, are selected), the value
is $0003, so we have succeeded. Let's see how to select the
green component:

AND.W    #$0f0,D4    ; Select only the green component ($RGB->$0G0)

And the red one:

AND.W    #$f00,D4    ; Select only the red component ($RGB->$R00)

So far, everything should be clear.
Now, we could already do the ‘FAKE’ routine, which works like this
: each time, add #1 to each individual component and
compare it with the colour in the table to see if we need to stop adding to
that component. For example, if we have the colour $0235 to achieve,
we will have these steps every frame:

1)    $111	; +$111, all 3
2)    $222    ; +$111, all 3
3)    $233    ; +$011, the RED component is fine, I only add to Gr. and Blue
4)    $234    ; +$001, the RED and GREEN components are fine, +1 only Blue
5)    $235	; +$001, as above, +1 only to blue

Each time we should compare the RED component of the colour in the
table with the one we are “increasing” using a CMP. If we haven't reached it,
add 1; if we have reached it, don't add anything, then do the same with
GREEN and BLUE, finally combine the 3 “resulting” components using one or
more OR instructions, obtaining the resulting colour word to be placed in the
copperlist. And this for each of the 16, 32 colours or however many there are.
The quantity is not a problem for the processor, with DBRA cycles
you can do everything. The only detail is that the system I have described is not
very accurate, and especially in AGA you can see that the colours go their own way
. So, the structure of the routine remains the same, but we have to change
the way we calculate. We must first note one thing: how many frames, or
how many times should we call the routine to perform a complete fade?
If we have the colour $0F3, a nice green, for example, starting from $000 and
adding 1 each time, with the previous routine it would take 15 add.w #$010
for the green component, since it must reach the value $f (15).
So, let's consider creating a “parametric” routine, which can
calculate the colours at one of the 16 possible FADES, where phase 0 is
complete BLACK, and phase 16 is the full colour. Let's suppose we keep “track” of the phase to be done in a label “FaseDelFade”.
 Each time we will have to do:

addq.w    #1,FaseDelFade    ; set the phase to be done next time

So, at the first frame we will do a ‘BSR.s Fade’ with “FaseDelFade” at 1,
and the colours will be very dark, the next frame will call the
routine, but with ‘FaseDelFade’ at 2, and the colours will lighten (2/16 of the
), and finally, when we run it with ‘FaseDelFade’ set to 3, the colours will be
the same as those in the table. When I referred to the fraction, 2 sixteenths
of the colour, I was anticipating the technique to be used! In fact, while a
Fake routine, one of the horrors of fade routines that simply add 1 each time
are not fractionally accurate, what we are going to do is acceptable.
Let's get to the point: with the Fake routine we would have these steps to get
to a $084:

$011
$022
$033
$044
$054
$064
$074
$084

Well, when we get halfway there, we have a GREY! $044!! instead of a light green.
In reality, halfway through, we should have been at $042, i.e. dark green,
which happens to be exactly 1/2 of $084.
Now, here comes the solution: given the value ‘FaseDelFade’,
which we can call MULTIPLIER, when it is 0, we must
 
calculate 0/16 (zero sixteenths) of the colours, i.e. all ZERO.
On the other hand, when it is at 1, we must calculate 1/16 of the colours.
This continues up to 16/16, where the colour remains the same.
How can we implement this formula in instructions? Easy! Using an
isolated RGB component, for example BLUE: (we have the MULTIPLIER in d0)

MOVE.W    (A0),D4        ; Put the colour from the colour table in d4
AND.W    #$00f,D4    ; Select only the blue component ($RGB->$00B)
MULU.W    D0,D4        ; Multiply by the fade phase (0-16)
ASR.W    #4,D4		; shift 4 BITS to the right, i.e. division by 16
AND.W    #$00f,D4    ; Select only the BLUE component
MOVE.W    D4,D5        ; Save the BLUE component in d5

In practice, we multiply the component by the MULTIPLIER, then divide it by
16, in this case dividing by 16 is equivalent to an ASR.W #4,Dx, as we have
already seen for the 8x8 character print routine, where MULU.W #8,Dx can be
replaced by an LSL.w #3,Dx. Think of it as a DIVU.w #16,D4, and everything
makes sense again. Repeating this process three times for the three RGB components, we have
the FADE routine from BLACK to colours, and if we start with the multiplier at 16,
subtracting #1 each time until zero, we will have the opposite fade, from colour
to black. The latter is called FADE OUT, while the former is FADE IN.

We can see how the routine described in the two
lists Lesson8c.s and Lesson8d.s works in practice. The difference between these two lists is
only in theorder in which the division operations of the 3
RGB components are performed, but the principle of multiplication by the multiplier and
division by 16 is the same. The clearest is perhaps that of Lesson8d.s.

The design is a logo of the RAM JAM group, created by FLENDER, who is Italian.
I used this design because I joined this
group just as I was writing this lesson. So, from here
on, the course is a RAM JAM production!!!

Let's continue with a variation on the theme. Load Lesson8e.s. This is the
same routine, with a slight modification consisting of the addition of an
additional dominant component, which gives the design that
tone. It can be useful for giving the whole thing a carnival feel.

Finally, I am going to show you a routine that can change from any colour
to any other! Basically, you need two tables, one with the initial colours,
for example if you start from black, a table with lots of zeros, and another
with the final colours. The result is that to do the first fade, i.e. from black
to normal colours, you have to put a table with all zeros as the first table and
the second one with the colours. To go from the colours to black (FADE OUT),
you need to put the one with the normal colours as the first table and
a blank one as the second.
Now here are the innovations: for example, we can do a fade from
WHITE to normal colours by putting all $FFF as the first table and
the one with the normal colours as the second.
Let's exaggerate: we can switch from one colour to another! Just put
the colours you want at the beginning in the first table, and
the colours you want at the end in the second table. This way, we can switch from a
green tone to a bluish tone, and so on.
Load Lesson8f.s and try the routine, which shows the examples I
have given. As for how the routine works, it is rather
complicated, and I don't feel like reviewing it. If you want to try to understand it, read
my (few) old comments. Anyway, at least learn how to use it for your
own purposes!

,øØØØØØm ¸____
ØV´ ¬ØQ Øþ¤4Ø,
_øæØ#__ .ØF ________ Ø Ø#æØØæ_
.Ø^¨~°¢ØÐ `Ø_ __gøØØØØØØØØØØ#øæ___ Ø& VÞ°~¯°ØL
`Øø_ __ ¬ØØØØØØ»^^°°°°°°¤*0ØØØØØø__ _ÆØ~ _____JØ
¬¢Øæ_øØØø__ØØØ³" ¬~^«ØØØØØP _øØØØØØØ°
°°° °#ØØ/ ¸gæææ___ ¬°#ØØæ_øØ°
ØØP #ØØØØØØØæ_ ___ °4ØØØ¸
_____________ ØØÌ ° _F°ØØØ_ _Æ**Ø®_ "0Ø#_ _____________
\___ ØØ# Ø °¢ØØL ÆØ _ `Øì ¶ØØ_ ___/
T ¶ØØ 0Ø (ø ¬ØØb ØÍ (Ø) Øf ¶ØØ, T
| #Ø#¸ (Ø&____øØ¤° °#¸ _Ø´ ØØQ |
| 0ØØ__ °^¤¤¤°" __ ¬^***³´ ØØV |
| °ØØØæ______ ,ØØ _æØØ' |
| °«ØØØØØØØ ØØØØ ________æØØØ@~ |
| _ØØ~¨ØØP `°°¤* øØØØØØØØØØÞ°¯ |
| _æØØN___ØØ° _ØØ _ 0_¯¯¯¬4Ø_ |
| ,ØØ°¯¯‘0ØØ° ¸øØØ’ _Ø . `Ø_ °Øæ_ _ |
| lØ ^ __ØØØ¹ ,Ø" Æ ØQ ¬Ø, °ØØØØØØ_ |
| ¬Øæ__g# øØ¤~Ø´ Ø° ,Ø ØØ #ØØ__ °¯¯ ¬Ø, xCz |
_ __¦_______¬°^¤ØØ ¶Ø ¸Ø__ÆØ__ØP ØØ ¶ØØ¢Ø_ ____Øf ______¦__ _
: Øò___ØØ #ØØØØØØØØØØøØØæææØØ' ¬4# ØØ¤¤° :.
 ‘¢ØØØ@ ~~¯ ¯¬’°^^¤¤«**ØØ³ lØ ÎØ .
¯ ØL__ÆØ
°**¤°


Now I would like to show you three listings, the work of three ‘students’ who started from
scratch with my course, just like you. Encouraging, isn't it?

LESSON8g.s    - 10-level parallax (by Federico Stango)

LESSON8h.s    - control panel with gadgets (by Michele Giannelli)

LESSON8h2.s    - 8X8 scroll text (by Lorenzo Di Gaetano)

These three listings use only the knowledge from disc 1 of the course.
I only changed the startup, inserting startup1.s in place of the
old way of initialising disc1.
I hope you are also doing some ‘independent’ testing, otherwise what's the point
of reading everything like a novel? Wake up!!!
And if you've done something nice, send it to me, and I'll put it in the
next lessons and you'll become famous like Fiorello.

Let's now move on to a frequently asked question: ‘How do the equalizers
in the small AMIGAET.EXE demo on disc 1 of the course work?’
Well, I've “cut” that piece of listing, you can see how it all works in
lesson8i.s.

Warning: the ‘music.s’ routine on disc 2 is not the same as the one on
disc 1. The two changes are the removal of a bug that sometimes caused
a crash when exiting the programme, and the fact that mt_data is a pointer to the
music, and not THE music. This makes it easier to change the music
to create music discs, as seen in lesson8i2.s.


We have now reached the point where we can make equalizers, but we have not yet seen how to
print a point, i.e. ‘plot a dot’. We will remedy this immediately with Lesson8l.s

(then plot it on different planes from 3d_stars.s)

OK, now that we know how to print points, let's print lots of them next to each other
to make ‘lines’, in Lesson8m.s and Lesson8m2.s

Well, if you can make lines, you can also make parabolic curves,
just multiply X*X, in Lesson8m3.s, Lesson8m4.s, Lesson8m5.s

Now let's see how to ‘optimise’ the point printing routine. As you have
seen, it has a multiplication, which is very bad because multiplications
are slow. How can we “remove” it? We have to multiply by 40, so
we just need to ‘execute’ all the possible multiplications, i.e. the first 256
multiples of 40, and write the results in a table. Now we have in this
table all the ‘results’ of the multiplication in question according to the
various cases. Just make sure that the
correct result is “taken” from the table each time, just as we take the correct X or Y from the
coordinate tables for sprites. Let's see how this works in practice in Lesson8n.s

Let's check whether the new routine is actually faster than the
old one by writing and clearing the entire screen in Lesson8n2.s

Since we have seen how to reset a point (just put a BCLR in place of
the BSET), let's try to ‘animate’ a point as we did for sprites,
writing and deleting it every frame at different positions, in Lesson8n3.s

Try making modified versions, with multiple biplanes, with more than one point
at a time, etc. To print on 2 bitplanes, i.e. 4 colours, you can
do this: colour0 is the background, while we have 3 different colours to plot.
Considering that we have 2 bitplanes with the names ‘Bitplane1’ and ‘Bitplane2’,
you could create 3 routines, one that plots in bitplane1, one that plots in
bitplane2, and one that plots in both bitplanes, and jump to one of
these 3 routines to print in one of the 3 colours.

-- Incredible! Lorenzo di Gaetano quickly wrote his own listing!
Take a look: Lesson8n4.s

I imagine you've written a program that studies mega-complex functions,
drawing waves like the Quark logo. So we can take a short break
to advertise the copper waits, which weren't used for the point routines.
Take a look at what simple waits and color0 can do,
without the help of any bitplanes, in Lesson8o.s
There are no tricks, except that the copperlist is “built” as well as
modified. Here is the routine that “creates” the salient part of the copperlist:

; INITCOPPER creates the part of the copperlist with lots of WAIT and COLOR0 in succession

INITCOPPER:
lea    barcopper,a0    ; Address where to create the copperlist
move.l    #$3001fffe,d1    ; First wait: line $30 - WAIT in d1
move.l    #$01800000,d2	; COLOR0 in d2
move.w #coplines-1,d0    ; number of copper lines
initloop:
move.l    d1,(a0)+	; set WAIT
move.l    d2,(a0)+    ; set COLOR0
add.l    #02000000,d1    ; next wait, wait 2 lines lower
dbra    d0,initloop
rts

As you can see, the result of this routine is to create:

barcopper:
dc.l    $3001fffe    ; wait line $30
dc.l    $01800000	; colour 0
dc.l    $3201fffe    ; wait line $32
dc.l    $01800000    ; colour 0
dc.l    $3401fffe    ; wait line $34
dc.l    $01800000    ; colour 0
....

Think how much space and time we save this way.

________
___---“--------`--..____
,-------------------.============================
(__________________<|_) `--.._______..--”
| | ___,--“ - _ /
| | | |
,--” `--' |
~~~~~~~`-._ | _
`-.______,-“ (ö)
”(_)`
¯ ¯

To conclude the lesson, I think it is appropriate to discuss a feature
of the processor which, despite being very important, has not been
discussed until now. In fact, you THOUGHT you knew enough about the 68000, but in reality
until now it has been studied in a very superficial way, the bare minimum needed to
perform routines. In fact, we haven't mentioned Condition Codes,
and with them the CCR, which is part of the SR (Status Register).
Here are the 16 bits that make up the register:

SR:
___
15    T - TRACE        \
14    - not used by the 68000     |
13    S - SUPERVISOR         |
12    - not used by the 68000     |- SYSTEM BYTE
11    -             |
10    I2 \             |
9    I1 > INTERRUPT MASK     |
8    I0 /         ___/
7    -            \
6    -             |
5    -             |
4    X - EXTENSION         |- USER BYTE (Condition Code Register)
3    N - NEGATIVE         | (contains arithmetic flags)
2    Z - ZERO         |
1    V - OVERFLOW (excess)     |
0    C - CARRY ___/


Well, this mysterious register contains bits relating to condition FLAGS.
 To be precise, its low byte, called CCR (Condition Code
Register), contains these FLAGS. We will discuss the high byte of the SR later,
 when we talk about INTERRUPTS and SUPERVISOR MODE.
For now, I can only tell you that the processor can operate in two modes,
one USER and one SUPERVISOR. Normally, the programs we write
are executed in USER mode. When we need interrupts, we will see how to
switch from Supervisor mode to User mode and vice versa, but remember that some
instructions can only be executed in SUPERVISOR mode. If you try to
execute them in USER mode, everything will go into a deep coma. These instructions are
called PRIVILEGED, so be careful!
For now, it is enough to UNDERSTAND the low byte of the SR, the CCR.
Each instruction, when executed, can affect the flags. For example, if a
subtraction results in a negative result, the N flag is set; if it results in zero,
the Z flag is set; if an addition results in a number larger than
that which can be contained in D0.l, the V bit (overflow) is set, which
indicates that the result cannot be contained in the destination. This
also applies to Carry, which is set in the event of a carry.
You could check the flags themselves by testing the CCR byte, but since the
68000 is the best processor in the world, there are enough instructions
to know the status of the flags: these are Bcc, where cc stands for
Condition Codes and can be replaced with CS, EQ, GE, GT, HI, LE, LS, LT, MI, PL...
Remember that when talking about how CMP instructions work
followed by BEQ and BNE, we explained that BEQ/BNE knew how
the CMP had gone because the result of the CMP was written on a “slip of paper”?
Well, the “slip of paper” where the CMP writes the result for BEQ/BNE is
the CCR, the low byte of SR! In reality, this piece of paper is made up of 
4 bits, plus a fifth, called eXtend, which is used for special purposes.
Using these 4 bits, you can create quite a few ‘situations’, not just
BEQ and BNE, but you can also know if a number is greater or smaller than
another, if two numbers are equal, if there is a carry in an
operation, if the result is negative, etc. Here are all the Bcc:


bhi.s    label    ; > for unsigned numbers
bgt.w    label    ; > for signed numbers
bcc.s    label    ; > also called BHS, Carry = 0 (unsigned)
bge.s    label    ; >= for signed numbers
beq.s    label    ; = for all numbers
bne.w    label    ; >< for all numbers
bls.w    label    ; <= for unsigned numbers
ble.w    label    ; <= for signed numbers
bcs.w    label    ; < for unsigned numbers; also known as BLO,
; means that Carry = 1
blt.w    label    ; < for signed numbers
bpl.w    label    ; If Negative = 0 (PLus)
bmi.s    label    ; If Negative = 1, (Minus) signed numbers
bvc.w    label    ; V=0, no OVERFLOW (result can be contained)
bvs.s    label    ; V=1 OVERFLOW (result too large to
; be contained in the destination)


Now let's see how to use Bcc after CMP.x OP1,OP2

beq.s    label    ; OP2 = OP1 - for all numbers
bne.w    label    ; OP2 >< OP1 - for all numbers
bhi.s    label    ; OP2 > OP1 - without sign
bgt.w    label    ; OP2 > OP1 - with SIGN
bcc.s    label    ; OP2 >= OP1 - without sign, also called *‘BHS’*
bge.s    label    ; OP2 >= OP1 - with SIGN
bls.w    label    ; OP2 <= OP1 - without sign
ble.w    label    ; OP2 <= OP1 - with SIGN
bcs.w    label    ; OP2 < OP1 - without sign, also known as *‘BLO’*
blt.w    label    ; OP2 < OP1 - with SIGN

And now how to use them after a TST.x OP1

beq.s    label    ; OP1 = 0 - for all numbers
bne.w    label    ; OP1 >< 0 - for all numbers
bgt.w    label    ; OP1 > 0 - with SIGN
bpl.s    label    ; OP1 >= 0 - with SIGN (or BGE)
ble.w    label    ; OP1 <= 0 - with SIGN
bmi.w    label    ; OP1 < 0 - with SIGN (or BLT)

As you can see, after a CMP you can find out quite a lot! You can
notice the signs > (greater than), >= (greater than or equal to), =, >< (not equal to),
<= (less than or equal to), < (less than), and what's more, there is a Bcc for these
comparisons for normal numbers, and one for signed numbers (with sign).
As for negative numbers, so far we have only mentioned that,
for example, -1 is $FFFFFFFF, -5 is $FFFFFFFB, establishing more or less that the
high bit, i.e. 31 if we are in longword, 15 if in .w and 7 if in .b, is
the sign bit, i.e. if it is 1, the number is negative, and proceeds as
if it were going “backwards” from $FFFF, which is -1, to $FFFE, which is -2, $FFFD for -3
and so on, until it reaches (in the .w field) $8001, i.e. -32767, followed by
$8000, i.e. -32768, which is the most negative number possible in a word with
sign, and corresponds to %1000000000000000, i.e. the high bit of the sign set
and all the others reset to zero: we started from -1, i.e. %111111111111111.
This system used to obtain negative numbers in binary is called two's complement.
 We already know that the most significant bit, i.e. the one on the far left,
 represents the sign: if = 0 it is positive, if = 1 it is negative.
This system applies to both .byte numbers (the bit is 7) and
.word (the bit is 15) and .longword numbers (the bit is 31).
Let's now look in detail at how two's complement works: we have noticed
that it is not enough to change the most significant bit to go from positive to
negative. Let's take the example of +26 and -26 in the .word field:

;5432109876543210
+26    %0000000000011010    ($001A)
-26    %1111111111100110    ($FFE6)

Bit 15 in +26 is reset and in -26 it is set, but this is clearly not
the only change needed to go from -26 to -26!!!
We need to do the two's complement of %0000000000011010, which consists of
REVERSING all bits and ADDING 1 to the result.
Let's see if this is true: reversing all bits gives us:

%1111111111100101

Let's add 1:

%1111111111100101 +
1 =
-----------------
%1111111111100110

If the row of 1s confuses you, isolate the 6 low bits: %100101 is 25, if you
add 1 = %100110, i.e. 26, with bits 7 to 15 all set to 1, i.e. -26.
If we want -26 in a byte, just use %11100110, i.e. $E6.
If we want -26 in a long: %1111111111111111111111111100110 = $FFFFFFE6
We can choose to use our bytes, words or longs as we wish, with or without a sign,
 depending on the instructions we use and our programme.
To clarify, here is how much a .b, a .w or a .l can contain depending on the
system used, whether ‘normal’ or ‘2's complement’:

Signed BYTE     .8 bits     - from -128 ($80) to +127 ($7f)
Signed BYTE .8 bits     - from 0 ($00) to 255 ($ff)
Signed WORD     .16 bits - from -32768 ($8000) to +32767 ($7fff)
Unsigned WORD .16 bits - from 0 ($0000) to 65535 ($ffff)
Signed LONG     .32 bits - from -2147483648 ($80000000) to +2147483648 ($7fffffff)
Unsigned LONG .32 bits - from 0 ($00000000) to 4294967299 ($ffffffff)

As you can see, in the SIGNED BYTE field, numbers from 128 to 255 are
considered as values from -128 to -1, while in the SIGNED WORD field, values
ranging from 32768 to 65535 are considered as values from -32768 to -1.
The same value applies to the .longword notation.
To summarise, here are two ways to obtain a negative number from a positive number:

System 1:

Given the number N=%00110 (6 decimal), to find -N, perform the bitwise negation of N, obtaining N=%11001 (-7 decimal), and then add 1 to the result:
N=%11001+%00001=%11010 (-6 decimal)
System 2: Given the number N=%00110 (6 decimal), to find -N, perform the bitwise negation of N until the least significant bit is 1, obtaining N=%00001 (-7 decimal), and then add 1 to the result:

System 2:

Given the number N=%00110 (6 decimal), to find -N, perform the bitwise negation
of N until the least significant bit N=%11010 (-6 decimal).

If our routine never goes below zero, it is best to
use one byte for its 255 values. If, on the other hand, we want to go from -50 to +50,
we need to use instructions such as BGT, BLE, BLT, which compare signed numbers,
instead of BHI and BLS, for example, which compare unsigned numbers.
Addition and subtraction work with both signed and unsigned numbers,
while multiplication and division do not. In fact, there are two types
of instructions for signed and unsigned numbers: MULU and DIVU for unsigned numbers,
 MULS and DIVS for signed numbers.

Now that we have clarified negative numbers, let's look at the CCR bits, i.e. the flags, one by one:


*bit 0 - Carry (C): set to 1 when the result of an addition generates a
carry, or when a subtrahend is greater than the minuend, i.e.
when a subtraction has required a “borrow”. The Carry bit also contains
the most significant bit of an operand subjected to a
shift or rotation. It is set to zero when the last operation
performed has no carries or “borrow”. For example, one way to
set the CARRY flag is as follows:

move.l    #$FFFFFFFF,d0
ADDQ.L    #1,d0

The result is d0=00000000, with the CARRY and ZERO flags set, because we have
exceeded the maximum capacity in .l, and the result is also ZERO!

*bit 1 - Overflow (V): is set if the result of the last operation
between signed numbers is too large to be
contained in the destination operand, for example if the result exceeds the
limits -128..+127 in the byte field. For example, the sum .b 80+80 generates an
oVerflow, having exceeded +127. In the .w field, the limits are -32768..+32767, and
in the .l field they are -/+ 2 billion. Note that the sum 80+80 in the byte
field does not set the Carry and eXtend flags, but only the oVerflow flag, since
160 does not exceed 255, the maximum that can be contained in a byte for normal numbers.

*bit 2 - Zero (Z): set when the operation generates a result of zero (also useful
for checking the decrement of a counter), as well as when
two equal operands are compared.

*bit 3 - Negative (N): set to 1 if, in an operation, the high bit of the
number, in two's complement format, is set. In practice, if the result
is a negative number, this bit is set, otherwise it is reset to zero.
The two's complement is obtained by taking the one's complement of the operand
(i.e. inverting all the bits) and then adding 1; for example, +26 in
binary is %000110010; its one's complement is %11100101 (inversion of bits
0 to bits 1 and vice versa); adding 1 gives %11100110.
Bit 7, known as the sign bit, is copied to bit 3 of the Status Register;
In the case of -26, for example, N is set, indicating a negative number.

*bit 4 - Extend (X): this is a repetition of the Carry bit and is used in
operations carried out in BCD notation (Binary Coded Decimal: the decimal number
20, for example, is not represented by 00010100, but in the form
two tens, zero units 0010 0000) and in binary operations “extended” as ADDX
and SUBX, special versions of the addition and subtraction instructions ADD and
SUB.
_____
/\___/\
/_/__/ \
\ \ /
\____\/
Y
:
.

In light of this new knowledge, refer to the reference text on all
processor instructions, with their effects on the CCR FLAGS, the
68000-2.TXT, an “evolution” of the old 68000.TXT on the first disk, which is now
child's play for you (or is it?).

Before starting LESSON9.TXT, it would be a good idea to read the entire
68000-2.TXT, so that you are thoroughly familiar with the CPU instructions!
Consider it as a LESSON8b.TXT, “DO IT” all, grasp its essence.
I admit that it may SCARE YOU (if you are half-baked) to read it all, but
once you become familiar with what is written in that nice 100K text
you can finally tell everyone that you know how to program the 68000.
By the way, if you find instructions you don't know later on, you can't
complain, because they are explained in 68000-2.TXT!
First, take a look at the CMP and Bcc instructions, where the various
types of Bcc are explained in more detail, then start from the beginning and work your way
to the end, perhaps rereading it several times, taking breaks between readings
and eating a sandwich. This 68000-2.TXT is the second hurdle you
have to overcome; the first was LESSON2.TXT, where you learned the basics
,
 addressing. Many stopped at that hill. Now you
are faced with a mountain, and just as many will not have the guts to overcome it.
But those who do will be able to try to reach the summit!

Have you read it at least once? Are the Condition Codes clear to you?
Here are some examples to check if you have understood. They were kindly
written by Luca Forlizzi (the Dark Coder) and Antonello Pardi (Deathbringer),
allowing me to speed up the writing of the lessons on AGA and 3D.

Lesson8p1a.s    -> CC in the MOVE instruction
Lesson8p1b.s    -> CC in MULU/MULS
Lesson8p1c.s    -> CC in DIVU/DIVS
Lesson8p2a.s    -> CC and Ax address registers
Lesson8p2b.s    -> Sign extension in Ax address registers
Lesson8p3.s    -> CC in TST
Lesson8p4.s    -> CC in AND, NOT, OR, EOR
Lesson8p5.s    -> CC in NEG
Lesson8p6.s    -> CC in ADD
Lesson8p7.s    -> CC in CMP
Lesson8p8.s    -> CC in ADDX
Lesson8p9.s    -> CC in lsr,asr,lsl,asl

Finally, load my Lesson8p9b.s, which also contains a ‘question’.

____________________
\ /
\________________/
_( o.. ..o )_
/ )(\__ __/) ( \
( / \/ / \ \/ \ )
/\( ( _) )/\
\_/\ __ \___/ __/\_/
\\\_________ ( /
\\_|_|_|_|7 /
\\|_|_|_|/ /
\________/


Before moving on to the next lesson, there are a couple of things I
would like to tell you. My friend Michele, who programs adventure games, asked me
some questions the last time he came to visit me, and I think they might
be of interest to many of you. He made a control panel at the
bottom, similar to Lesson8h.s, and at the top he displays the various figures, which
he loads from the diskette (we'll see later how to load files with the
dos.library system library). The problem is that he had the .raw files for the figures, but the 
palette for each figure had to be kept in the main programme in tables
,
 one for each figure, and a routine was responsible for copying the colours from the
right table to the copperlist depending on the figure loaded. However, this
messed up the code, as there are dozens of figures. Then I
remembered that with iffconverters, including KefCon, you can ALSO
save THE PALETTE at the bottom of the .RAW! Just change the CMAP OFF option to BEHIND, and
the palette is attached to the bottom of the .raw, from colour 0 to the last, word after
word. You could also choose BEFORE, which attaches the palette before the
pic, but in that case you would need to point to “after the palette”, setting it.
Having established that it is best to save with CMAP BEHIND (at the bottom), let's see what
changes in the saved .raw file.
The file is the same, but longer. In the case of the logo in this lesson, it is
16 words longer, as it has 16 colours.w at the bottom, as in this example
(to clarify):

start_pic:
incbin    “logo320*84*16c.raw”    ; bitplanes.raw normal
dc.w $000,$fff,$200,$310    ; palette
dc.w $410,$620,$841,$a73
dc.w $b95,$db6,$dc7,$111
dc.w $222,$334,$99b,$446
end_pic:

I have saved the logo in this format, let's see with what
simple routine we can copy the palette in copperlist, in Lesson8q.s
Note that the pic, when pointed normally, also works in the previous listings,
 in fact we only have some ‘extra’ words that are not
displayed because they are ‘after’ the end of the last bitplane.

Another thing I was asked is: how do you know which processor
and which kickstart is present on the machine? In Lesson8r.s, this mystery
is revealed... just consult the bits dedicated to this purpose!

So, if you are convinced that you have understood everything so far, you can move on
to loading LESSON9.TXT, which will FINALLY introduce you to the blitter, which
at this point you were surely wondering if it really exists.

A note: if you can read English, you will certainly find these
fundamental books useful:

The second edition of the Amiga hardware manual:

‘Amiga Hardware Reference Manual’ ISBN code: 0-201-18157-6


AS FOR THE 680x0:

Motorola, ‘MC68020 32-bit Microprocessor User Manual, fourth edition’,
Prentice Hall ISBN 0-13541657-4

Motorola, ‘MC68030 Enhanced 32-bit Microprocessor User Manual, second edition’
Prentice Hall ISBN 0-13-566951-0, Motorola ISBN 0-13-566969-3.

Motorola, ‘MC68040 32-bit Microprocessor User Manual’


Perhaps you should not get the user manual for the 68000 or the 68040,
since the 68000 is explained (I hope) quite well in 68000-2.txt, and the
68040 is currently the preserve of a lucky few, so demos or games that
only run on 68040 would not be very widespread. Furthermore, the biggest differences
are between the 68000 and 68020, while there are few differences between the 68020 and 68030,
and the same applies to the 68030 compared to the 68040. The biggest differences, however,
are in the MMU and the CACHE control instructions, but when programming
demos and NOT operating systems, this is not of great interest to us.

_/\ /\ /\_
_ \ (_/ \_) / _
_)\__________________________) _/\_ (__________________________/(_
(______________\_\__\___\________) (________/___/__/_/______________)
(_ ________________\_\__\___ \/ ___/__/_/_________________ _)
\/ \ / \/
\/