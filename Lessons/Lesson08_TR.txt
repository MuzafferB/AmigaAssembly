_
_|_ / \.¼¼/\_/\¼._
| / ¯\/ \/ \ _
| Y _____¯\/¯_____ Y ___ /¯\ ___ .--.
.--------- |/¯¯¯¯¯\ /¯¯¯¯¯\| ----- .Y¯¯¯Y¾Y Y:Y¯¯¯Y. ___ ------.\/.--.
| ¬ f | YY | Y ¬.¾¾l___j¾l___j¾l___j¾Y¯¯¯Y ¬ \/ ¬ |
|. l -¼- jl -¼- j /¯/\¼f _ Y¼f _ Y¼f _ Y¾l___j |
|¡ |\ | _/¯¯\_ | /| ( < >l/ \j¼l/ \j¼l/ \j./__ / .|
|: j \__/ /¯¯\ \__/ l \_\/ `\ /¼¼¼\ /¼¼¼\ /¼l/ /j :|
|. ( ¯¯ / \ ¯¯ ) V `¼¼¼V¼¼¼¼¼V¼‘ \/ .|
| \__ \_/\_/ __/ .:::::::’ |
|. ¯\ /¯ ««=-- DISK 2 - DERS 8 --=»» .|
| /\ Y : . . Y · . . . tS |
`--‘/\`------- (_| | :| ) ---------- · . ----------------’
`--' \\j_j_ll// . · .
~:¯:¯::~ .

ASEMBLER KURSU - DERS 8

Yazar: Fabio Ciucci

Bu derste 68000 hakkında bilgiler derinleştirilecek ve
daha önce işlenen çeşitli konular hakkında ayrıntılı açıklamalar yapılacaktır.
Kursu sabit diske yükleyenler için bir not: kursun adını taşıyan bir
dizin oluşturmanızı tavsiye ederim:

Assembler1
Assembler2
Assembler3
...

Bütün disketleri buraya kopyalayın. Ardından s:startup-sequence'e şunu ekleyin:

assign Assembler1: dh0:Assembler1
assign Assembler2: dh0:Assembler2
assign Assembler3: dh0:Assembler3
...

(dh0: sadece bir örnektir... elbette uygun sürücüyü yazacaksınız!).
Ardından, powerpacker formatında olan tüm kaynakları ve verileri açmanızı tavsiye ederim.
Bunu yapmak için, c:PP dosyasını sabit diske kopyalayın ve
LIBS'de PowerPacker.library klasöründe olup olmadığını kontrol edin, yoksa bu diskten
kopyalayın. Şimdi, otomatik açmayı etkinleştirmek için kabuktan “PP” komutunu çalıştırın
.
 Şimdi bir “geçici” dizin oluşturun,
örneğin ‘buffer’ adını verin. Assembler1 dizinindeki TÜM dosyaları Buffer dizinine kopyalarsanız, tüm dosyalar açılacaktır, aslında
“uzayacaklar”
.. Şimdi hepsini Assembler1'e kopyalayabilirsiniz (örneğin
DiskMaster veya DirOpus'un MOVE komutuyla, bu komut dosyaları tampondan da siler).
Aynı şekilde Assembler2'nin tamamını tampona kopyalayabilir, ardından
Assembler2'ye kopyalayabilirsiniz. Bu hızlı işlemi atlamak için,
dosyaları disketten HD dizinlerine kopyalamadan önce PP'yi yükleyebilirsiniz, böylece
AssemblerX'teki dosyalar açılmış olur.
3 assign komutu, “AssemblerX:” adındaki diski aramak yerine
“dh0:AssemblerX” dizininde arama yapılmasını sağlar.
Aslında, sonraki listelerin bazılarında “Assembler2:” aranır ve
“Assembler3:” için de aynı şey geçerlidir.


P.S: Kursun tamamını İngilizceye çevirmeyi planlıyorum. Ancak bu
beni aylarca yeni ders yazmamaya zorlayacaktır...
Bu nedenle, disk 1'i okumuş,
İngilizceyi yeterince bilen ve en az
bir dersi çevirmek isteyen biri varsa, çok sevinirim. Çeviri işinde bana yardımcı olan kişi
tabii ki yurtdışından elde edilen kârın çok yüksek bir yüzdesini
alacaktır 
(%30 nasıl? Belki çok fazla...)
Bana yardımcı olabilecekler (çok güzel bir çeviri işi)
en kısa sürede benimle iletişime geçsin.

P.S2: Lütfen diski 1'i TÜM arkadaşlarınıza (ve arkadaşlarınız olmayanlara) kopyalayın
, şehirdeki dükkanlara verin,
duyuru panolarına veya gazetelere ilan verin, ilgilenen
biri var mı diye bakın ve programlamak için yeni bağlantılar bulun. Özellikle,
 sahnenin CyberAssemblica felsefesini yayabilirsiniz,
 bunun özetini SCENA.TXT dosyasında bulabilirsiniz.
Papa bile balkona çıktığında kursun 1. diskine sahip olmalı
! (serbestçe kopyalanabilir).
Disk 2, yani bu disk ise,
serbestçe kopyalanamaz, aksi takdirde sadece diski 1 alanların bana gönderdiği
(çok da fazla olmayan) parayı bile alamam.
Düşünsenize, bu kişiler her iki diski de alsalardı!
Her neyse, disk 3, 4, vb. diskleri yaparsam, muhtemelen
2. diski de serbestçe kopyalanabilir hale getireceğim (ancak shareware olarak),
böylece yeniler 1. ve 2. diskleri hemen alabilecekler, ben de
3. ve 4. disklerle biraz para kazanacağım....


Dersimize devam edelim, dosya HardDisk'te veya Floppy'de olsun.
Öncelikle, 68000 ile ilgili dersi tamamlamamız gerekiyor, çünkü şu ana kadar
basit bir şekilde kullanıldı. Önceki dersten itibaren
sayıların veya kayıtların tek tek bitleri üzerinde çalışmanın çok sık gerekli olduğunu
görmüşsünüzdür. Programlamaya devam ettikçe, AND, OR, NOT, ROL, ASL... vb.
yani boole mantık ve bit kaydırma işlemleri gibi komutları girme eğiliminde olacaksınız.
Ah! LEZIONI dizininde SCENA AMIGA'nın ne olduğunu açıklayan bir metin bulunmaktadır.
. Artık birer kodlayıcı olmaya başladığınıza göre,
demo programlama kültürünün doğuşu için kime teşekkür etmeniz gerektiğini bilmeniz uygun olur.
 Bu kültür, gördüğünüz gibi “yasadışı” olmasına rağmen çok iyi işliyor.
Metin adı SCENA.TXT, asm dersleriyle kafanızı yormak istemediğinizde okuyun.
beyninizi asm dersleriyle yormak istemediğinizde okuyun!
Derse devam etmeden önce, bir başlangıç listesi yapmanız gerekir.
Bu liste, sistem kopyasını kaydetme ve geri yükleme işlemlerini içerir ve şimdiye kadar kullandığımızdan daha verimlidir.
Ayrıca, bu başlangıç listesi
tüm sonraki listelere dahil edilecek, bu nedenle müziği çalan rutini dahil etmek için daha önce gördüğümüz “INCLUDE” komutuyla
“INCLUDE” komutuyla yüklemek daha yararlı olacaktır.
Müziği çalan rutini eklemek için daha önce gördüğümüz komutla.
Bu başlangıç listesini, çeşitli açıklamaların sonucunda adım adım derslerde “oluşturacağız”.
Önceki derslerde kullanılan başlangıç prosedürünü inceleyelim:

Başlangıç:
move.l    4.w,a6        ; Execbase
jsr    -$78(a6)    ; Devre dışı
lea    GfxName(PC),a1    ; Lib adı
jsr    -$198(a6)	; OpenLibrary
move.l    d0,GfxBase
move.l    d0,a6
move.l    $26(a6),OldCop    ; eski COP'u kaydedelim

; Burada copperst'imiz işaretlenmiştir ve rutinler bulunmaktadır

move.l    OldCop(PC),$dff080	; Sistem cop'unu işaret ediyoruz
move.w    d0,$dff088        ; cop'u başlatıyoruz
move.l    4.w,a6
jsr    -$7e(a6)    ; Etkinleştir
move.l    gfxbase(PC),a1
jsr    -$19e(a6)    ; Kütüphaneyi kapat
rts

Pratikte, Disable ile çoklu görev ve sistem kesintilerini durduruyoruz,
 ardından grafik kütüphanesini açıyoruz, bu sayede
eski copperlist adresini bulabiliyoruz, çünkü bunun GfxBase adresinden
26 bayt sonra olduğunu biliyoruz. Eski
copperlist'i nasıl geri koyacağımızı bildiğimiz ve WorkBench'i hareketsiz hale getirdiğimiz için,
uyumsuzluk korkusu olmadan doğrudan özel yongalar üzerinde
işlem yapabiliriz.
eski bakır listeyi işaret etmek için Enable komutunu çalıştırmak ve işletim sisteminin pencerelerini yeniden görüntülemek gerekir.
Bu işlemler çalışmak için gerekli olan minimum işlemlerdir, ancak
kodda bazı iyileştirmeler yapılabilir, örneğin
video modunu sıfırlayan grafik kütüphanesi rutinleri çalıştırılabilir
böylece VGA/Multisync/Multiscan
ve diğerleri için de sıfırlamak. Bunun için özel bir işlev vardır ve adı LoadView'dur, bakalım:

; GfxBase, A6

MOVE.L    $22(A6),WBVIEW    ; Mevcut sistem WBView'unu kaydeder
SUBA.L    A1,A1        ; Video modunu sıfırlamak için boş View
JSR    -$DE(A6)    ; LoadView sıfır - video modu sıfırlandı

LoadView işlevi, a1'de yapı adresinin belirtilmesini gerektirir,
 ancak bu durumda A1 SIFIRLANMIŞTIR, çünkü a1'i kendisine ekliyoruz
ve a1=0 elde ediyoruz. A1 SIFIR olduğunda, işlev video modunu sıfırlar
ve onu monitörler için özel frekanslar olmadan, taramalı olmayan bir LOWRES moduna geri döndürür.
 Bu noktada, copperlist durumunun kontrol altında olduğundan daha emin olabiliriz.
 Ayrıca, eski WBVIEW yapısına işaret eden eski işaretçiyi bir etikette kaydettik,
 bu da listelemenin sonunda onu ve monitörler için olası özel frekansları geri yüklememizi sağlayacaktır
:

MOVE.L    WBVIEW(PC),A1    ; Eski WBVIEW A1'de
MOVE.L    GFXBASE(PC),A6    ; GFXBASE A6'da
JSR    -$DE(A6)    ; loadview - eski View'u geri yükle

Interlaced modunun da doğru şekilde sıfırlandığından ve geri yüklendiğinden emin olmak için,
 yine graphics.library'deki WaitOF rutinini çalıştırarak iki kare bekleyebilirsiniz:
MOVE.L    WBVIEW(PC),A1    ; Eski WBVIEW A1'de

MOVE.L    WBVIEW(PC),A1    ; WBVIEW A1'de
MOVE.L    GFXBASE(PC),A6    ; GFXBASE in A6
JSR    -$DE(A6)    ; loadview - eski View'u geri yükle
JSR    -$10E(A6)    ; WaitOf ( varsa interlace'i yeniden düzenle)
JSR    -$10E(A6)    ; WaitOf

İçimizin rahat olması için, video modunu sıfırlayan ilk
loadwiew'den sonra da bir çift WaitOF koyalım ve hazır başlamışken
sıfırlamanın gerçekten gerçekleştiğini kontrol edelim, WBVIEW'nin beklendiği gibi sıfırlanıp sıfırlanmadığını test ederek:

; GfxBase A6 kaydında

MOVE.L    $22(A6),WBVIEW    ; Mevcut sistem WBView'unu kaydeder
SUBA.L    A1,A1		; Video modunu sıfırlamak için boş View
JSR    -$DE(A6)    ; Boş LoadView - video modu sıfırlandı
JSR    -$10E(A6)    ; WaitOf ( Bu iki WaitOf çağrısı )
JSR    -$10E(A6)    ; WaitOf ( interlace'i sıfırlamak için kullanılır )

İşletim sistemi rutinlerini kullandığımızdan, gelecekteki makinelerde
video modunun yine sıfırlanacağından eminiz.
Uyumluluğu “abartmak” için, listenin sonunda
ekranları ve pencereleri “yeniden çizen” intuition.library işlevlerini çağırabiliriz
:

move.l    4.w,a6		; ExecBase in A6
LEA    IntuiName(PC),A1 ; Açılacak kütüphane adı (intuition)
JSR    -$198(A6)    ; OldOpenLibrary - kütüphaneyi aç
TST.L    D0        ; Hata?
BEQ.s	EXIT        ; Evet ise, kodu çalıştırmadan çık
MOVE.L    D0,A6        ; IntuiBase a6'da
jsr    -$186(A6)    ; ReThinkDisplay - Ekranların özelliklerini yeniden düzenle
; ...

Bu işlem WBView ile yapılan işlemin aynısıdır.
Şu anda blitter'ı henüz kullanmadık, ancak sonraki derslerde
çok sayıda ‘blitter’ olacak ve bu başlangıcı kullanacağımız için,
bu amaç için hazırlamak faydalı olacaktır. Blitter'ın, biz kullanırken
işletim sistemi tarafından kullanılmadığından emin olun ve
WorkBench'in blitter kullanımını durdurabilen bir GfxLib işlevi vardır:

jsr    -$1c8(a6)    ; OwnBlitter, blitter üzerinde tekel hakkı verir
; işletim sisteminin kullanmasını engeller.

Listelemenin sonunda, tersini yapan işlevi çağırmak yeterlidir, yani
grafik kütüphanesi tarafından blitterin kullanımını yeniden etkinleştirir:

jsr    -$1ce(a6)    ; DisOwnBlitter, işletim sistemi artık
; blitter'ı tekrar kullanabilir

Bu iki işlev, Disable ve Enable işlevlerine benzerdir ve
gördüğümüz gibi, çoklu görev ve sistem kesintilerini durdurur ve yeniden etkinleştirir.
Aslında, Disable işlevinden daha az radikal bir işlev de vardır, yani
Forbid, çoklu görevi devre dışı bırakırken
; Forbid ve Disable'ın birlikte kullanılması yasak değildir, belki
sistemin durmasını daha yumuşak hale getirir, birlikte deneyelim:

move.l    4.w,a6        ; ExecBase in A6
JSR    -$84(a6)    ; FORBID - Multitasking'i devre dışı bırakır
JSR    -$78(A6)    ; DISABLE - İşletim sisteminin kesintilerini de devre dışı bırakır
;     işletim sistemi
; rutinleri

MOVE.L    4.w,A6        ; ExecBase in a6
JSR    -$7E(A6)    ; ENABLE - Sistem Kesintilerini Etkinleştir
JSR    -$8A(A6)    ; PERMIT - Çoklu görevleri etkinleştir

Artık Amiga, Guru Meditation veya SoftWare Failure
hatasıyla, donanımı programladığımız konusunda onu uyarmadığımızı söyleyerek itiraz edemez!

/ \ //\
|\___/| / \// .\
/O O \__ / // | \ \
/ / \/_/ // | \ \
@___@‘ \/_ // | \ \
| \/_ // | \ \
| \/// | \ \
_|_ / ) // | \ _\
’/,_ _ _/ ( ; -. | _ _\.-~ .-~~~^-.
,-{ _ `-.|.-~-. .~ `.
‘/\ / ~-. _ .-~ .-~^-. \
`. { } / \ \
.----~-.\ \-’ .~ \ `. \^-.
///.----..> \ _ -~ `. ^-` ~^-_
///-._ _ _ _ _ _ _}^ - - - - ~ ~--, .-~
|_/~

Her şeyin durumunu kaydettiğimize göre, neden
veri ve adres kayıtlarının değerlerini de kaydetmiyoruz?
ve MOVEM komutudur. Ancak kayıtlar
STACK'te, yani A7 kayıtında, SR olarak da bilinen ve şimdilik
kullanmaktan kaçındığımız kayıtta kaydedilir. Stack'in ne olduğunu görelim: bunun bir
adres kaydına benzer bir kayıt olduğunu düşünün, boşuna A7 kaydı değil,
yani içerdiği değer bir adrestir, yani bir adresi GÖSTERİR.
Aslında, A7 (veya SP) içindeki adresi değiştirirsek, Amiga
tamamen çıldırır. Peki, bu adresi Stack Pointer'a kim koyar?
Değiştirildiğinde Guru/Software Failure hatası oluştuğuna göre,
bu sayıyı her reset'te işletim sisteminin belirlediğini ve gerektiğinde
değiştirdiğini tahmin edebilirsiniz. Ancak nasıl kullanıldığını bilirsek, çok yararlı olabilir.
Kurs boyunca, dolaylı adresleme ile bir bellek alanını nasıl gösterebileceğimizi gördük, örneğin şöyle yazarak:

lea    bitplane,a0
move.l    #$123,(a0)+
move.l	#$456,(a0)+

a0 kaydını kullanarak bitplane'e $123 ve $456 değerlerini girdik,
çünkü a0'ı bitplane'e PUNTARE yaptık. Bu listeden,
 post-increment ile dolaylı adresleme kullanarak
veri alanına arka arkaya, birbiri ardına veri girmenin nasıl mümkün olduğunu da görebiliriz.
Bu komutlardan sonra şunu yazarsak ne olur?

move.l    -(a0),d0
move.l    -(a0),d1

d0'a son girilen değer, yani $456 kopyalanır,
 d1'e ise ilk değer, $123 kopyalanır ve a0 tekrar bitplane'e işaret eder.
Pratikte "geri döndük".
Peki, bunun tersini yaptığımızı hayal edin:
gördüğümüz örnekte, BITPLANE adını verdiğimiz bir bellek alanı var ve
move.l #xxx,(a0)+ ile o adresten ileriye doğru yazıyoruz.

Bitplane
o------------>

Sonra, belirli sayıda komutun ardından, a0 bitplane+x'i işaret eder, yani bellekte çok
daha ileride.
Bu alana “ektiğimiz” değerleri
move.l -(a0),xxx komutlarıyla “geri alabiliriz”, bu komutlar bizi tekrar
başlangıç adresi BITPLANE'ye geri götürür. Ancak dikkat! Verileri
girdiğimiz sıranın tersi sırayla topladık, yani en son girilen
ilk geri alınan olur. Yığın, bellekteki bir adrese işaret eder ve
“alan” olarak kullanılır, yani verilerin kaydedileceği ve geri alınacağı alan.
Ancak, bitplane örneğinin aksine, “ters” olarak kullanıldığına dikkat etmek gerekir.
 Yığın ihtiyacı ilk CPU'larla ortaya çıkmıştır ve
şöyle düzenlenmiştir: bir bilgisayarın belleği genellikle
en düşük konumlardan en yüksek konumlara doğru doldurulur, örneğin
512k belleğe sahip bir bilgisayarımız varsa ve 256k uzunluğunda bir dosya yüklememiz gerekiyorsa,
 ilk 256k doldurulur ve 257 ila 512 arasındaki Kb boş kalır.
Genel verileri kaydetmek için bir STACK alanı ayırmak istendiğinde,
bu alanın belleğin sonundan başlayarak
verileri ilk bellek konumuna doğru “geriye doğru” kaydetmek
ve belleği en iyi şekilde kullanmak


ZERO ---------------------------------------HAFIZANIN SONU
Programlar ----->>        <<-----STACK


Bu şekilde, hafıza tamamen bitmedikçe yığın üzerine yazılmaz
ve her halükarda işletim sistemi altındaki programlar bu tür bir
çatışmayı önler! Biz işletim sisteminden çalıştırılabilir demo veya oyunlar yapmalıyız,
bu nedenle çatışma veya
üzerine yazma olmaması için yığını standart şekilde kullanmalıyız. 
Otomatik başlatılan ve
çıkış gerektirmeyen bir program yazarsak, yığın için kendi alanımızı tanımlayabiliriz, ancak bu
uyumluluk sorunlarına yol açabilir ve şimdilik bunu yapmamanızı tavsiye ederim.
Son olarak, STACK'e veri girip çıkarmayı çok basit bir örnekle başlayarak görelim: D0 kaydının içeriğini kaydedin ve
daha sonra geri yükleyin.

MOVE.L    d0,-(SP)    ; d0'ı yığına kaydediyoruz. NOT:
; tek bir kayıt kaydetmemiz gerekiyorsa, MOVE kullanıyoruz
; MOVEM değil, bu çoklu kayıtlar için kullanılır.

;    D0'ı değiştiren rutinler

MOVE.L    (SP)+,d0    ; d0'ın eski değerini geri yüklüyoruz
; STACK'ten alarak

MOVE.L d0,-(SP) veya MOVE.L d0,-(A7) yazmanın eşdeğer olduğunu unutmayın,
bellekte aynı ikili dizi birleştirilir. d0'ın içeriğinin
SP'nin işaret ettiği adrese kopyalandığını ve SP'nin kendisinin
bir uzunluk daha geriye işaret ettiğini unutmayın. Ardından d0 çeşitli rutinler tarafından değiştirilir ve
eski değerini almak istediğimizde, SP'deki adresinden geri almamız yeterlidir.
 (SP)+ ile SP'yi, d0'u kaydetmeden önce işaret ettiği adrese geri getirdiğimizi unutmayın,
 yani bir long geri gittik,
 sonra değeri geri alarak ileri döndük.
Şimdi birden fazla kaydın değerini kaydetmeyi deneyelim:

MOVE.L    d0,-(SP)	; d0'ı yığına kaydeder
MOVE.L    d1,-(SP)    ; d1'i yığına kaydeder
MOVE.L    d2,-(SP)    ; d2'yi yığına kaydeder
MOVE.L    d3,-(SP)    ; d3'ü yığına kaydeder

;    d0,d1,d2,d3'ü değiştiren rutinler

MOVE.L	(SP)+,d3    ; d3'ün eski değerini geri yükleyelim
MOVE.L    (SP)+,d2    ; d2'nin eski değerini geri yükleyelim
MOVE.L    (SP)+,d1    ; d1'in eski değerini geri yükleyelim
MOVE.L    (SP)+,d0    ; d0'ın eski değerini geri yükleyelim
; STACK'ten alarak

Son kaydedilen değerin geri alınabilecek ilk değer olduğunu unutmayın,
çünkü geri gidip sonra ileri dönerek,
girilen son değerden ilk değere kadar ters sırada okuruz:

Başlangıç adresi STACK
GİRİŞ:    -(SP)    <--------------o    - geri -


Başlangıç adresi STACK
OKUMA:    (SP)+    ---------> o    - ileri -


“yığın” olarak adlandırılan bir yapıdır, aslında şu şekilde hayal edilebilir
: bir çizgi roman koleksiyonunuz olduğunu ve bunları
1'den 50'ye kadar sıralamak istediğinizi düşünün. 1'i bulduğunuzda, onu masanın üzerine koyarsınız.
2'yi bulduğunuzda, onu 1'in üzerine koyarsınız. Sonra 3'ü 2'nin üzerine koyarsınız ve
böylece bir “yığın” oluşturursunuz, 50 numarayı
yığının en üstüne koyana kadar. Şimdi, çizgi romanları geri almak isterseniz, ilk
karşınıza çıkan 50 numara olur, sonra altında 49, 48 vb. ve en son
1'i bulursunuz. Yığın aslında “ilk giren, son çıkar” türündedir, yani “içeriye ilk konulan
son çıkar”.
Yığını yanlış bir şekilde değiştirirseniz, bellekteki değerlerin rastgele alınacağını
ve daha önce kaydedilmiş değerler olarak kabul edileceğini anlayacaksınız.
Bu nedenle, şunu yaptığınızda dikkatli olun:

MOVE.L    xxxx,-(SP)    ; xxxx'i yığına kaydedelim

Bir dahaki sefere (SP)+ ile yığından okuduğunuzda xxxx'i elde edersiniz.

Yığına herhangi bir veriyi kaydedebilir ve geri alabilirsiniz, ancak en
en belirgin yararlarından biri, kayıtların durumunu kaydetmektir ve bunu
yapmak için, tek bir kaydı kaydetme durumunda gördüğümüz basit MOVE.L komutunu
veya birden fazla kayıt için MOVEM (MOVE Multiple) komutunu kullanabilirsiniz.
MOVEM'in nasıl çalıştığını görelim: tüm kayıtları (a7 hariç,
tabii ki SP olan a7 hariç, yani d0,d1,d2,d3,d4,5,d6,d7,a0,a1,a2,a3,a4,a5,a6),
15 MOVE yerine sadece bu MOVEM komutunu çalıştırmanız gerekir:

MOVEM.L    d0-d7/a0-a6,-(SP)    ; tüm kayıtları STACK'e kaydeder

Ve hepsini geri yüklemek için şunu yeterlidir:

MOVEM.L    (SP)+,d0-d7/a0-a6    ; tüm kayıtları STACK'ten geri alır

Pratik olarak MOVEM, bir kayıt listesini hedefe taşır
“MOVEM.L d0-d7/a0-a6,hedef” durumunda veya bir kaynağı çeşitli
kayıtlara kopyalar, “MOVEM.L kaynak,d0-d7/a0-a6” durumunda.
Kaynak ve hedef “standart” formattadır, bu nedenle
LABEL/ADRESLER veya dolaylı adreslemelerden kopyalanabilir:

MOVEM.L    d0-d7/a0-a6,-(SP)
MOVEM.L    d0-d7/a0-a6,LABEL
MOVEM.L    d0-d7/a0-a6,$53000

MOVEM.L    $53000,d0-d7/a0-a6
MOVEM.L    LABEL(PC),d0-d7/a0-a6
MOVEM.L    (SP)+,d0-d7/a0-a6

Liste şu standardı izler: kayıtları ayrı ayrı,
“/” çubuğu ile ayırarak gösterebilirsiniz, bu nedenle şunu söyleyebiliriz:

MOVEM.L    d0-d7/a0-a6,-(SP)

şuna eşdeğerdir:

MOVEM.L    d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6,-(SP)

Ancak, ardışık kayıt serileri
serinin ilk ve son kayıtları “-” ile ayırarak gösterilebileceğinden,
çubukla yalnızca veri kayıtları adres kayıtlarından ayrılır.
Aslında asm de şunu kabul eder:

MOVEM.L    d0-a6,-(SP)

Bunu çok uzun bir önceki komut olarak düşünürsek, ancak
tüm assembler'lar bu biçimi kabul etmediğinden, “/” işaretini
veri kayıt serisi ile adres kayıt serisi arasına koymak daha iyidir.
Örnekler verelim: d0, d1, d2, d5 ve a3 kayıtlarını kaydetmek istiyoruz:

MOVEM.L    d0-d2/d5/a3,-(SP)

d0/d1/d2'yi d0-d2 ile basitleştirdik.
Şimdi d2,d4,d5,d6,a3,a4,a5,a6'yı kaydetmeyi deneyelim:

MOVEM.L    d2/d4-d6/a3-a6,-(SP)

Bu kayıtları geri yüklemek için şunu yazacağız:

MOVEM.L    (SP)+,d2/d4-d6/a3-a6

MOVEM'in sözdizimi açık olduğunu düşünüyorum. Bu komutla
çoklu görevleri yönetmek mümkündür. Aslında, aynı veri ve adres kayıtlarını kullanan iki programı
birbirleriyle etkileşime girmeden nasıl çalıştırabileceğinizi hiç merak ettiniz mi? Cevap basit!
Her rutinin başında, kayıtların durumunu kaydeden bir MOVEM vardır.
Her rutinin başında, kayıtların durumunu kaydeden bir MOVEM vardır.
Rutin çalıştırılır ve çıkışta kayıtlar, sanki bu rutin hiç çalıştırılmamış gibi
orijinal durumlarına geri döner.
Aslında birçok rutin bu şekilde yapılandırılmıştır:

Rutin:
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
rts

Bu şekilde, bir “BSR.W ROUTINE” kayıtların değiştirilmesine neden olmaz,
bu nedenle a5'te $dff000 ve a6'da ExecBase varsa,
yürütülmesinden sonra bu değerlerin hala mevcut olacağından emin olabiliriz.
MOVEM kullanırken, ilk birkaç seferde, daha önce yapılan “hareketlerin İPLİĞİNİ” kaybetmek sık sık olur,
 bu nedenle şöyle bir durum ortaya çıkabilir:


Rutin:
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
rts

Bu durumda BÜYÜK bir HATA vardır, çünkü ilk olarak yığın
çok ileri gitmiştir, bu nedenle yığından daha sonra alınacak tüm veriler
yanlış olacaktır, ikinci olarak kayıtlar zaten giriş değerlerinden
farklı değerlere sahip olacaktır. Her şeyi eski haline getirmek için şöyle yapılabilir:


Rutin:
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
....
MOVEM.L    d0-d7/a0-a6,-(SP)
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
....
....
MOVEM.L    (SP)+,d0-d7/a0-a6
rts

Bu şekilde, rutinin çıkışında kayıtlar giriş değerine sahip olur
ve yığın giriş adresine geri döner. (rutine giriş!)

Bu noktada, son örnekte olduğu gibi, başlangıçta kayıtların kurtarılması
ve son olarak geri yüklenmesi için başlangıç programımıza gerekli donanımı sağlayabiliriz.
Şu anda başlangıcımız şöyle görünüyor:

MAINCODE:
movem.l    d0-d7/a0-a6,-(SP)    ; Kayıtları yığına kaydeder
move.l    4.w,a6            ; ExecBase a6'da
LEA	GfxName(PC),A1        ; Açılacak kitaplık adı
JSR    -$198(A6)        ; OldOpenLibrary - lib'i aç
MOVE.L    d0,GFXBASE        ; GfxBase'i bir etikete kaydet
BEQ.w    EXIT2            ; Evet ise, kodu çalıştırmadan çık
LEA    IntuiName(PC),A1    ; Intuition.lib
JSR    -$198(A6)        ; Openlib
MOVE.L    D0,IntuiBase
BEQ.w    EXIT1            ; Sıfırsa, çık! Hata!

MOVE.L    IntuiBase(PC),A0
CMP.W	#39,$14(A0)    ; sürüm 39 veya üstü mü? (kick3.0+)
BLT.s    EskiIntui
BSR.w    SpritesV39'u sıfırla
EskiIntui:

MOVE.L    GfxBase(PC),A6
MOVE.L    $22(A6),WBVIEW    ; Mevcut sistem WBView'unu kaydet

SUBA.L    A1,A1        ; Video modunu sıfırlamak için boş View
JSR    -$DE(A6)    ; Boş LoadView - video modu sıfırlandı
SUBA.L    A1,A1        ; Boş View
JSR    -$DE(A6)    ; LoadView (güvenlik için iki kez...)
JSR    -$10E(A6)    ; WaitOf ( Bu iki WaitOf çağrısı )
JSR    -$10E(A6)    ; WaitOf ( interlace'i sıfırlamak için kullanılır )
JSR    -$10E(A6)    ; İki tane daha, hadi!
JSR    -$10E(A6)

MOVEA.L    4.w,A6
SUBA.L    A1,A1        ; NULL görevi - bu görevi bul
JSR    -$126(A6)    ; findtask (d0=görev, FindTask(ad) a1'de)
MOVEA.L    D0,A1        ; a1'deki görev
MOVEQ    #127,D0        ; d0'daki öncelik (-128, +127) - EN ÜST!
JSR    -$12C(A6)    ;_LVOSetTaskPri (d0=öncelik, a1=görev)

MOVE.L    GfxBase(PC),A6
jsr    -$1c8(a6)    ; OwnBlitter, blitter üzerinde münhasır hak verir
; işletim sisteminin kullanmasını engeller.
jsr    -$E4(A6)    ; WaitBlit - Her blitter işleminin bitmesini bekler
JSR    -$E4(A6)    ; WaitBlit

move.l    4.w,a6        ; ExecBase in A6
JSR    -$84(a6)	; FORBID - Çoklu görev özelliğini devre dışı bırakır
JSR    -$78(A6)    ; DISABLE - İşletim sisteminin kesintilerini de devre dışı bırakır
;    
**************
bsr.w    HEAVYINIT    ; Artık donanım kayıtlarında
**************            ; çalışan kısmı çalıştırabilirsiniz

move.l    4.w,a6        ; ExecBase in A6
JSR    -$7E(A6)    ; ENABLE - Sistem Kesmelerini etkinleştir
JSR    -$8A(A6)    ; PERMIT - Çoklu görevleri etkinleştir

SUBA.L    A1,A1        ; NULL görevi - bu görevi bul
JSR    -$126(A6)    ; findtask (d0=görev, FindTask(ad) a1'de)
MOVEA.L    D0,A1        ; a1'deki görev
MOVEQ    #0,D0        ; d0'daki öncelik (-128, +127) - NORMAL
JSR    -$12C(A6)    ;_LVOSetTaskPri (d0=öncelik, a1=görev)

MOVE.W    #$8040,$DFF096    ; blit'i etkinleştir
BTST.b    #6,$dff002    ; WaitBlit...
Wblittez:
BTST.b    #6,$dff002
BNE.S    Wblittez

MOVE.L    GFXBASE(PC),A6    ; GFXBASE in A6
jsr    -$E4(A6)	; Blit işleminin bitmesini bekle
JSR    -$E4(A6)    ; WaitBlit
jsr    -$1ce(a6)    ; DisOwnBlitter, işletim sistemi artık
; blitter'ı tekrar kullanabilir
MOVE.L    IntuiBase(PC),A0
CMP.W    #39,$14(A0)    ; V39+?
BLT.s    Çok eski
BSR.w    Sprite'ları geri koy
Çok eski:

MOVE.L    GFXBASE(PC),A6    ; GFXBASE A6'da
MOVE.L    $26(a6),$dff080    ; COP1LC - Eski sistem copper1'i işaret et
MOVE.L    $32(a6),$dff084    ; COP2LC - Eski sistem copper2'yi işaret et
JSR    -$10E(A6)    ; WaitOf ( Varsa interlace'i yeniden düzenle)
JSR    -$10E(A6)    ; WaitOf
MOVE.L    WBVIEW(PC),A1    ; Eski WBVIEW A1'de
JSR    -$DE(A6)    ; loadview - eski View'u geri yükle
JSR    -$10E(A6)    ; WaitOf ( Varsa interlace'i yeniden düzenle)
JSR    -$10E(A6)    ; WaitOf
MOVE.W	#$11,$DFF10C    ; Bu tek başına geri yüklemez..!
MOVE.L    $26(a6),$dff080    ; COP1LC - Eski sistem copper1'i işaret et
MOVE.L    $32(a6),$dff084    ; COP2LC - Eski sistem copper2'yi işaret et
moveq    #100,d7
RipuntLoop:
MOVE.L    $26(a6),$dff080    ; COP1LC - Eski sistem copper1'i işaret et
move.w    d0,$dff088
dbra    d7,RipuntLoop	; Güvenlik için...

MOVEA.L    IntuiBase(PC),A6
JSR    -$186(A6)    ; _LVORethinkDisplay - Tüm
; ekranı, ViewPorts ve olası
; interlace veya multisync modlarını da dahil olmak üzere yeniden çiz.
MOVE.L    a6,A1        ; Kütüphaneyi kapatmak için IntuiBase'i a1'e
move.l	4.w,a6        ; ExecBase A6'da
jsr    -$19E(a6)    ; CloseLibrary - intuition.library KAPALI
Exit1:
MOVE.L    GfxBase(PC),A1    ; GfxBase a1'de kütüphaneyi kapatmak için
jsr    -$19E(a6)	; CloseLibrary - graphics.library KAPALI
Exit2:
movem.l    (SP)+,d0-d7/a0-a6 ; Eski kayıt değerlerini geri al
RTS             ; ASMONE veya Dos/WorkBench'e geri dön

Sadece dört ayrıntı eklenmiştir: bunlardan biri, Graphics.library açıldıktan sonra yapılan kontrol,
 çünkü herhangi bir nedenle açılmaması durumunda,
 d0'da GfxBase adresi yerine SIFIR buluruz.
Tek yapmanız gereken, bir sözde “TST.L D0” ve açılmaması durumunda EXIT etiketine atlamaktır
.
 Condition Codes'u inceleyerek, d0'ın sıfırlanıp sıfırlanmadığını öğrenmek için neden “tst” kullanmadan bir move'dan sonra “beq” yapmanın yeterli olduğunu göreceksiniz.
Diğer bir ayrıntı ise sistem COPPER2'nin (GfxBase+$32)
ortaya çıkmasıdır. Bu, işletim sistemi tarafından $dff084, COP2LC'ye girilen değerden başka bir şey değildir
; Şu ana kadar copperlist 2'yi hiç kullanmadık, ancak ilerleyen derslerde
kullanışlı olduğu durumları mutlaka göstereceğiz.
Diğer bir “incelik” ise sprite'ları sıfırlamaktır, ancak bu sadece
kickstart 3.0 veya üstü sürümlerde mümkündür, çünkü sprite sıfırlama işlevi
bu sürümden itibaren kullanılabilir. Sprite'ları sıfırlayan SubRoutine
işletim sistemine yapılan çağrılarla “yasal” programlamanın klasik bir örneğidir
... göz atarsanız göreceğiniz gibi, 
işletim sistemini kullanmak, donanım üzerinden programlamaktan daha karmaşıktır (değil mi?).
Son olarak, görev önceliği ayarı vardır. Bildiğiniz gibi,
çoklu görevde çalışan her programın diğerlerine göre bir “önceliği” vardır.
Peki, onu en yüksek seviyeye alalım! Yani 127. Aslında buna gerek yok, çünkü
daha sonra çoklu görevi tamamen devre dışı bırakacağız, ancak daha sonra göreceğiz ki
önceliği en yüksek seviyeye ayarlamak ve çoklu görevi yeniden etkinleştirmek
disketten, sabit diskten veya CDrom'dan veri dosyalarını yüklemek için

Bu başlangıç ayarıyla, işletim sisteminin
sorunsuz bir şekilde “atlanabilmesi” için elimizden geleni yapıyoruz. Şimdi, Amiga'nın donanımını daha kapsamlı bir şekilde kontrol etmek için neler yapabileceğimize bakalım.
Amiga donanımını daha eksiksiz bir şekilde kontrol altına almak için neler yapabileceğimize bakalım.
Öncelikle, DMA KANALLARININ “kapatılması” veya “açılması” ve
kesintilerin ve diğer şeylerin etkinleştirilmesi için kullanılan DMACON, INTENA, ADKCON ve INTREQ kayıtları eklenmelidir.
 Şimdilik listelerde
COPPER, BITPLANES ve SPRITE'ların etkinleştirildiğini varsayıyoruz, çünkü
hem ASMONE (BITPLANE) metinlerini ve menülerini hem de
fare imlecini (SPRITE) görebiliyoruz. Bu, bu kanalların etkinleştirildiği anlamına gelir.
Ancak, ilgilendiğimiz kanalların etkinleştirildiğinden ve ilgilenmediğimiz kanalların
etkinleştirilmediğinden emin olmak için bu kayıtların durumunu kendimiz değiştirmemiz daha iyidir.
Bunu, copperlist için yaptığımız gibi, bu kayıtların durumunu başlangıçta kaydedip, ardından istediğimiz gibi etkinleştirip devre dışı bırakan kodumuzu çalıştırıp, son olarak kayıtları başlangıç durumuna geri getirerek yapabiliriz,
 sanki hiçbir şey olmamış gibi.
başlangıç durumuna geri getirin, sanki hiçbir şey olmamış gibi.
Ama önce bu DMA kanallarının ne olduğunu görelim.
DMA, “Direct Memory Access” yani “doğrudan bellek erişimi” anlamına gelir.
Aslında Amiga'da belleğe erişim çok karmaşıktır, çünkü belleğe
sadece işlemci değil, görüntüleri görüntülemek için bakır,
kopyalamak ve taşımak için blitter, sesleri çalmak için ses kartı da erişmelidir.
 Tüm bu işlemcilerin aynı anda belleğe (en azından CHIP belleğine) erişmek istemesi
ve “kazaların” meydana gelmesini önlemek için,
bir “trafik ışığı” ve viyadük sistemi kurulmuştur; bu, şehir planlama ve
ulaşımdan bahsedilebilir. Aslında AGNUS çipinde, işlemleri koordine eden bir DMA kanal yöneticisi vardır
 kanalları koordine eder ve kanal boş olduğunda özel çiplerin ve 68000'in “sırayla” 
belleğe erişmesini sağlar. Bu erişim hem
okuma hem de yazma olabilir (bakır bakırlitleri OKUR, ses
müziği OKUR, ancak blitter aynı zamanda görüntüleri de YAZAR, vb.).
Çeşitli DMA kanalları vardır, her biri belirli bir amaca adanmıştır, bunlara bir göz atalım:

1) DMA COPPER:     Bu kanal aracılığıyla bakır COPPERLIST'i okur.
Devre dışı bırakılırsa, bakır listesi artık okunmaz,
sonuç olarak bit düzlemleri ve sprite'lar kaybolur
ve arka plan rengini
WAIT'leri copperlist'e koyarak birkaç kez değiştirerek yapılan olası gölgeler de kaybolur.
Pratik olarak ekran tek renkli,
COLOR0 renginde kalır. Bu durumda ekran rengini
sadece işlemci ile “MOVE.W #xxx,$dff180” komutuyla değiştirebilirsiniz.

2) DMA SPRITE:     Bu kanal, SPRxPT kayıtlarında copperlist'te işaretlenen sprite yapılarının aktarımını gerçekleştirir.
Ancak, SPRxDAT kayıtlarına doğrudan yazarak
sprite'ları görüntülemek ve
DMA'nın işini manuel olarak yapmak mümkün olduğunu daha önce görmüştük.
SPRITE DMA kanalının tek kanalını devre dışı bırakarak, sprite'lar sıfırlanmış gibi kaybolur ve bitplane'ler ve WAIT ile elde edilen tonlamalar ekran üzerinde kalır. Sadece DMA SPRITE kanalını devre dışı bırakarak, sprite'lar sıfır
olarak işaretlenmiş gibi kaybolur ve ekran üzerinde bitplane ve
copperlist'teki WAIT ve MOVE ile elde edilen gölgeler kalır.
DMA BITPLANE devre dışı bırakıldığında, DMA
SPRITE aktif olsa bile sprite'lar kaybolur.

3) DMA BITPLANE: Bu kanalı devre dışı bırakıldığında, BPLxPT'de işaretlenen bitplane
artık görüntülenmez, ancak 
bakınız.
Bu kanalı kapatmak, BPLCON0'da ZERO bitplanes koymakla eşdeğer olabilir,
yani copperlist'te “dc.w $100,$200”.
DMA SPRITE'ın etkinleştirilmesi durumunda, DMA BITPLANE'in etkinleştirilmesi durumunda,
DMA BITPLANE devre dışı bırakıldığında,
sprite'lar bitplane'lerle birlikte kaybolur, DMA SPRITE kanalı
aktif olsa bile. Bu, BPLCON0'a sıfır bitplane koyduğumuzda da oluyordu.
4) DMA DISCO:     Okuma veya yazma sırasında sürücüden
CHIP belleğine veri aktarımı için kullanılır.

5) DMA AUDIO1     Amiga'nın 4 stereo ses kanalını kontrol eden 4 ayrı kanaldır.
DMA AUDIO2     Örneğin, ses kanalından ses çıkarmak için
DMA AUDIO3     DMA AUDIO1 kanalını açmanız ve sesi
DMA AUDIO4     sesini kapatmak için bu DMA kanalını kapatmanız yeterlidir. Tabii ki
Amiga sessizken, örneğin
WorkBench'i arka plan müziği olmadan kullanırken, 4 kanal daima kapalıdır.

6) DMA BLITTER:     Bu DMA, blitterin okuma ve yazma erişimlerini
yönetir. Blitterin DMA kanallarını
bu işlemciye ayrılmış derste inceleyeceğiz.

Peki, bellek erişim süresi işlemci ve
özel yongalar arasında nasıl bölünür? Bu, video çözünürlüğüne ve hangi kanalların
etkinleştirildiğine bağlıdır. Pratikte, ne kadar az kanal açıksa, 68000 ve
diğer CHIP'ler o kadar hızlı çalışır.
Video çözünürlüğü ve DMA arasındaki ilişkiye bakalım: video görüntüsü
raster çizgilerden, yani elektronik fırça ile çizilen çizgilerden oluşur
ve buna raster denir. $dff006 (VHPOSR) değerini okuyarak veya WAIT komutuyla copperlist kullanarak belirli bir dikey çizgiyi nasıl bekleyeceğimizi zaten biliyoruz.
Her raster çizgisinde 227,5 bellek erişimi mümkündür ve
DMA bunlardan sadece 225'ini kullanır. Eğer ilgilenirseniz, bir bellek erişim döngüsü
, 50Hz'de 320x256 PAL ekranda 0,00000028131 saniye sürer.
68000, her BUS döngüsünde belleğe erişmeye zaman bulamayacağı için,
 sadece çift döngülerde erişim izni vardır, yani 113 kez
aster. Sorun, Blitter ve Copper'ın da
çift döngülerde erişebilmesi ve zavallı 68000'den döngü çalmasıdır.
Tek döngüler ise DMA yöneticisi tarafından AUDIO,
DISCO, SPRITE erişimleri için kullanılır.
Özetle, raster hattı başına 227/228 döngü vardır ve bunlar çift ve
tek döngülere bölünmüştür. 113 tek döngüde, CHIP belleğine yalnızca
AUDIO, DISCO ve SPRITE sırayla erişebilir. 113 çift döngüde
BLITTER, COPPER ve 68000 sırayla belleğe erişebilir, ancak burada zavallı
68000'in önceliği düşüktür.
Blitter DMA devre dışı bırakıldığında, 68000'in
daha sık belleğe erişebileceğini, çünkü daha fazla çift döngü boş olacağını anlayabilirsiniz.
DMA copper'ın DMA BLITTER üzerinde önceliği olduğunu ve bunun da
68000 üzerinde önceliği olduğunu ve 68000'in FAST RAM'de çalışmasının daha iyi olacağını unutmayın.
Aslında, 68000'in çalıştırdığı kod CHIP RAM yerine FAST RAM'deyse
işlemci en ufak bir yavaşlama yaşamaz. Bu nedenle
kodu SECTION CODE ile fast ram'e koymak daha uygundur.
Bir örnek verelim: copper veriyolunu işgal ediyorsa, hem blitter
hem de 68000 bir sonraki çift döngüyü beklemelidir. Sorun şu ki,
 320x256 LOWRES çözünürlükte 6 bitplanes ile 68000
"sadece“ bakırın eşittir döngülerinin yarısını 6
bitplanes görüntülemek için, toplamda 56 döngü, 640x256 HIRES 16
renk durumunda, yani 4 bitplanes, bakır 68000'in neredeyse tüm eşittir döngülerini ”çalıyor" ve
sonuç olarak program yavaşlıyor (bilgisayarda FAST RAM yoksa).
Raster satırı sırasında DMA erişimleri belirli bir şemayı izler:
çift döngülerin COPPER, BLITTER ve 68000 arasında bölündüğünü gördük.
Tek döngülerde, DISCO, AUDIO,SPRITE ve BITPLANE erişimleri
şu sırayı izler: yatay çizgi $7'den $c'ye DMA DISCO erişimleri
,
 çizgi $D'den $14'e AUDIO erişimleri, $15'ten $34'e
SPRITE erişimleri ve son olarak $35'ten $e0'a BITPLANE erişimleri gerçekleşir.
Özetleyelim:

- HER RASTER ÇİZGİSİNDEKİ DMA ERİŞİM HARİTASI -

ÇİFT DÖNGÜLER: 113 adettir ve Copper, Blitter ve 68000 arasında bölünmüştür, burada
copper en yüksek önceliğe sahiptir, bu nedenle yüksek
çözünürlükte, örneğin 640x256, 4 bit düzlemde, 68000
hemen hemen hiç belleğe erişemez ve
çok belirgin bir yavaşlama meydana gelir. Tek çözüm, kodu hızlı RAM'e yerleştirmektir
, böylece işlemcide yavaşlama olmaz. Ayrıca,
68020 ve üstü işlemcilerde fast ram'deki kod her zaman
CHIP RAM'dekinden çok daha hızlıdır.

TEK DÖNGÜLER: 113 adettir ve Audio, Disco ve Sprite arasında şu sırayla bölünmüştür
:
yatay satır:

$07 - $0C    DMA DISCO erişimi
$0d - $14    4 DMA AUDIO kanalına erişim
$15 - $34    8 DMA SPRITE kanalına erişim
$35 - $e0    Bellekteki bit düzlemlerine erişim


Aslında programlama amacıyla bu teknik ayrıntıları bilmenize gerek yoktur,
 ancak DMA kanallarını tasarruf etmenin
maksimum çalışma hızına ulaşmak için ne kadar önemli olduğunu anlamanıza yardımcı olabilir.
Örneğin, bir prodüksiyonunuzda ekranın üst kısmında HAM veya HIRES
ekranınız varken, altta daha düşük çözünürlükte başka şeyler çalıştırıyorsanız
çözünürlükte başka şeyler çalıştırıyorsanız, ilk satırdan
“zorlu” ekranın sonuna kadar (örneğin 16 renkli hires) hem işlemci hem de
blitter yavaşlar ve kalan sürede
resmin altında kalabilir. Hız kazanmak için öncelikle
16 rengi yalnızca gerçekten gerekli olan yerlerde etkinleştirebilirsiniz, örneğin:


----------- ekran başlangıcı, BPLCON0 16 renk HIRES için ayarlanmış
\ SİYAH boşluk
/
*** ###*** ##***## ##** ##* #* # # # *#*# ### * ***#*##
*** ###*** ##***## ##** ##* #* # # # *#*# ### * ***#*## > ŞEKİL
*** ###*** ##***## ##** ##* #* # # *#*# ### * ***#*##
\ SİYAH alan
/
----- bplcon0 daha düşük çözünürlük için ayarlandı

**
**    > DÖNEN 3D TOPLAR VE KÜPLER
**
----- siyah alan


----- ekran sonu, dc.w $ffff,$fffe

Bu durumda bir copperlist'in kaydını görüyorsunuz.
Şeklin altındaki 3d rutininde, ellinciye kadar zamanında çalıştırılmak için çok az bir şeyin eksik olduğunu varsayalım.
 Copperlist'i ve rutini biraz değiştirmek yeterlidir,
 saniyede bir kare hızında çalışabilir, ne yapacağımıza bakalım:

COPPERLIST
dc.w    $100,$200    ; başlangıçtaki “SİYAH” alanda 0 bit düzlemi
dc.w    $3507,$fffe    ; şeklin başladığı satırı bekle
dc.w    $100,$c200    ; 16 renk yüksek çözünürlüğü etkinleştir
dc.w	$a007,$ffe    ; şeklin bittiği satırı bekle
dc.w    $100,$200    ; resmin altındaki SİYAH bölgede 0 bit düzlemi
dc.w    $b007,$fffe    ; siyah bölgenin sonunu bekle
dc.w    $100,$3200    ; vektör rutini için 3 bit düzlem düşük çözünürlük
dc.w    $e007,$fffe    ; bu satırın altında şekiller gelmez
dc.w    $100,$200	; bu nedenle dma'yı iyice kapatalım BITPLANE
;    ve belki COLOR0 ve WAIT ile bir gölgelendirme yapalım,
;    DMA'yı meşgul etmeden monitörün alt kısmını doldurmak için
;    dc.w
$ffff,$fffe


Abartmak için, şekillerin
ekranı yatay olarak tamamen doldurmadığı video penceresini daraltabiliriz. Şu durumu ele alalım:
ekranın ortasında dönen bir 3d katı var ve
onun üstündeki ve altındaki dma bitplane'i zaten kapattık:

---------- ekran başlangıcı, dc.w $100,$200



---------------- /\    ---- katı başlangıcı, dc.w $100,$3200
/ |\
/ | \
/ | \
\___|__/
--------------------------- katı nesnenin sonu, dc.w $100,$200

------------- ekranın sonu, dc.w $ffff,$fffe


Gördüğünüz gibi, katı nesne ekranın ortasında dönüyor ve
ekranın en sağ ve en sol alanlarını asla kaplamıyor. Bu noktada,
DIWStrt ve DIWStop üzerinde işlem yaparak ekranı biraz “kapatabiliriz”
ve sadece gerekli genişlikte bırakabiliriz, ardından üstüne veya altına daha geniş çizimler yapmak için
gerektiği kadar “genişletebiliriz”:


dc.w    $8E,$2c81	; DiwStrt normal genişlik için geniş şekil
dc.w    $90,$2cc1    ; DiwStop normal genişlik

WAIT

dc.w    $8E,$2c91    ; DiwStrt katı alan içinde daraltılmış
dc.w    $90,$2cb1	; DiwStop


Aslında video penceresini daraltarak DMA zamanından tasarruf ediyoruz, çünkü
bit düzlemlerinin aktarımı sadece tanımlanan video penceresinin içindeki alanda
gerçekleşiyor.

Bu konuyu kapatıp, bu kanalları nasıl açıp kapatacağımıza bakalım.
Amiga'da DMACon ($dff096) adlı bir donanım kaydı
(=DMA Denetleyici) adlı bir donanım kaydı vardır ve her bir DMA kanalının açılmasını yönetir.
DMAConW ($dff096) yalnızca olası değişiklikleri YAZMAK için kullanılırken,
DMAConR ($dff002) yalnızca çeşitli bitleri OKUMAK için kullanılır.
İşte 2 kayıt $dff096 ve $dff002'nin haritası: (aynıdır, ancak biri okuma,
 diğeri yazma içindir). Kayıt, $dff100 (BPLCON0) gibi BITMAPPED'dir,
 bu nedenle hangi bitlerin tek tek açık veya kapalı olduğunu sayar:

(NOT: 13 ve 14 bitleri sadece okunabilir (R), 15 bitleri sadece yazılabilir (W))

DMACON ($dff096/$dff002)

bit- 15 DMA Set/Clear        (W)    (sadece $dff096'dan yazılabilir)
14 BlitBusy (veya BlitDone)    (R)    (sadece $dff002'den okunabilir)
13 Blit Zero        (R)    (sadece okunabilir)
12 X            (kullanılmaz)
11 X            (kullanılmaz)
10    BlitterNasty (BlitPri) (R/W)    (R/W = Hem okunabilir hem yazılabilir)
9    Master    (DmaEnable)    (R/W) - “genel anahtar”
8    DMA BitPlane (RASTER)    (R/W) - BPLEN olarak da bilinir
7 Bakır DMA        (R/W) - COPEN olarak da bilinir
6 Blitter DMA        (R/W) - BLTEN olarak da bilinir
5 Sprite DMA    (R/W) - SPREN olarak da bilinir
4 Disk DMA        (R/W) - DSKEN olarak da bilinir
3 DMA Audio3 (ses 4)    (R/W) - yani AUD3EN
2 DMA Audio2 (ses 3)    (R/W) - yani AUD2EN
1 DMA Audio1 (ses 2)    (R/W) - yani AUD1EN
0 DMA Audio0 (ses 1)	(R/W) - yani AUD0EN

*SET/CLR
-Bit 15 çok önemlidir: eğer açıksa, $96'da yazma için 1 olarak ayarlanan bitler
ilgili DMA'ları açmak için kullanılır, bit 15 0 ise,
 kayıtta 1 olan diğer bitler ilgili kanalları kapatmak için kullanılır.
Daha açık bir şekilde açıklayayım: bir veya daha fazla kanalı açmak veya kapatmak için
ilgili bitleri 1 olarak ayarlamak gerekir; bu kanalların
kapatılması veya açılması gerektiğini belirleyen bit 15'tir: 1 ise açılır,
0 ise kapanır (önceki durumlarından bağımsız olarak).
Hangi OPERATE'leri seçeceğinize karar verdikten sonra, bit 15'e göre kapatmak (0) veya
açmak (1) kararını verirsiniz.
Bir örnek verelim:
;5432109876543210
move.w #%1000000111000000,$dff096    ; bit 6, 7 ve 8 AÇIKTIR
;5432109876543210
move.w #%0000000100100000,$dff096    ; bit 5 ve 8 KAPALI.


NOT: BIT 14-10, BLITTER VE ÇİPİN SAAT DÖNGÜLERİ İLE İLGİLİDİR.
BU KONU DAHA SONRA KAPSAMLI OLARAK ELE ALINACAKTIR.
BU DERSDE KULLANILMAYACAKTIR.

*BlitBusy
-Bit 14 sadece okunabilir (SADECE $dff002'den okunabilir) ve
blitterin o anda “blittering” (yani çalışıp çalışmadığını) bilmek için kullanılır.
Bu bit, blitterin çalışıp çalışmadığını bilmek için kullanılır,
çünkü, daha sonra göreceğimiz gibi, blitter çalışırken
blitter kayıtlarını değiştirmek mümkün değildir... aslında mümkündür, ancak
felaketle sonuçlanır! Bu nedenle, blitteri yeniden kullanmadan önce bu bitin 0 olmasını
bir btst ile beklemek gerekir.

*Blit Sıfır
-Bit 13, bir blit işleminin sonucu 0 olduğunda, yani
herhangi bir blit işlemiyle değiştirilen RAM tamamen
0 olarak ayarlandığında ayarlanır. Bu birçok durumda meydana gelebilir, ancak
bu biti yalnızca nadir durumlarda okumak daha kullanışlıdır, aslında
(örneğin: iki nesnenin -bob- RAM'i değiştirmeden çarpışıp çarpışmadığını kontrol etmek için), ancak bunu
daha sonra ayrıntılı olarak ele alacağız.

-12-11 bitleri şu anda makine tarafından kullanılmamaktadır.

*BlitPri
-Bit 10, ayarlandığında, blitterin mevcut tüm bus döngülerini
kullanmasını sağlar ve “zavallı 68000”in kullanabileceği az sayıdaki döngüyü de “çalarak”.
 Bu, Fast veya ROM'a erişirse yavaşlamaz,
aksi takdirde Chip'e erişirken durur.
Pratikte, bu bit 1 olduğunda, blitter 680x0 üzerinde tam
öncelik yerine tam önceliğe sahiptir

*DmaEn/Master
-Bit 9 genel anahtardır: Çeşitli cihazların DMA'larının çalışması için 1 olarak ayarlanması gerekir
. Örneğin,
tüm kayıtları sıfırlamadan tüm kanalları geçici olarak devre dışı bırakmak için kapatılabilir
.

-Bit 8-0, çeşitli cihazların DMA kanallarını açmak/kapatmak için kullanılır.

Esasen, yalnızca bit 10-0, bit 15 kullanılarak değiştirilebilir (değiştirilebilir).
Örneğin, şimdi yalnızca plane, copper ve blitter'ın DMA'larını açmayı deneyelim.
Bunu yapmak için, önce tüm kanalları kapatmak için kaydı sıfırlamak
ve böylece istenmeyen DMA'ları devre dışı bırakmak gerekir;
ardından istenen DMA'ları ayarlayın:

move.w    #$7fff,$dff096            ; $7fff = %0111111111111111
; yani: her şey kapalı:
; bit 15 SIFIR'da, bu nedenle
; tüm 1'ler
; bu durumda KAPALI anlamına gelir.
; 5432109876543210
move.w    #%1000001111000000,$dff096    ; bitler 6,7,8,9 ayarlandı, yani
; BLITTER,COPPER,BITPLANE
; ve genel anahtar
; bit 15 1'e, dolayısıyla tüm
; 1'ler AÇIK anlamına gelir

Değer $7fff, %0111111111111111'dir, bu nedenle tüm DMA bitleri sıfırlanır.
Ardından, Copper, Plane ve blitter DMA'ları ve
1 olarak ayarlanan bit 15 sayesinde master DMA'lar ayarlanır!

BU ÇOK ÖNEMLİ KAYDIN ÇALIŞMASI, ‘INTENà VE 'INTREQ’ KAYITLARININ ÇALIŞMASINA BENZERDİR, BU NEDENLE
BIT 15'İN “AÇ/KAPAT” BİTİ OLARAK ÇALIŞMASI KONUSUNDA ŞÜPHENİZ KALMAYANA KADAR DEVAM ETMEYİN.
Şimdiye kadar gördüğümüz listelerde $dff096 (DMACON) ve $dff002 (DMACONR) kayıtları hiç kullanılmamıştır, çünkü

Şimdiye kadar gördüğümüz listelerde
$dff096 (DMACON) ve $dff002 (DMACONR) kayıtları hiç kullanılmadı, çünkü
bakır, bit düzlemleri ve sprite'ların DMA kanallarının etkin olduğunu varsaydık.
Aslında, programın çalıştırılması sırasında
asm ekranını görebiliyorsanız, bu hem COPPER hem de BITPLANE dma'nın
etkin olduğu anlamına gelir. İşaretçi okunun varlığı, bunun
DMA SPRITE ile görüntülendiğini gösterir. Ancak donanım düzeyinde programlama yaparken
ödün veremezsiniz, her şeyin istediğiniz gibi olmasını
 "her şeyin istediğimiz gibi olmasını ummamalıyız. Copperlist'teki TÜM kayıtların
BPL1MOD, DIWSTART/STOP vb. olarak ayarlamanın ne kadar önemli olduğunu gördük, aksi takdirde garip değerlerle karşılaşabiliriz.
 Aynı şeyi DMA kanalları için de yapacağız: başlangıçta durumlarını kaydedeceğiz,
 sonra hepsini kapatıp sadece istenenleri açacağız
ve sonunda DMA kanallarını başlangıç durumuna geri getireceğiz, tıpkı
aynı şekilde yapacağız.
DMACON durumunu okumak için DMACONR'den,
yani $dff002'den okumak gerektiğini söylemiştik. Bir “kaydetme” rutini şöyle olabilir:

move.w    $dff002,OLDDMA    ; DMACONR - DMA durumunu kaydeder

Şimdi, yazma kaydı olan $dff096 üzerinde işlem yaparak bunu istediğimiz gibi değiştirebiliriz
:

move.w    #$7fff,$dff096	; DMACON - tüm kanalları sıfırla

; 5432109876543210
move.w    #%1000001110100000,$dff096 ; Copper, Bitplane ve Sprite'ı etkinleştiriyorum

Daha kolay olamazdı. Şimdi, çıkmadan önce eski değeri geri koymamız gerekiyor
.
 Ancak DİKKAT! OLDDMA'yı DMACON ($dff096)
'a DMACONR ($dff002) 'dan okuduğumuz gibi doğrudan koyamayız, çünkü
bit 15, SET/CLR bitidir ve sadece yazma içindir ve okuma sırasında her zaman sıfırdır,
bu nedenle bit 15 sıfırlanarak değer geri yüklenirse, bitler
DMA kanallarını açmak yerine kapatabilir. Bu nedenle,
OLDDMA'da kaydedilen değerin bit 15'ini ayarlamadan önce, bu şekilde
bitler AÇIK olarak değerlendirilecektir. Peki, bir
word'un 15 bitini nasıl ayarlayabiliriz? Bunun sonsuz yolu vardır. Bunlardan biri BSET komutunu kullanmaktır,
örneğin:

move.w    $dff002,d0    ; DMACONR'yi d0'a kaydederim
bset.l    #15,d0        ; 15 bitini ayarlarım (SET/CLR)
move.w    d0,OLDDMA    ; ve değeri OLDDMA'ya kaydeder
...
bsr.w    routines
...
move.w    #$7fff,$dff096        ; tüm kanalları sıfırlar
move.w    OLDDMA(PC),$dff096	; sadece başlangıçta
rts                ; aktif olanları yeniden etkinleştir.

Aksi takdirde OR komutunu kullanabilirsiniz. Bitler üzerindeki etkisini hatırlayalım:

0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1

Önceki örnek şu şekilde olur:

or.w    #$8000,OLDDMA    ; $8000 = %1000000000000000, yani bit 15'e 1

Yukarıdaki tablodan da görebileceğiniz gibi, sıfırlanan bitler hedefi değiştirmez,
 bu durumda ilk 14 bit sıfırlanır, dolayısıyla OR işleminden sonra OLDDMA'nın ilk 14
bit'i değişmez (0 OR 0=0, 0 OR 1=1).
15. bit ayarlandığından, 1 OR 0=1 olur, bu nedenle
15. bit ayarlanır ve diğer 14 bit değişmeden kalır. BTST #15,d0 ile aynıdır.
Başlangıçta OR kullanılması daha uygundur, çünkü DMACON dışında
diğer kayıtlar da kaydedilir. Bunlar INTENA ($dff09a yazma ve $dff01c
okuma), INTREQ ($dff09c yazma ve $dff01e okuma) ve ADKCON ($dff09e
yazma ve $dff010 okuma) kayıtlarıdır. Şimdilik, bu
kayıtların DMACON gibi botmapped olduğunu ve SET/CLR olarak kullanılan bit
15 ile benzer şekilde çalıştığını söyleyebilirim. INTENA ve INTREQ kesmeler için kullanılırken,
ADKCON ise DISK DRIVE ve AUDIO için çeşitli görevlerde kullanılır. Bu kayıtların nasıl kullanıldığını
kesintiler ve ses ele alındığında göreceğiz, şimdilik
DMACON ile birlikte durumlarını kaydedelim. Şimdi bu 4 kaydı nasıl kaydedeceğimize bakalım:

LEA    $DFF000,A5        ; CUSTOM kayıtlarının Offsetleri için taban
MOVE.W    $2(A5),OLDDMA        ; DMACONR - DMA durumunu kaydeder
MOVE.W    $1C(A5),OLDINTENA    ; INTENA'nın eski durumunu kaydeder
MOVE.W    $10(A5),OLDADKCON    ; ADKCON'un eski durumunu kaydeder
MOVE.W	$1E(A5),OLDINTREQ    ; INTREQ'nin eski durumunu kaydeder

Şimdi, çıkışta değeri geri yükleyebilmek için
OLDDMA,OLDINTENA,OLDADKCON,OLDINTREQ etiketleriyle işaretlenmiş 4 kelimenin tümünün 15 bitini ayarlamamız gerekiyor.
 4 etiketin arka arkaya yerleştirildiğini unutmayın:

OLDDMA:			; Eski DMACON durumu
dc.w    0
OLDINTENA:        ; Eski INTENA durumu
dc.w    0
OLDADKCON:        ; Eski ADKCON durumu
DC.W    0
OLDINTREQ:        ; Eski INTREQ durumu
DC.W    0

Böylece OR devreye girer. Bir kelime için OR.w #$8000,dest
yeterliyse, tek bir OR ile 2 kelimeyi OR.L #$80008000,dest ile düzeltebiliriz!!!
Bu durumda 4 kelime için bu OR'lardan bir çift yeterlidir:

MOVE.L    #$80008000,d0		; Yüksek bit maskesini hazırlar
; kayıtların
; kaydedildiği kelimelerde ayarlanacak
OR.L    d0,OLDDMA    ; Tüm kaydedilen değerlerin bit 15'ini ayarlar
OR.L    d0,OLDADKCON    ; donanım kayıtlarının,
; bu değerleri kayıtlara geri koymak için gereklidir.

İşte birkaç komutla, hemen sonra sıfırlayacağımız 4 kaydı da kaydettik ve “ayarladık”
:

MOVE.L    #$7FFF7FFF,$9A(a5)    ; KESİNTİLERİ VE INTREQS'leri DEVRE DIŞI BIRAK
MOVE.L    #0,$144(A5)        ; SPR0DAT - işaretçiyi yok et!
MOVE.W    #$7FFF,$96(a5)        ; DMA'LARI DEVRE DIŞI BIRAK

Bu noktada, sadece ihtiyacımız olan DMA kanallarını etkinleştirebiliriz.
Çıkışta, tüm kayıtları sıfırlamak ve geri yüklemek yeterlidir:

MOVE.W    #$7FFF,$96(A5)        ; TÜM DMA'LARI DEVRE DIŞI BIRAK
MOVE.L    #$7FFF7FFF,$9A(A5)    ; KESİNTİLERİ VE INTREQS'leri DEVRE DIŞI BIRAK
MOVE.W    #$7fff,$9E(a5)        ; ADKCON bitlerini devre dışı bırak
MOVE.W    OLDADKCON(PC),$9E(A5)    ; ADKCON
MOVE.W    OLDDMA(PC),$96(A5)    ; Eski DMA durumunu geri yükle
MOVE.W    OLDINTENA(PC),$9A(A5)    ; INTENA DURUMU
MOVE.W    OLDINTREQ(PC),$9C(A5)    ; INTREQ

Daha basit olamazdı! Artık DMA kanallarını tamamen kontrol ediyoruz ve
istediğimiz gibi etkinleştirebilir ve devre dışı bırakabiliriz, çünkü
çıkışta geri yüklenirler.

Başlangıcımızı tamamlamak için bir EQUATE tanımlayabiliriz. EQUATES'in ne olduğunu hatırlıyor musunuz?
EQU veya = assembler direktifleri, istediğiniz gibi uydurduğunuz kelimeler ile sayılar arasında eşitlikler tanımlar, örneğin:
CANE    EQU    10
GATTO    EQU	20

MOVE.L    #CANE,d0    ; MOVE.L #10,d0 olarak derlenir
MOVE.L    #GATTO,d1    ; MOVE.L #20,d1 olarak derlenir
ADD.L    d0,d1        ; SONUÇ = 30
rts

Eşlemeler etiketlere benzer, ancak : ile bitmez. EQU
yerine eşittir (=) kullanılabilir:

KÖPEK    =    10

Ayarlamak için DMA kanalları için bir EQU tanımlayabiliriz:

;5432109876543210
DMASET    EQU	%1000001110000000    ; bakır ve bitplane DMA etkinleştirildi
;         -----a-bcdefghij

;    a: Blitter Nasty (Şu anda ilgimizi çekmiyor, sıfırda bırakalım)
;    b: Bitplane DMA     (Ayar yapılmazsa, sprite'lar da kaybolur)
;	c: Copper DMA     (Sıfırlandığında copperlist de çalışmaz)
;    d: Blitter DMA     (Şu anda ilgilenmiyoruz, sıfırlayalım)
;    e: Sprite DMA     (Sıfırlandığında sadece 8 sprite kaybolur)
;    f: Disk DMA     (Şu anda ilgilenmiyoruz, sıfırlayalım)
;    g-j: Audio 3-0 DMA (Amiga'yı sessize alarak sıfırlayalım)

Gördüğünüz gibi, bit 15 ve 9 HER ZAMAN AYARLANMALIDIR, çünkü biri
SET/CLR ve diğeri Master, genel anahtardır.
Listede şunu yazabilirsiniz:

MOVE.W	#DMASET,$96(a5)        ; DMACON - bitplane ve copper'ı etkinleştirir

Böylece listenin başında değiştirilecek EQU'yu
altında bitlerin anlamlarını içeren kısa bir yardım özeti ile görebiliriz.

Şimdi başlangıcı görelim, Lezione8a.s metin tamponuna yükleyin ve inceleyin.
Son yorumda bazı küçük değişikliklerle ilgili notlar bulunmaktadır.

· ·
¦ . .__ :
: ·^·¯¯\ __¡__
_ _|__ _______ ____________ /\ \______________ _________ ____\ //____ _
¯ ¯|¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯\/ \ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯\//¯¯¯¯¯ ¯
: _ø , \__. . ¦
¦ //\/ ¯¯·^· /\__. . :
· '/\ / ¯¯·^· :
_ _|___ ____________/ /_____ _________ / /\________ ______ ____|______ _
¯ ¯|¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯\/ / ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯|¯¯¯¯¯¯ ¯
¦ . . .__ / ·
: “COi! Ðe$¦gN” ·^·¯¯\/ :.
 ·
· .
.

Artık “evrensel” başlangıç kodumuz olduğuna göre, bunu ayrı bir dosyaya kaydedip
INCLUDE komutuyla sonraki listelerin başına ekleyebiliriz.
Bu komutu daha önce müzik rutinini eklemek için kullanmıştık.
Her listeyi şu şekilde başlatmak yeterlidir:

Section    UsoLaStartUp,CODE

*****************************************************************************
include    “startup1.s”    ; bu include ile
; her seferinde yeniden yazmaktan kurtuluyorum!
*****************************************************************************

Startup1.s'in SECTION olmadan başlangıç dosyası olduğunu unutmayın, bu nedenle
her seferinde include'dan önce SECTION name,CODE veya CODE_C komutunu eklemeliyiz.
Startup “BSR.S START” komutunu verir, bu nedenle listelemeyi şöyle başlatacağız:

START:
MOVE.W	#DMASET,$96(a5)        ; DMACON - bitplane, copper
; ve sprites'i etkinleştirir.

move.l    #COPPERLIST,$80(a5)    ; COP'umuzu işaretleyelim
move.w    d0,$88(a5)        ; COP'u çalıştıralım
move.w	#0,$1fc(a5)        ; AGA'yı devre dışı bırak
move.w    #$c00,$106(a5)        ; AGA'yı devre dışı bırak
move.w    #$11,$10c(a5)        ; AGA'yı devre dışı bırak

a5'te $dff000 olduğunu unutmayın. Bu durumda onu kullandım.

Mükemmel bir başlangıç gibi görünüyor, ancak henüz son dokunuş eksik.
Bu son dokunuş, programı WorkBench simgesinden
sorunsuz bir şekilde başlatma olanağıdır. Aslında, programlarımızı cli/shell
'den başlattığımız sürece bu başlangıç yeterlidir, ancak
WorkBench'ten çift tıklayarak başlatmak için simgeler çizmek istiyorsanız
bazı komutlar eklemeniz gerekir. Bu sadece bir formalitedir, ancak
büyük programlarda, bellek tahsis eden programlarda, çıkışta
tüm bellek serbest bırakılmayabilir veya daha kötüsü olabilir.
Başlangıca eklemeniz gerekenler şunlardır:

ICONSTARTUP:
MOVEM.L    D0/A0-A1/A4/A6,-(SP)    ; kayıtları yığına kaydeder
SUBA.L    A1,A1
MOVEA.L    4.w,A6
JSR    -$126(A6)    ; _LVOFindTask(a6)
MOVEA.L    D0,A4
TST.L    $AC(A4)        ; pr_CLI(a4) CLI'dan mı çalışıyoruz?
BNE.S    FROMCLI        ; evet ise, formaliteleri atla
LEA    $5C(A4),A0	; pr_MsgPort
MOVEA.L    4.W,A6        ; Execbase in a6
JSR    -$180(A6)    ; _LVOWaitPort
LEA    $5C(A4),A0    ; pr_MsgPort
JSR    -$174(A6)    ; _LVOGetMsg
LEA    RETURNMSG(PC),A0
MOVE.L    D0,(A0)
FROMCLI:
MOVEM.L    (SP)+,D0/A0-A1/A4/A6    ; kayıtları yığından geri yükle
BSR.w    MAINCODE    ; programımızı çalıştır
MOVEM.L    D0/A6,-(SP)
LEA	RETURNMSG(PC),A6
TST.L    (A6)        ; CLI'dan mı başladık?
BEQ.S    ExitToDos    ; evet ise, formaliteleri atla
MOVEA.L    4.w,A6
JSR    -$84(A6)    ; _LVOForbid - not! İzin gerekmez
MOVEA.L	RETURNMSG(PC),A1
JSR    -$17A(A6)    ; _LVOReplyMsg
ExitToDos:
MOVEM.L    (SP)+,D0/A6        ; çıkış kodu
MOVEQ    #0,d0
RTS

RETURNMSG:
dc.l    0

İşletim sisteminin kütüphanelerine yapılan çağrıları ayrıntılı olarak yorumlamayacağım,
 bunların bahsettiğim formaliteler olduğunu bilmeniz yeterlidir.
Workbench'ten başlangıcında bu kod bulunmayan bir program çalıştırırsanız,
 en büyük sorun, programdan çıktığınızda
programın kapladığı bellek boşaltılmamasıdır!!!
Gördüğünüz gibi, başlangıçta programın CLI'dan mı yoksa WorkBench'ten mi çalıştırıldığı
,
 özel bir sistem bayrağı kontrol edilerek kontrol edilir.
Program CLI'dan başlatılmışsa, WB'den çalıştırma durumunda
izlenecek formaliteler atlanır. Aksi takdirde, bu formaliteler yerine getirilir.
Bu parçayı diğer başlangıç dosyasına eklemek yerine, ayrı tutmak daha iyidir,
 böylece dahil edip etmemeyi seçebilirsiniz, çünkü bazı derleyiciler, dersin değiştirilmiş ASMONE sürümü de dahil olmak üzere,
 çalıştırma sırasında
sonsuz bir döngüye neden olurlar, çünkü “WorkBench tarafından yüklenmiş gibi görünürler, ancak
”formaliteler" yürütüldüğünde tam tersi gibi görünürler. Diğer
Asmone sürümleri veya diğer derleyiciler ise bu kodu sorunsuz bir şekilde yürütürler,
 ancak her derleyiciyle uyumluluk için bunu ayrı tutmak tercih edilir
:

;    Include    “DaWorkBench.s”    ; “WO” ile kaydetmeden önce ; işaretini kaldırın

Bu şekilde, ‘J’ ile derleme ve testler sırasında bunu dahil etmiyoruz,
ancak “WO” ile nihai yürütülebilir dosyayı kaydetmeden önce dahil ediyoruz.

Lezione8b.s dosyasını yükleyin, INCLUDE ile dahil edilen evrensel başlangıcı kullanan ilk liste.
Bit düzlemlerinin ve sprite'ların kullanımını içerir,
bu nedenle DMA kanallarının etkin olup olmadığını kontrol etmek için testler yapabilirsiniz.
__ __ __ __ __ __ __ /\_/_/\__ __ / /\__ __ / /\ /\ \ __ __/\ \ __ __/\_\_/\ / / \_\/_/\_/_/\_/_/ / /
__ __ __ __ __ __ __ __
/\_/_/\__ __ / /\__ __ / /\ /\ \ __ __/\ \ __ __/\_\_/\
/ / \_\/_/\_/_/\_/_/ / /\_/_/\_/_/ \_/ \_\_/\_\_/\ \ \_\_/\_\_/\_\/_/ \ \_
\/ \_\/ \_\/ \_\/_/ / \_\/ \ \ / \ / / \/_/ \ \_\/_/ \/_/ \/_/ \/_
-:-----:------------\_\/--------\_\/---\/_/--------\/_/---------------------

Dikey çizgiyi bekleyen YENİ rutin görünce korktunuz mu?
Aslında korkacak bir şey yok, aksine çok daha iyi.
Eski “rutini” inceleyelim:

cmp.b    #$xx,$dff006    ; VHPOSR

Aslında, sadece $dff006 baytını kontrol ediyoruz, bu bayt elektronik fırçanın dikey konumunu,
 0'dan 7'ye, yani $00'dan $ff'ye kadar olan bitleri içerir.
Ancak, copperlist'teki WAIT yönetiminden bildiğiniz gibi, elektronik fırça
$FF çizgisini aşıyor, ki bu aslında normal bir ekranda 200'den başka bir şey değil.
COPPER'daki WAIT ile $FF'nin ötesindeki konumlara ulaşmak için
bu bölgenin sonunu beklememiz gerektiğini gördük:

dc.w    $FFDF,$FFFE    ; NTSC bölgesinin sınırını bekleyin

Bundan sonra sayaç $00'dan yeniden başlar

dc.w    $0007,$FFFE    ; $100 satırını bekleyin
dc.w    $0107,$FFFE    ; $FF+$01=$101 satırını bekle

$38'e kadar. Peki, $dff006'daki bayt da bu şekilde davranıyor: bir
kez $ff konumuna ulaştığında $00'dan yeniden başlar, ancak $100'u gösterir ve
$138'e kadar devam eder (38 ile), ardından $00'dan, gerçek SIFIR'dan yeniden başlar
ve sonra tekrar $ff'ye ulaşır, diğer 38'i yapmak için, vb.
Bu nedenle listelerde her zaman $FF satırı veya $80 satırı beklenir, çünkü
$dff006 ile $00 satırı veya $20 satırı beklenirse,
$00 satırı $00 satırında ve $100 satırında gerçekleştiği için
rutin her kare için 2 kez çalışır.
Peki, ilk 38 satırı ve
$ff'den sonraki satırları rahatça beklemek için ne yapmalıyız? Kısacası, taramanın 312 satırından herhangi birini hatasız bir şekilde bekleyen bir rutin gerekiyor.
Bu zor değil, çünkü YÜKSEK bit, sekizinci bit,
$dff006'ya çok yakın, tam olarak bir önceki bayt olan $dff005'te bulunuyor.
Sprite'ların dikey konumunda yaptığımız gibi yapmalıyız,
çünkü yüksek bit ayrıdır.
Ancak bu durumda, bellekte değil, söz konusu baytın hemen önündedir.
 Durumu analiz edelim:


$dff004 baytı şu anda bizi ilgilendirmiyor, interlace için LOF bitini içerir
$dff005 bizim için önemli! bit 0, V8, yani dikey konumun yüksek biti.
$dff006'yı artık biliyoruz! V7-V0 bitleri, dikey konumun 8 düşük biti.
$dff007 yatay konumu (H8-H1) içerir. Çözünürlük 1/160
ekran. Şimdi bu bizi hiç ilgilendirmiyor!!!

$dff004/$dff005 VPOSR kaydıdır, $dff006/$dff007 ise VHPOSR'dir
.
 Her kayıt bir WORD uzunluğundadır. Ancak bazı durumlarda bunlara
tek tek baytlar olarak erişebiliriz. $100 satırını beklemek için şöyle yapabiliriz:

WaitVbl:
btst.b    #0,$dff005
beq.s    WaitVbl

Bu rutin, üst bit olan V8'in ayarlanmasını bekler. Ayarlanmışsa,
 $100 satırında veya en azından ondan sonra olduğumuz anlamına gelir.
EVRENSEL bir rutin yapmak için şöyle yapabiliriz: (a5=$dff000)

Waity1:
MOVE.L    4(A5),D0    ; $dff004 ve $dff006, yani VPOSR ve VHPOSR
LSR.L	#8,D0        ; bitleri 8 pozisyon sağa kaydır
AND.W    #%111111111,D0    ; Sadece dikey pozisyonun bitlerini seç
CMP.W    #300,D0        ; 300. satır mı? ($12c)
bne.s    Waity1

Bu durumda, $dff004/5/6/7'yi d0'a kopyaladık, ardından tümünü
sağa 8 bit kaydırdık, çünkü sağdaki ilk 8 bit, ilgilenmediğimiz
$dff007'nin yatay konumu tarafından işgal edilmiştir, böylece
dikey konumu en sağa getirilmiştir. Bu noktada, bir AND ile, sadece
ilk 8 biti, yani $dff006'nın bitleri ile $dff005'in en üst bitini seçiyoruz.
Böylece d0'da 0'dan 312'ye kadar gerçek hat numarasını elde ediyoruz!
AND komutunun şu etkiye sahip olduğunu hatırlatmak isterim:

0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1

Aslında AND, yalnızca ilk işlenenin biti
ve ikinci işlenenin biti 1 olduğunda 1 sonucunu verir, komut şu şekilde çevrilebilir
“İLK VE İKİNCİ BIT 1 Mİ? EVETSE, 1 İLE CEVAP VER, HAYIRSA
SIFIR İLE CEVAP VER”. AND, bir sayının belirli bitlerini sıfırlamak için kullanışlıdır
. Bizim örneğimizde, yüksek bitleri sıfırladık:

AND.W    #%00000000000000000000000111111111,d0

Onaltılık sistemde daha açık görünebilir:

AND.W    #$000001FF,D0    ; sadece alt bayt artı bit 8.

Tek dezavantajı, 4 komut gerektirmesidir. Sadece 3 komut kullanan bir
rutin yazalım:

WBLANNY:
MOVE.L	4(A5),D0    ; VPOSR ve VHPOSR - $dff004/$dff006
AND.L    #$0001FF00,D0    ; Yalnızca dikey konumdaki bitleri seçer
CMP.L    #$00013000,D0    ; $130 (304) hattını bekle
BNE.S	WBLANNY

Bu durumda, bitleri kaydırmadan (shift) tüm uzunluk üzerinde çalışıyoruz.
Beklenmesi gereken satır numarasının 2 basamak sola kaydırıldığını unutmayın.
 Örneğin, $FF satırını beklemek için:

CMP.L    #$0000ff00,D0    ; $130 (304) satırını bekle

kesinlikle daha iyi ve daha hızlıdır. Her zaman bu
rutini kullanmanızı tavsiye ederim. Aksi takdirde, birkaç kayıt daha “kirletmek”
sorun değilse, Lezione8b.s'de bulunan turbo versiyonu da vardır:


MOVE.L    #$1ff00,d1    ; AND ile seçim için bit
MOVE.L    #$13000,d2    ; beklenecek satır = $130, yani 304
Waity1:
MOVE.L    4(A5),D0    ; VPOSR ve VHPOSR - $dff004/$dff006
ANDI.L    D1,D0        ; Yalnızca dikey konum bitlerini seçer
CMPI.L    D2,D0        ; $130 (304) hattını bekler
BNE.S    Waity1

Gördüğünüz gibi, esasen hiçbir şey değişmez, sadece işlemler
sabitler arasında değil, kayıtlar arasında yapılır ve bu daha hızlıdır.
Hız önemlidir, çünkü örneğin 50. satırı
LSR'nin de olduğu ilk rutinde bekletirseniz, işlemci
tüm testleri bitirip 50. satırda olduğumuzu fark ettiğinde, biz çoktan
50. satırın ortasına gelmiş oluruz!

Sadece, temel olarak kullandığınız kayıtlara bağlı olarak a5 veya a6'da
her zaman $dff000'ın bulunduğundan, yani herhangi bir alt rutin tarafından
üzerinin yazılmadığından emin olmanızı tavsiye ederim. Bunu önlemek için, kayıtları
daha önce açıklandığı gibi MOVEM ile kaydedebilir veya
 “MOVE.L #$1ff00,d1” komutunun altına bir LEA $dff000,a5 ekleyebilirsiniz. Aynı şey d0, d1 ve d2 kayıtları için de geçerlidir, bunları değiştirdiğiniz için
başka programlar tarafından kullanılmadığından emin olmalısınız.

Son olarak, $138 satırını asla geçmeyin, çünkü bu son satırdır,
 aksi takdirde rutin sonsuz bir döngüye girer.

Video NTSC frekansına ayarlanmışsa ($dff1dc sıfırlanarak),
maksimum sınır $106 satırıdır.

ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ
ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ
ØØØØ ÍØØØØ
ØØØØ ___ ÍØØØØ
ØØØØ __øØ@**#__ ____ææææ_ [ØØØØ
ØØØØ gØ°¯ °4æ_ __øØ@¤°¨¯¯¯¯¶& ÌØØØØ
ØØØØ ,ØP ¬0þ¸ ,gØ¤°¯ 0Q [ØØØØ
ØØØØ Ø~ _______ °Ø_ _Ø° ___ææØØØ, ÌØØØØ
ØØØØ ØØØØØØØØm_ °Ø_ _ ,_/Ø´ _æØØØØØØØØ
ØØØØ °°¤ØØØØØØØQ__ °#_Ø IØÞ _ÆØØØØØØØ@° ÍØØØØ
ØØØØ _ `ØØØØØØØØæ_ ¬¢² dØØØÑØØØØ³ ]ØØØØ
ØØØØ `Øæ¸ ØØØ1 "¢ØØØQ__ ÆØØØ´ ¶ØØØ¸ ÌØØØØ
ØØØØ VØ#_ #ØØò (æ °ØØØØø ØØØ° æ) ¶ØØ# ,® ]ØØØØ
ØØØØ Ø#Ø_ ¬ØØØQ___ØØØØØØ «ØØØæ__ JØØØ ¸ØF ÍØØØØ
ØØØØ ¬Ø_`N_ ¢ØØØØØØØ²°°¯___¬°0ØØØØØØØØ _Ø° [ØØØØ
ØØØØ °ØµØÑ&_ ¨°°°~ ¸ØØØØØ, ¯~°°°°“_.øØ¹ ]ØØØØ
ØØØØ #Ø ¬ØQ_ ¬Ø' ¬¤° ___ææØ¤°ØP IØØØØ
ØØØØ `W_ØP4MøææææææææææææØØØ¤°”Ø _Ø° ]ØØØØ
ØØØØ ¬ØØ_ 0F¯¯7#¯¯¯¬Ø¯¯¯¯TØ ØØ@´ ÌØØØØ
ØØØØ ¬#ØØØæ._àW___jØ____jØ_æøØ³ [ØØØØ
ØØØØ ¢#ØF¨°¶Ø^^¤4Ø¤¤°°¢ØØØ^ [ØØØØ
ØØØØ °«N__IN_ Ø___æØ»° [ØØØØ
ØØØØ °^¤*#ØØØØ@¤°" xCz IØØØØ
ØØØØ ÍØØØØ
ØØØØL__________________________________________________IØØØØ
ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ
ØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØØ


DMA'ları kaydetmek
ve VBLANK hattını daha iyi kontrol etmek için AND/OR/LSR komutlarının yararını gördükten sonra, bu mantık komutlarının yeni kullanımlarına geçelim
. Şüphesiz, bir figürü siyah renkten yavaş yavaş
parlak ve tam renge doğru (ve tersi) solma
etkisi yaratan bir solma rutini
nasıl yapılacağını analiz etmek gerekir.

CopColors:
dc.w $180,0,$182,0,$184,0,$186,0
dc.w $188,0,$18a,0,$18c,0,$18e,0
....

Copperlist'te, renk kayıtlarının bulunduğu yerde. Yapmamız gereken şey,
 bu sıfırların yerine doğru RGB değerlerini (tam olarak $0RGB kelimesi)
koymak ve bunları, her kare için bir adım olmak üzere, çeşitli adımlarla
figürümüzün renklerine ulaşana kadar “artırmak”tır:

CopColors:
dc.w $180,$000,$182,$fff,$184,$200,$186,$310
dc.w $188,$410,$18a,$620,$18c,$841,$18e,$a73
...

Öncelikle, şeklin renklerinin bir tablosunu
“danışmak” için hazırlamalıyız, aksi takdirde “ne zaman vardığımızı” bilemeyiz:

TabColoriPic:
dc.w $fff,$200,$310,$410,$620,$841,$a73,...
...

(NOT: 0 rengi, $dff180, bu tabloya eklenmemiştir, çünkü
siyah, $000, her zaman siyah kalır ve bunu rutine dahil etmiyoruz,
bunun yerine 1 renginden, $dff182'den başlıyoruz, bu durumda $FFF'dir).

Bu tabloyu oluşturmak için, editörle kopyalanan
copperlist 'ten $180,$182,$184 'leri “elle” silmeniz yeterlidir, renkler elbette kalacaktır.

Artık “hedef” renklerin bulunduğu tabloya sahibiz, peki tabloda renkleri doğru renklere ‘artıran’ bir rutin nasıl oluşturulur?
Kesinlikle 3 RGB bileşeninin her biri için ayrı ayrı çalışmalıyız ve bunları ayırmak için AND kullanabiliriz, bu da gördüğümüz gibi bitlerin sadece bir kısmını “seçer” ve diğerlerini sıfırlar.
Kesinlikle RGB'nin 3 bileşeninin her biri için ayrı ayrı çalışmalıyız
ve bunları ayırmak için AND kullanabiliriz, ki bu, gördüğümüz gibi, sadece
bitlerin bir kısmını seçer ve diğerlerini sıfırlar. Renklerin bulunduğu tablonun adresi
a0'da olduğuna göre, örneğin, sadece mavi bileşeni nasıl ayıracağımıza bakalım:

MOVE.W	(A0),D4        ; Renk tablosundaki rengi d4'e koy
AND.W    #$00f,D4    ; Sadece mavi bileşeni seç ($RGB->$00B)

Şimdi d4'te sadece MAVİ değeri var... eğer renk $0123 olsaydı, d4'te
AND.w #%000000001111,d4 (sadece 4 bit veya nibble seçilir) işleminden sonra değer
$0003 olur, yani işimizi başardık. Yeşil bileşeni
nasıl seçeceğimize

AND.W    #$0f0,D4    ; Sadece yeşil bileşeni seç ($RGB->$0G0)

Ve kırmızı bileşeni:

AND.W    #$f00,D4    ; Sadece kırmızı bileşeni seç ($RGB->$R00)

Şimdiye kadar her şey açık olmalı.
Şimdi, “FAKE” rutinini, yani “SAHTE” rutinini yapabiliriz. Bu rutin şu şekilde çalışır
: her seferinde her bir bileşene #1 eklenir ve
tablodaki renkle karşılaştırılır, eğer o bileşene eklemeyi bırakmamız gerekiyorsa
. Örneğin, ulaşmamız gereken renk $0235 ise,
her kare için şu adımları izleyeceğiz:

1)    $111    ; +$111, hepsi 3
2)    $222    ; +$111, hepsi 3
3)    $233    ; +$011, KIRMIZI bileşeni uygun, sadece Gr. ve Mavi'ye ekle
4)	$234    ; +$001, KIRMIZI ve YEŞİL bileşenler tamam, +1 sadece Mavi
5)    $235    ; +$001, yukarıdaki gibi, +1 sadece mavi

Her seferinde, tablodaki KIRMIZI bileşeni bir CMP ile
“arttırdığımız” bileşenle karşılaştırmalıyız, eğer ulaşmadıysak
1 eklemeliyiz, ulaştıysak eklememeliyiz, sonra aynı şeyi
YEŞİL ve MAVİ ile yapmalıyız, son olarak 3 bileşeni bir veya
birden fazla OR komutuyla birleştirerek, copperlist'e koyulacak sonuç renk kelimesini elde etmeliyiz
copperlist'e yerleştirilecek sonuç renk kelimesini elde ederiz. Ve bunu 16, 32 renk veya kaç renk varsa her biri için yaparız.
Miktar işlemci için sorun değildir, DBRA döngüleri ile
her şey yapılabilir. Tek ayrıntı, tarif ettiğim sistemin
çok kesin olmaması ve özellikle AGA'da renklerin kendi başlarına hareket ettiği
görülmesidir. Dolayısıyla, rutinin yapısı aynı kalır, ancak
hesaplama yöntemini değiştirmeliyiz. Öncelikle bir şeye dikkat etmeliyiz: kaç kare, yani
tam bir solma gerçekleştirmek için rutini kaç kez çağırmalıyız?
Örneğin, $0F3 rengi, güzel bir yeşil rengi ele alalım, $000'dan başlayıp
her seferinde 1 ekleyerek, önceki rutinle 15 add.w #$010
gerekir, çünkü $f (15) değerine ulaşması gerekir.
Öyleyse, renkleri solmanın 16 olası AŞAMASINDAN birinde hesaplayabilen bir “parametrik” rutin yapmayı düşünelim. Burada aşama 0
tam SİYAH ve aşama 16 tam renktir.
Yapılacak aşamanın ‘hesabını’ bir “FaseDelFade” etiketinde tuttuğumuzu varsayalım. Her seferinde şunları yapmamız gerekir: addq.w    #1,FaseDelFade    ;
FaseDelFade“ etiketinde ”hesap tutalım". Her seferinde şunları yapmamız gerekecek:

addq.w    #1,FaseDelFade    ; bir dahaki sefere yapılacak aşamayı sistem

Öyleyse, ilk karede “BSR.s Fade” komutunu ‘FaseDelFade’ değerini 1 olarak ayarlayarak vereceğiz
ve renkler çok koyu olacak, sonraki karede
rutini tekrar çağıracağız, ancak “FaseDelFade” değerini 2 olarak ayarlayarak renkler açılacak (renklerin 2/16'sı
doldurulacak), son olarak “FaseDelFade” 3 olarak ayarlandığında renkler
tablodakilerle aynı olacak. Önce kesirden bahsederken, 2 onaltılık
renk, kullanılacak tekniği önceden anlatıyordum! Aslında bir
Fake rutini, her seferinde sadece 1 ekleyen rutin solma korkularından biri
kesir olarak kesin değildir, bizim yapacağımız ise kabul edilebilir.
Önemli noktaya gelelim: Fake rutiniyle,
$084'e ulaşmak için şu adımları izlememiz gerekir:

$011
$022
$033
$044
$054
$064
$074
$084

Peki, yarıya geldiğimizde GRİ bir renk elde ediyoruz! $044!! Yeşil yerine.
Aslında, yarıya geldiğimizde, $042'de, yani koyu yeşil renkte olmamız gerekirdi.
Bu da tesadüfen $084'ün tam yarısıdır.
Şimdi, çözüm ortaya çıkıyor: “FaseDelFade” değerine sahip olduğumuzda,
buna MULTIPLIER adını verebiliriz, 0 olduğunda,
 
0/16 (on altıda sıfır) renkleri, yani tümünü SIFIR olarak hesaplamalıyız.
Öte yandan, 1 olduğunda, renklerin 1/16'sını hesaplamalıyız.
Böylece 16/16'ya kadar renk aynı kalır.
Bu formülü komutlarda nasıl uygulayabiliriz? Çok kolay!
İzole bir RGB bileşeni, örneğin MAVİ: (d0'da MULTIPLIER var)

MOVE.W    (A0),D4        ; Renk tablosundaki rengi d4'e koyun
AND.W    #$00f,D4    ; Sadece mavi bileşeni seçin ($RGB->$00B)
MULU.W    D0,D4        ; Solma aşaması (0-16) ile çarpın
ASR.W    #4,D4        ; 4 BİT sağa kaydır, yani 16'ya böl
AND.W    #$00f,D4    ; Sadece MAVİ bileşeni seç
MOVE.W    D4,D5        ; MAVİ bileşeni d5'e kaydet

Pratikte, bileşeni MULTIPLIER ile çarparız, ardından
16'ya böleriz, bu durumda 16'ya bölmek ASR.W #4,Dx'e eşittir,
8x8 karakterlerin yazdırma rutininde gördüğümüz gibi MULU.W #8,Dx, bir LSL.w #3,Dx ile
değiştirilebilir. Bunu bir DIVU.w #16 olarak düşünün,D4 olarak düşünün ve her şey
yerine oturur. Bu işlemi 3 RGB bileşeni için 3 kez tekrarlayarak
SİYAH'tan renklere FADE rutinini elde ederiz ve çarpanı 16 ile başlatırsak,
her seferinde #1'i sıfıra kadar çıkararak, renkten
siyah'a ters fade elde ederiz. İkincisi FADE OUT olarak adlandırılırken, ilki FADE IN'dir.

Bu rutinin nasıl çalıştığını, iki
Liste Lezione8c.s ve Lezione8d.s'de görebiliriz. Bu iki liste arasındaki tek fark,
 3 RGB bileşeninin bölme işlemlerinin gerçekleştirilme sırasıdır,
 ancak çarpan ile çarpma ve
16 ile bölme prensibi aynıdır. En açık olanı belki de Lezione8d'dir.s.

Çizim, İtalyan FLENDER tarafından yapılan RAM JAM grubunun logosu.
Bu çizimi kullandım çünkü bu dersi yazarken bu gruba katıldım.
Bu nedenle, bu noktadan itibaren
kurs RAM JAM'in bir yapımıdır!!!

Konuyla ilgili bir varyasyonla devam edelim, Ders8e.s dosyasını yükleyin. Bu
aynı rutin, ancak küçük bir değişiklikle,
ek bir dominant bileşen eklenerek çizime bu tonu kazandırılmıştır
tonunu kazandırıyor. Bu, resme karnaval havası vermek için yararlı olabilir.

Son olarak, herhangi bir renkten
başka bir renge geçebilen bir rutin sunacağım! Pratikte iki tablo gerekir, biri başlangıç renkleri için,
örneğin siyahla başlıyorsanız, bir tablo sıfırlarla dolu ve diğeri
son renklerle dolu. Sonuç olarak, ilk solmayı, yani siyahtan
normal renklere geçmek için, ilk tablo olarak tamamen sıfırlanmış bir tablo ve
ikinci tablo olarak renkli tabloyu koymanız gerekir. Renklerden siyaha geçmek için (FADE OUT),
ilk tablo olarak normal renkli tabloyu ve ikinci tablo olarak
tamamen sıfırlanmış bir tablo koymanız gerekir.
Bu noktada yenilikler geliyor: örneğin,
BEYAZ'dan normal renklere geçiş yapabiliriz, ilk tablo olarak tüm $FFF'leri ve
ikinci tablo olarak normal renkleri koyarak.
Abartalım: bir renkten diğerine geçebiliriz!
İlk tabloya başlangıçta olmasını istediğimiz renkleri, ikinci tabloya ise
sonunda olmasını istediğimiz renkleri koymak yeterlidir. Bu şekilde, bir
yeşil tonundan mavimsi bir tona vb. geçebiliriz.
Lezione8f.s dosyasını yükleyin ve
yaptığım örnekleri gösteren rutini deneyin. Rutinin işleyişi oldukça
karmaşıktır ve onu tekrar gözden geçirmek istemiyorum. Anlamak isterseniz
eski yorumlarımı okuyun. En azından kendi amaçlarınız için kullanmayı öğrenin!
!

,øØØØØØm ¸____
ØV´ ¬ØQ Øþ¤4Ø,
_øæØ#__ .ØF ________ Ø Ø#æØØæ_
.Ø^¨~°¢ØÐ `Ø_ __gøØØØØØØØØØØ#øæ___ Ø& VÞ°~¯°ØL
`Øø_ __ ¬ØØØØØØ»^^°°°°°°¤*0ØØØØØø__ _ÆØ~ _____JØ
¬¢Øæ_øØØø__ØØØ³" ¬~^«ØØØØØP _øØØØØØØ°
°°° °#ØØ/ ¸gæææ___ ¬°#ØØæ_øØ°
ØØP #ØØØØØØØæ_ ___ °4ØØØ¸
_____________ ØØÌ ° _F°ØØØØ_ _Æ**Ø®_ "0Ø#_ _____________
\___ ØØ# Ø °¢ØØL ÆØ _ `Øì ¶ØØ_ ___/
T ¶ØØ 0Ø (ø ¬ØØb ØÍ (Ø) Øf ¶ØØ, T
| #Ø#¸ (Ø&____øØ¤° °#¸ _Ø´ ØØQ |
| 0ØØ__ °^¤¤¤°" __ ¬^***³´ ØØV |
| °ØØØæ______ ,ØØ _æØØ' |
| °«ØØØØØØØ ØØØØ ________æØØØ@~ |
| _ØØ~¨ØØP `°°¤* øØØØØØØØØØÞ°¯ |
| _æØØN___ØØ° _ØØ _ 0_¯¯¯¬4Ø_ |
| ,ØØ°¯¯“0ØØ° ¸øØØ” _Ø . `Ø_ °Øæ_ _ |
| lØ ^ __ØØØ¹ ,Ø" Æ ØQ ¬Ø, °ØØØØØØ_ |
| ¬Øæ__g# øØ¤~Ø´ Ø° ,Ø ØØ #ØØ__ °¯¯ ¬Ø, xCz |
_ __¦_______¬°^¤ØØ ¶Ø ¸Ø__ÆØ__ØP ØØ ¶ØØ¢Ø_ ____Øf ______¦__ _
: Øò___ØØ #ØØØØØØØØØØøØØæææØØ' ¬4# ØØ¤¤° :.
 “¢ØØØ@ ~~¯ ¯¬”°^^¤¤«**ØØ³ lØ ÎØ .
¯ ØL__ÆØ
°**¤°


Şimdi size üç liste sunmak istiyorum, bunlar da tıpkı sizin gibi benim kursumla sıfırdan başlayan “öğrencilerim” tarafından yapılmış.
Cesaret verici, değil mi?

DERS 8g.s    - 10 seviyeli paralaks (Federico Stango)

DERS 8h.s    - gadget'larla kontrol paneli (Michele Giannelli)

DERS 8h2.s	
- scrolltext 8X8 (Lorenzo Di Gaetano)

Bu üç liste, kursun 1. diskindeki bilgilerden yararlanmaktadır.
Ben sadece başlangıcı değiştirdim, eski başlangıç yönteminin yerine startup1.s'yi ekledim.
Eski başlangıç yöntemini
 Uyanın!!!
Ve eğer güzel bir şey yaptıysanız, bana gönderin, en azından
sonraki derslerde gösteririm ve Fiorello gibi ünlü olursunuz.

Şimdi sık sorulan bir soruyla devam edelim: “Kursun 1. diskindeki küçük AMIGAET.EXE demosunda bulunan ekolayzır
nasıl çalışıyor?”.
Peki, o liste parçasını “kestim”,
her şeyin nasıl çalıştığını lezione8i.s'de görebilirsiniz.

Dikkat: Disk 2'deki “music.s” rutini, Disk 1'deki ile aynı değildir.
 2 değişiklik, bazen programın çıkışında bir guru hatasına neden olan bir BUG'ın kaldırılması
ve mt_data'nın müzik dosyasına değil, müzik dosyasına bir işaretçi olmasıdır
. Bu, müziği daha kolay değiştirebilmenizi sağlar,
ders8i2.s'de görüldüğü gibi müzik diskleri oluşturmak için.


Ekolayzırları yapmaya kadar geldik, ancak henüz
bir noktayı nasıl yazdırılacağını, yani “bir nokta çizmeyi”. Bunu hemen Ders8l.s ile telafi edelim

(daha sonra 3d_stars.s'den farklı düzlemlere çizilmiş olarak ekleyin)

Tamam, artık noktaları yazdırmayı bildiğimize göre, yan yana birçok nokta yazdırarak
Ders8m.s ve Ders8m2.s'de “çizgiler” oluşturalım

Peki, çizgiler yapabiliyorsak, parabolik eğriler de yapabiliriz,
X*X'i çarpmamız yeterlidir, Ders8m3.s, Ders8m4.s, Ders8m5.s

Şimdi noktaları yazdırma rutinini nasıl “optimize edebiliriz” bakalım. Gördüğünüz gibi
, bir çarpma işlemi var ve bu çok kötü çünkü çarpma
işlemleri yavaştır. Bunu “kaldırmak” için ne yapmalıyız? 40 ile çarpmalıyız, bu yüzden
tüm olası çarpma işlemlerini “gerçekleştirmemiz” yeterlidir, yani ilk 256
40'ın katlarını çarpmamız ve sonuçları bir tabloya yazmamız yeterlidir. Şimdi bu
tabloda, çeşitli durumlara göre söz konusu çarpma işleminin tüm “sonuçları” bulunmaktadır.
Her seferinde doğru sonucun tablodan “alınmasını” sağlamak yeterlidir, tıpkı sprite koordinat tablolardan doğru X veya Y'yi aldığımız gibi.
Bunu Lezione8n.s'de pratikte görelim.

Ders8n2.s'de tüm ekranı yazıp silerek, yeni rutinin eskisinden daha hızlı olup olmadığını kontrol edelim.
Ekranı yazıp silerek, eski rutinin eskisinden daha hızlı olup olmadığını kontrol edelim.

Bir noktayı sıfırlamayı öğrendiğimize göre (BSET yerine BCLR koymak yeterlidir),
 sprite'larda yaptığımız gibi bir noktayı “canlandırmaya” çalışalım.
Her karede farklı konumlarda yazıp silerek, Ders 8n3.s'de

Birden fazla biplane, birden fazla nokta
vb. içeren değiştirilmiş versiyonlar yapmayı deneyin. 2 bitplane, yani 4 renge yazdırmak için
şöyle yapabilirsiniz: color0 arka plandır, çizmek için 3 farklı renk vardır.
“Bitplane1” ve “Bitplane2” adında 2 bitplane olduğunu varsayarsak,
3 rutin oluşturabilirsiniz, biri bitplane1'e, biri
bitplane2'ye ve biri her iki bitplane'e çizim yapan ve
bu 3 rutinden birine atlayarak 3 renkten birinde yazdırmak için.

-- İnanılmaz! Lorenzo di Gaetano hemen bir liste yazdı!
bakın: Lezione8n4.s

Sanırım çok karmaşık fonksiyonları inceleyen,
Quark'ın logosu gibi dalgalar çizen bir program yazdınız. O zaman, nokta ve virgül ile bit düzlemlerini kontrol etmek için kullanılan
 
. Basit wait ve color0 komutlarının,
bit düzlemi yardımı olmadan, Lezione8o.s
Hiçbir hile yok, sadece copperlist “inşa ediliyor” ve
değiştiriliyor, işte copperlist'in önemli parçasını “oluşturan” rutin:

; INITCOPPER, birçok WAIT ve COLOR0'ın ardından copperlist'in bir parçasını oluşturur

INITCOPPER:
lea    barcopper,a0    ; Copperlist'in oluşturulacağı adres
move.l    #$3001fffe,d1    ; İlk wait: satır $30 - WAIT in d1
move.l    #$01800000,d2    ; COLOR0 d2'de
move.w #coplines-1,d0    ; bakır hat sayısı
initloop:
move.l    d1,(a0)+    ; WAIT'i koy
move.l    d2,(a0)+    ; COLOR0'ı koy
add.l	#$02000000,d1    ; sonraki bekleme, 2 satır aşağıda bekle
dbra    d0,initloop
rts

Görüldüğü gibi, bu rutinin sonucu şudur:

barcopper:
dc.l    $3001fffe    ; $30 satırında bekle
dc.l    $01800000	; renk 0
dc.l    $3201fffe    ; bekleme satırı $32
dc.l    $01800000    ; renk 0
dc.l    $3401fffe    ; bekleme satırı $34
dc.l    $01800000    ; renk 0
....

Bu şekilde ne kadar yer ve zaman kazandığımızı bir düşünün.

________
___---‘--------`--..____
,-------------------.============================
(__________________<|_) `--.._______..--’
| | ___,--‘ - _ /
| | | |
,--’ `--' |
~~~~~~~`-._ | _
`-.______,-‘ (ö)
’(_)`
¯ ¯

Dersi bitirmek için, çok önemli olmasına rağmen şimdiye kadar ele alınmayan
işlemcinin bir özelliğini ele almamız gerektiğini düşünüyorum.
Aslında 68000 hakkında yeterince bilgiye sahip olduğunuzu DÜŞÜNÜYORDUNUZ, ancak gerçekte
şimdiye kadar sadece “yüzeysel” bir şekilde incelenmiştir, rutin işlemleri yapmak için
gerekli olan minimum bilgiyi öğrendik. Aslında, Durum Kodları ve
bunlarla birlikte SR (Durum Kaydı) parçası olan CCR'den bahsedilmedi.
Kaydı oluşturan 16 bit şöyledir:

SR:
___
15    T - TRACE        \
14    - 68000 tarafından kullanılmıyor     |
13    S - SUPERVISOR         |
12    - 68000 tarafından kullanılmıyor     |- SYSTEM BYTE
11    -             |
10    I2 \             |
9    I1 > INTERRUPT MASK     |
8    I0 /		 ___/
7    -            \
6    -             |
5    -             |
4    X - EXTENSION         |- USER BYTE (Condition Code Register)
3    N - NEGATIVE         | (aritmetik bayrakları içerir)
2    Z - ZERO         |
1    V - OVERFLOW (aşma)     |
0    C - CARRY (TAŞIMA) ___/


Peki, bu gizemli kayıt, durum bayraklarıyla ilgili bitleri içerir,
 daha doğrusu düşük baytı, CCR (Durum Kodu Kaydı) olarak adlandırılır
Kayıt) bu bayrakları içerir. SR'nin yüksek baytını daha sonra
INTERRUPT ve SUPERVISOR MODU hakkında konuşurken ele alacağız.
Şimdilik, işlemcinin iki modda çalışabileceğini söyleyebilirim:
USER (KULLANICI) ve SUPERVISOR (SÜPERVİZÖR). Normalde yazdığımız programlar
USER modunda çalışır. Kesintilere ihtiyacımız olduğunda, Supervisor modundan User moduna ve tersi nasıl
geçileceğini göreceğiz, ancak bazı
komutların sadece SUPERVISORE modunda çalışabileceğini unutmayın, USER modunda çalıştırmaya çalışırsanız
her şey derin bir komaya girer. Bu komutlar
PRIVILEGIATE olarak adlandırılır, dikkat edin!
Şimdilik SR'nin alt baytını, CCR'yi ANLAMAK yeterlidir.
Her komut, çalışırken bayrakları etkileyebilir, örneğin
bir çıkarma işlemi negatif bir sonuç verirse N bayrağı, sıfırdan bir sonuç verirse
Z bayrağı, bir toplama işlemi daha büyük bir sayı ile sonuçlanırsa
örneğin D0.l'de bulunan sayıdan daha büyükse, V bitini, yani taşma bayrağını ayarlar ve
sonucun hedefe sığmadığını gösterir. Bu
Carry için de geçerlidir, yani taşıma için de geçerlidir ve taşıma durumunda ayarlanır.
Bayt CCR'yi test ederek bayrakları kontrol etmek mümkündür, ancak
68000 dünyanın en iyi işlemcisi olduğu için, bayrakların durumunu öğrenmek için yeterli komutlar mevcuttur
: bunlar Bcc'dir, burada cc
Condition Codes (Koşul Kodları) anlamına gelir ve CS, EQ, GE, GT, HI, LE, LS,LT, MI, PL...
CMP
komutlarının BEQ ve BNE ile birlikte nasıl çalıştığını anlatırken, BEQ/BNE'nin CMP'nin nasıl çalıştığını bildiğini
çünkü CMP'nin sonucu bir “kağıda” yazıldığını açıklamıştık.
Peki, CMP'nin BEQ/BNE için sonucu yazdığı “kağıt”
CCR, SR'nin düşük baytıdır! Aslında bu kağıt parçası
4 bitten ve özel amaçlar için kullanılan eXtend adı verilen beşinci bir bitten oluşur.
Bu 4 bit sayesinde, sadece
BEQ ve BNE değil, bir sayının diğerinden büyük mü küçük mü olduğunu,
, iki sayının eşit olup olmadığını, bir işlemde taşıma olup olmadığını,
 sonucun negatif olup olmadığını vb. öğrenmek mümkündür. İşte tüm Bcc'ler:


bhi.s    label    ; > işaretsiz sayılar için
bgt.w    label    ; > işaretli sayılar için
bcc.s    label	; > BHS olarak da bilinir, Carry = 0 (işaretsiz)
bge.s    label    ; >= işaretli sayılar için
beq.s    label    ; = tüm sayılar için
bne.w    label    ; >< tüm sayılar için
bls.w    label    ; <= işaretsiz sayılar için
ble.w    label    ; <= işaretli sayılar için
bcs.w    label	; < işaretsiz sayılar için; BLO olarak da bilinir,
; Carry = 1
blt.w    label    ; < işaretli sayılar için
bpl.w    label    ; Negatif = 0 (PLus) ise
bmi.s    label    ; Negatif = 1 (Minus) ise işaretli sayılar
bvc.w    label	; V=0, no OVERFLOW (sonuç sığabilir)
bvs.s    label    ; V=1 OVERFLOW (sonuç çok büyük
; hedefte sığmaz)


Şimdi CMP.x OP1,OP2'den sonra Bcc'leri nasıl kullanacağımızı görelim.

beq.s    label    ; OP2 = OP1 - tüm sayılar için
bne.w    label    ; OP2 >< OP1 - tüm sayılar için
bhi.s    label    ; OP2 > OP1 - işaretsiz
bgt.w    label    ; OP2 > OP1 - İŞARETLİ
bcc.s    label    ; OP2 >= OP1 - işaretsiz, *“BHS”* olarak da bilinir
bge.s    label    ; OP2 >= OP1 - İŞARETLİ
bls.w    label    ; OP2 <= OP1 - işaretsiz
ble.w    etiket    ; OP2 <= OP1 - İŞARETLİ
bcs.w    etiket    ; OP2 < OP1 - işaretsiz, *“BLO”* olarak da adlandırılır
blt.w    etiket    ; OP2 < OP1 - İŞARETLİ

Ve şimdi bunları bir TST.x OP1

beq.s    label    ; OP1 = 0 - tüm sayılar için
bne.w    label    ; OP1 >< 0 - tüm sayılar için
bgt.w    label    ; OP1 > 0 - İŞARETLİ
bpl.s    label    ; OP1 >= 0 - İŞARETLİ (veya BGE)
ble.w    label    ; OP1 <= 0 - İŞARETLİ
bmi.w    label    ; OP1 < 0 - İŞARETLİ (veya BLT)

Görüldüğü gibi, bir CMP'den sonra pek çok şey öğrenilebilir!
> (büyük), >= (büyük veya eşit), =, >< (farklı)
<= (küçük veya eşit), < (küçük) işaretleri görülebilir ve ayrıca normal sayılar için bu
karşılaştırmaların bir Bcc'si ve Signed (işaretli) sayılar için bir Bcc'si vardır.
Negatif sayılara gelince, şimdiye kadar sadece
örneğin -1'in $FFFFFFFF, -5'in $FFFFFFFB olduğunu ve
bitinin yüksek olduğunu yani longword'da 31, .w'de 15 ve .b'de 7,
işaret bitidir, yani 1 ise sayı negatiftir ve
-1 olan $FFFF'den -2 olan $FFFE'ye, -3 olan $FFFD'ye
vb. (w alanında) $8001'e, yani -32767'ye ulaşana kadar devam eder, ardından
$8000, yani -32768 gelir, bu da işaretli bir kelimede olabilecek en negatif sayıdır
ve %1000000000000000'a karşılık gelir, yani işaretin yüksek biti
ve diğerleri sıfırlanmıştır: -1'den, yani %111111111111111'den başlamıştık.
Bu sistem, ikili sayılarda negatif sayılar elde etmek için kullanılır ve
iki tamamlayıcı olarak adlandırılır. En anlamlı bitin, yani en soldaki bitin
işareti temsil ettiğini zaten biliyoruz: = 0 ise pozitif, = 1 ise negatiftir.
Bu sistem hem .byte sayılar için (bit 7'dir) hem de
.word (bit 15) ve .longword (bit 31) sayılar için de geçerlidir.
Şimdi ikili tamamlayıcıların nasıl çalıştığını ayrıntılı olarak görelim: en anlamlı biti değiştirmekle pozitiften negatife geçmenin yeterli olmadığını gördük
.
.word alanında +26 ve -26 örneklerini ele alalım:

;5432109876543210
+26    %0000000000011010    ($001A)
-26    %1111111111100110    ($FFE6)

+26'daki bit 15 sıfırlanmıştır ve -26'da ayarlanmıştır, ancak -26'dan -26'ya geçmek için yapılması gereken tek değişiklik bu değildir!
%0000000000011010'un ikili tamamlayıcısını yapmak gerekir, bu da
tüm bitleri TERS ÇEVİRMEK ve sonuca 1 EKLEMEKTİR.
Bunun doğru olup olmadığını deneyelim: tüm bitleri ters çevirerek şunu elde ederiz: %1111111111100101 1'i ekleyelim: %1111111111100101
Doğru olup olmadığını deneyelim: tüm bitleri tersine çevirerek şunu elde ederiz:

%1111111111100101

1 ekleyelim:

%1111111111100101 +
1 =
-----------------
%1111111111100110

1'lerin sırası kafanızı karıştırıyorsa, alt 6 biti ayırın: %100101, 25'tir,
1 ekleyin = %100110, yani 26, 7'den 15'e kadar tüm bitler 1'dir, yani -26.
Bir baytta -26 istiyorsak, %11100110, yani $E6 yeterlidir.
Bir long'da -26 istiyorsak: %1111111111111111111111111100110 = $FFFFFFE6
Byte, word veya long'ları istediğimiz gibi, işaretli
veya işaretsiz olarak kullanabiliriz, bu kullandığımız komutlara ve programımıza bağlıdır.
Açıklığa kavuşturmak için, kullanılan sisteme göre bir .b, bir .w veya bir .l'nin ne kadar alabileceğini aşağıda görebilirsiniz,
 “normal” veya “2'ye tamamlayıcı” ise:

İşaretli BYTE     .8 bit     - -128 ($80) ile +127 ($7f) arası
İşaretsiz BYTE .8 bit     - 0 ($00) ile 255 ($ff) arası
İşaretli WORD     .16 bit - -32768 ($8000) ile +32767 ($7fff) arası
İşaretsiz WORD .16 bit - 0 ($0000) ile 65535 ($ffff) arası
LONG işaretli     .32 bit - -2147483648 ($80000000) ile +2147483648 ($7fffffff) arası
LONG işaretsiz .32 bit - 0 ($00000000) ile 4294967299 ($ffffffff) arası

Görüldüğü gibi, SIGNED BYTE alanında 128 ile 255 arasındaki sayılar
-128 ile -1 arasındaki değerler olarak kabul edilirken, SIGNED WORD alanında
32768 ile 65535 arasındaki değerler -32768 ile -1 arasındaki değerler olarak kabul edilir.
Aynı değer .longword notasyonu için de geçerlidir.
Özetle, pozitif bir sayıdan negatif bir sayı elde etmek için 2 sistem vardır:

Sistem 1:

N=%00110 (6 ondalık) sayısı verildiğinde, -N'yi bulmak için N'nin bit bit negasyonu yapılır
ve N=%11001 (-7 ondalık) elde edilir, ardından sonuca 1 eklenir:

N=%11001+%00001=%11010 (-6 ondalık)

Sistem 2:

N=%00110 (6 ondalık) sayısını bulmak için -N'yi bulmak için N'nin bit bit negasyonunu
en anlamlı 1'e kadar gerçekleştirin N=%11010 (-6 ondalık).

Rutinimizde sıfırın altına hiç inilmiyorsa, 255 değer için bir bayt kullanmak iyidir.
Bunun yerine -50 ile +50 arasında gitmek istiyorsak,
BHI ve BLS gibi işaretsiz sayıları karşılaştıran komutlar yerine,
işareli sayıları karşılaştıran BGT, BLE, BLT gibi komutlar kullanmak gerekir.
Toplama ve çıkarma işlemleri hem işaretli hem de işaretsiz sayılarla çalışır,
ancak çarpma ve bölme işlemleri çalışmaz, çünkü işaretli ve işaretsiz sayılar için iki tür
komut vardır: işaretsiz sayılar için MULU ve DIVU,
 işaretli sayılar için MULS ve DIVS.

Negatif sayıları açıklığa kavuşturduktan sonra, CCR'nin bitlerini, yani bayrakları tek tek inceleyelim:


*bit 0 - Carry (C): bir toplama işleminin sonucu bir
taşıma (‘carry’) oluşturduğunda veya bir çıkarılan sayı çıkarılan sayıdan büyük olduğunda, yani
bir çıkarma işlemi “borç” gerektirdiğinde 1 olarak ayarlanır. Carry biti
ayrıca bir operandın bir
shift veya rotasyona tabi tutulduğunda en anlamlı veya en anlamsız biti içerir. Son işlem
gerçekleştirildiğinde, taşıma veya “borç” olmadığında sıfıra ayarlanır. Örneğin, CARRY bayrağını
ayarlamak için şu yöntem kullanılabilir:

move.l    #$FFFFFFFF,d0
ADDQ.L    #1,d0

Sonuç d0=00000000'dır, CARRY ve ZERO bayrakları ayarlanmıştır, çünkü
.l'de tutulabilecek maksimum değeri aştık ve sonuç da SIFIR!

*bit 1 - Taşma (V): işaretli sayılar arasındaki son işlemin sonucu, hedef işlenen
değeri aşarsa, örneğin bu sonuç
-128..+127 sınırlarını aşarsa, ayarlanır. Örneğin, 80+80 toplamı bir
oVerflow oluşturur, çünkü +127'yi aşmıştır. .w alanında sınırlar -32768..+32767,
.l alanında ise -/+ 2 milyar'dır. Bayt alanında 80+80 toplama işleminin
Carry ve eXtend bayraklarını ayarlamadığı, ancak oVerflow bayrağını ayarladığı unutulmamalıdır, çünkü
160, normal sayılar için bir baytta saklanabilecek en büyük değer olan 255'i aşmamaktadır.

*bit 2 - Sıfır (Z): işlem sıfır sonucunu verdiğinde (bir sayacın azalmasını kontrol etmek için de kullanışlıdır)
 ve iki operandın eşit olup olmadığını karşılaştırırken
ayarlanır.

*bit 3 - Negatif (N): bir işlemde, iki tamamlayıcı formatındaki sayının üst biti
ayarlanmışsa 1 olarak ayarlanır. Pratik olarak, sonuç
negatif bir sayı ise bu bit ayarlanır, aksi takdirde sıfırlanır.
İki tamamlayıcı, işlenenin bir tamamlayıcısını yaparak
(yani tüm bitleri tersine çevirerek) ve ardından 1 ekleyerek elde edilir; örneğin, +26
ikili sistemde %000110010'dur; bir tamamlayıcısı %11100101 (
0 bitlerini 1 bitlerine ve tersi); 1 eklenerek %11100110 elde edilir.
7. bit, işaret biti olarak adlandırılır ve Durum Kaydının 3. bitine kopyalanır;
Örneğin -26 durumunda, N ayarlanır ve negatif bir sayıyı gösterir.

*4. bit - Extend (X): Carry bitinin bir tekrarıdır ve
BCD (Binary Coded Decimal: ondalık sayı
20, örneğin, 00010100 olarak değil,
iki on, sıfır birim 0010 0000) biçiminde ve ADDX
ve SUBX, ADD ve SUB toplama ve çıkarma komutlarının özel versiyonları.
SUB.
_____
/\___/\
/_/__/ \
\ \ /
\____\/
Y
:
.

Bu yeni bilgiler ışığında, işlemcinin tüm komutları ve bunların CCR FLAG'leri üzerindeki etkileri ile ilgili referans metnine bakın:
68000-2.TXT, ilk diskteki eski 68000.TXT'nin bir “gelişimi”, artık
sizin için çocuk oyuncağı (değil mi?).

DERS9.TXT'ye başlamadan önce, tüm
68000-2.TXT'yi okumanız iyi olur, en azından CPU komutları konusunda gerçekten bilgili olursunuz!
Bunu bir LEZIONE8b,TXT olarak düşünün, hepsini “ÇALIŞIN”, özünü kavrayın.
Hepsini okumak sizi KORKUTABİLİR (eğer yarı yarıya bilgiliyseniz), ama
bu güzel 100K'lık metinde yazılanlara aşina olduktan sonra
nihayet 68000'i programlayabildiğinizi herkese söyleyebileceksiniz.
Ayrıca, ileride bilmediğiniz talimatlar bulursanız, şikayet edemezsiniz
çünkü bunlar 68000-2.TXT dosyasında açıklanmıştır!
İlk olarak, CMP ve Bcc komutlarına bakın, burada çeşitli
Bcc türleri daha ayrıntılı olarak açıklanmıştır, sonra baştan başlayın ve
sonuna kadar okuyun, gerekirse birkaç kez tekrar okuyun, aralarda mola verin
ve bir sandviç yiyin. Bu 68000-2.TXT, aşmanız gereken ikinci engeldir
; ilki, ilk
temelleri, adreslemeyi öğrendiğiniz LEZIONE2.TXT idi. Birçoğu o tepede durdu. Şimdi
önünüzde bir dağ var ve çoğu kişi onu aşacak cesarete sahip olmayacak.
Ama onu aşan, zirveye ulaşmayı deneyebilir!

En az bir kez okudunuz mu? Koşul Kodları net mi?
Anladığınızı kontrol etmek için bazı örnekler veriyorum. Bu örnekler,
Luca Forlizzi (the Dark Coder) ve Antonello Pardi (Deathbringer) tarafından yazıldı
ve AGA ve 3d ile ilgili dersleri daha hızlı yazmamı sağladı.

Ders8p1a.s    -> MOVE komutundaki CC
Ders8p1b.s    -> MULU/MULS'da CC
Ders8p1c.s    -> DIVU/DIVS'de CC
Ders8p2a.s    -> CC ve Ax adres kayıtları
Ders8p2b.s    -> Ax adres kayıtlarında işaret uzantısı
Ders8p3.s    -> TST'de CC
Ders8p4.s	-> CC AND, NOT, OR, EOR'da
Ders 8p5.s    -> CC NEG'de
Ders 8p6.s    -> CC ADD'de
Ders 8p7.s    -> CC CMP'de
Ders 8p8.s    -> CC ADDX'de
Ders 8p9.s    -> CC lsr, asr, lsl, asl'de

Son olarak, bir “soru” da içeren Lezione8p9b.s dosyasını yükleyin.

____________________
\ /
\________________/
_( o.. ..o )_
/ )(\__ __/) ( \
( / \/ / \ \/ \ )
/\( ( _) )/\
\_/\ __ \___/ __/\_/
\\\_________ ( /
\\_|_|_|_|7 /
\\|_|_|_|/ /
\________/


Bir sonraki derse geçmeden önce, size söylemek istediğim birkaç şey var.
 Macera oyunu programlayan arkadaşım Michele, geçen sefer beni ziyaret ettiğinde
bana birkaç şey sordu ve bunların
çoğunuzun da ilgisini çekebileceğini düşündüm. O,
altta Ders 8h.s'ye benzer bir kontrol paneli yaptı ve üstte çeşitli şekilleri görüntülüyor.
Bu şekilleri disketten yüklüyor (dos.library sistem kütüphanesi ile dosyaları nasıl yükleyeceğimizi daha sonra göreceğiz
). Sorun şu ki, resimlerin .raw dosyaları vardı, ancak her resmin
paletini ana programda hazırlanan tablolarda
saklaması gerekiyordu, her resim için bir tablo, ve bir rutin, yüklenen resme göre doğru tablodaki renkleri
copperlist'e kopyalamakla görevliydi. Ancak bu
kodun karmaşıklaşmasına neden oluyordu, çünkü resimler düzinelerceydi. Sonra
iffconverter ile, KefCon dahil,
PALETİ de kaydedilebildiğini hatırladım! CMAP OFF seçeneğini BEHIND olarak değiştirmeniz yeterlidir ve
.raw dosyasının sonuna, color0'dan sonuna kadar, kelime kelime
palet eklenir. BEFORE seçeneğini de seçebilirsiniz, bu durumda palet resmin önüne eklenir,
 ancak bu durumda “paletin arkasına” işaret etmeniz ve bunu sabitlemeniz gerekir.
CMAP BEHIND (altta) ile kaydetmenin uygun olduğuna karar verdikten sonra, kaydedilen .raw dosyasında ne
değiştiğine bakalım.
Dosya aynı, ancak daha uzun, bu dersin logosunda 16 kelime daha
uzun, çünkü sonunda 16 renk var, bu örnekte olduğu gibi
(anlamak için):

başlangıç_resim:
incbin    ‘logo320*84*16c.raw’    ; normal bitplanes.raw
dc.w $000,$fff,$200,$310    ; palet
dc.w $410,$620,$841,$a73
dc.w $b95,$db6,$dc7,$111
dc.w $222,$334,$99b,$446
fine_pic:

Logoyu bu formatta uygun şekilde yeniden kaydettim, şimdi
Lezione8q.s'de paleti copperlist'e kopyalamak için hangi basit rutini kullanabileceğimizi görelim.
Pic'in normal olarak işaretlendiğinde önceki listelerde de çalıştığına dikkat edin,
 aslında sadece son bit düzleminin “sonrasına” geldiği için görüntülenmeyen “fazladan” kelimeler var.

Başka bir soru da, makinede hangi işlemcinin ve hangi kickstart'ın mevcut olduğunu nasıl bilebileceğimizdi. Ders8r.s'de bu gizem
açığa çıkıyor...
 bunun için ayrılmış bitlere bakmanız yeterlidir!

Eğer buraya kadar her şeyi anladığınıza emin iseniz,
LEZIONE9.TXT dosyasını yükleyebilirsiniz. Bu dosya size nihayet blitter'ı tanıtacaktır.
Bu noktada, blitter'ın gerçekten var olup olmadığını merak ediyordunuzdur.

Not: İngilizce okuyabiliyorsanız, şu temel kitaplar size kesinlikle yararlı olacaktır
:

Amiga donanım kılavuzunun ikinci baskısı:

“Amiga Hardware Reference Manual” ISBN kodu: 0-201-18157-6


680x0 İLE İLGİLİ OLARAK:

Motorola, “MC68020 32-bit Microprocessor User Manual, fourth edition”,
Prentice Hall ISBN 0-13541657-4

Motorola, “MC68030 Enhanced 32-bit Microprocessor User Manual, ikinci baskı”
Prentice Hall ISBN 0-13-566951-0, Motorola ISBN 0-13-566969-3.

Motorola, “MC68040 32-bit Mikroişlemci Kullanıcı Kılavuzu”


68000 kullanım kılavuzunu veya 68040 kullanım kılavuzunu almamanız daha iyi olabilir,
çünkü 68000 (umarım) 68000-2.txt dosyasında yeterince iyi açıklanmıştır ve
68040 şu anda sadece birkaç şanslı kişinin elinde olduğundan,
sadece 68040'ta çalışan demo veya oyunlar çok yaygın değildir. Ayrıca en büyük farklar
68000 ve 68020 arasında iken, 68020 ve 68030 arasında çok az fark vardır
aynı şey 68030 ile 68040 için de geçerlidir. En büyük farklar
MMU ve CACHE kontrol komutlarında olmakla birlikte,
demo programları ve işletim sistemleri programlamadığımız için bu farklar bizim için çok önemli değildir.

_/\ /\ /\_
_ \ (_/ \_) / _
_)\__________________________) _/\_ (__________________________/(_
(______________\_\__\___\________) (________/___/__/_/______________)
(_ ________________\_\__\___ \/ ___/__/_/_________________ _)
\/ \ / \/
\/