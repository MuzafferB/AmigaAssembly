
ASEMBLER KURSU - DERS 4

Bu derste, copperlist kullanarak çeşitli çözünürlüklerde şekilleri görüntülemeyi öğreneceğiz.
 Şimdiye kadar sadece renk0'ı, yani $dff180'i değiştirebildik ve bununla gölgelendirmeler yaptık, ancak
şekiller WAIT komutuyla yapılamaz!!!
 Deluxe Paint ile oluşturulmuş, dijitalleştirilmiş, taranmış veya
Imagine veya Real 3d gibi bir ışın izleme programı ile renderlenmiş normal bir IFF figürü görüntülemek için WAIT gerekmez!!!!
Copper'a resmin grafik çözünürlüğünü (renk sayısı,
yüksek veya düşük çözünürlük, taramalı veya taramasız) BPLCON0 kaydı,
yani $dff100 aracılığıyla belirtmeniz yeterlidir. Bu değeri şu ana kadar her zaman $200 olarak tuttuk, bu da
şunu gösterir: “ÜSTÜNE YAZILAN” RESİMLER OLMADAN SADECE ARKA PLAN RENK.
Bu nedenle, bu tür bir bakır listesinde örneğin
color1, yani $dff182'yi değiştirirsek, hiçbir şey olmaz: çünkü hiçbir
BITPLANE, yani “bit düzlemi” etkinleştirilmemiştir , sadece “ARKA PLAN” etkinleştirilmiştir ve bunun rengi $dff180 ile
değiştirilebilir. Renk sayısını ve grafik çözünürlüğünü
(örneğin 320x200 piksel, burada PIXEL, şekli oluşturan küçük
noktaların her biri anlamına gelir) belirledikten ve görüntülenecek şeklin yerini
adresini uygun POINTER 
(
$dff080 (COP1LC) gibi kayıtlar, bit düzleminin adresi ise buraya yazılır)
şeklin renklerini, yani PALETTE (yani çizim programı (ör. DeLuxe Paint) tarafından söz konusu şekil için tanımlanan renk “PALETİ”)
tanımlamanız gerekir, aksi takdirde şekil yanlış renklerle görünecektir.
Pratik olarak, gerekli renk kayıtlarını copperlist'e koymalıyız,
şekil 4 renkli ise 4 rengi tanımlamalıyız:

dc.w    $180,$xxx    ; renk 0
dc.w    $182,$xxx    ; renk 1
dc.w    $184,$xxx    ; renk 2
dc.w    $186,$xxx    ; renk 3

Bu copperlist parçası KEFCON tarafından doğrudan kaydedilir

Şeklin boyutunu “ÖZEL” boyutlara ayarlamak için
diğer KAYITLAR da vardır, örneğin OVERSCAN şekli büyütür veya
ekranın sadece bir kısmını kaplayan bir “pencere” yapabilirsiniz.
Diğer özel kayıtlar, genellikle şekilleri uzatma efektleri için kullanılan MODÜLLER'dir.
İlk örneklerde, özel kayıtları sıfırlayacağız veya normal değerlerde bırakacağız,
 böylece bir
şekil görüntülenebilecek. Öncelikle, bir IFF dosyası,
yani DeLuxe Paint tarafından yüklenebilen standart formattaki bir resim ile
bellekte bulunan ve
copper tarafından görüntülenen GERÇEK resim (RAW veya BITMAP olarak adlandırılır) arasında fark olduğu açık olmalıdır. Diskte,
resimleri görüntülemek için gerekli olan IFF formatındaki resimleri RAW formatına dönüştürebilen küçük bir program bulunmaktadır.
COPPER ile görüntülemek için gerekli olan RAW formatına dönüştürebilen küçük bir program bulunmaktadır. Resimler aslında, bellekteki tüm BINER veriler gibi birçok
0 ve 1'den oluşur. Bellekteki her verinin
BIT, yani 0 ve 1'lerden oluştuğunu ve bunların bellekteki
olası tek 2 durum (sadece AKIM GEÇİŞİ ve AKIM YOKLUĞU
olabilir); kolaylık olması için ondalık ve onaltılık sistemi kullanıyoruz, ancak
gerçekte her zaman BIT'ler söz konusudur. Öyleyse, bitler sadece 0 ve 1 olabiliyorken,
32 renkli bir resmi nasıl görüntüleyebiliriz??? 
Belleğe, kareli bir kağıt sayfası gibi, bazı kareleri siyah
(yani 1) ve diğerleri beyaz (yani sıfır) olacak şekilde koyarsak, sadece 2
renkle, siyah ve beyazla çalışabiliriz, eski fosfor monitörlü bilgisayarlar gibi
ve arka plan rengini (sıfır bitleri) ve
bitlerin yanmasıyla (1) oluşturulan bazı çizimler veya kelimeleri görüntüleyebilirdi.
COPPER ile de bu şekilde, 2 renkle çalışmak mümkündür, tek yapmanız gereken
TEK BİR BITPLANE'İ AÇMAK YETERLİDİR. Bu durumda, daha önce açıklanan milimetre kağıdına benzer şekilde, “yanan” ve “sönük” noktalarla oluşan RAW figürü hafızaya kaydetmeliyiz.
Buraya kadar her şey açık olmalı:
bu, deniz savaşı oynamak gibi! Örneğin, bir gemi belirli sayıda PIXEL (nokta) ile yapılmış olur ve aynı şekilde her şey yapılabilir:
BİR ADAM:
belirli sayıda PIXEL'den (nokta) oluşur, aynı şekilde her şeyi yapabilirsiniz:

BİR ADAM:                 BİR UÇAK (sıfırları atladım!)
11
000011100000     000001100000         1111
000001000000     000010010000         1111
000111111000     000010010000     111111111111111111111
000101101000     000111111000     1111111111111111111111111
000101101000     000100001000		 1111
000011110000     000100001000         1111
000010010000                     111111
000010010000         BİR “A” 11111111
000010010000
000110011000

Şekil büyükse, çizim programı ile çizmek veya tarayıcı ile taramak ve ardından
bu diskteki (KEFCON)
programı ile RAW (0000110101...) formatına dönüştürmek daha uygun olacaktır. Arka plan rengini (sıfırları) tanımlamak için
dc.w $180,$000 (siyah) yazmanız yeterlidir, 1'lerin rengini tanımlamak için
dc.w $182,$0f0 (yeşil) yazmanız yeterlidir.
Çok renkli şekiller için püf noktası şudur: çeşitli BITPLANES, yani BIT DÜŞÜNCELERİ
(0001010 vb.) bir tür ŞEFFAFLIK içinde “ÜST ÜSTE YERLEŞTİRİLİR”,
böylece iki “1” üst üste geldiğinde belirli bir renk,
üç “1” üst üste geldiğinde başka bir renk vb. görünür. Bunların hiçbiri
hesaplanmamalıdır!!! Resmi Iffconverter ile yükleyip RAW olarak kaydedin,
sonra renk sayısını ve çözünürlüğü $dff100 (bplcon0) içine yazın,
resmin RAW dosyasını koyduğumuz yeri copper'a söyleyin, doğru renkleri (
iffconverter ayrı olarak kaydeder) yazın ve resim sorunsuz bir şekilde
görünür. Önemli olan işlemi net bir şekilde anlamaktır, pratikte
IFF görüntüsünü RAW'a dönüştürmek ve kaynağı değiştirmek iki
dakika sürer.
Öncelikle iffconverter'ın ne yaptığını açıklayalım (bizim durumumuzda
KEFCON adlı programı kullanıyoruz, bunu asmone penceresini taşıyarak ve
DOS MENÜSÜNE adını yazarak yükleyebilirsiniz; daha yeni ve
daha fazla seçeneğe sahip iffconverter'lar da var, bunlardan bazıları genellikle gereksizdir, ancak yer
ve kickstart 1.3 ile uyumluluk nedenleriyle bunu kursa koymaya karar verdim.
Ayrıca, işletim sistemi yerine donanım kayıtları kullanılarak programlandığı için
kursla uyumludur. Başka 
iffconverters kullanmak isterseniz, kullanabilirsiniz, ancak önce bunu kullanmayı öğrenin, çünkü
bu, muhteşem oyunlar ve demolar yapmak için kullanıldı). Gerçekte bir görüntünün
bit planlarından oluştuğunu gördük, daha fazla renk için daha fazla plan,
sadece 2 renk için. Ayrıca görüntülenebilmesi için
doğru renklerin (palet) ve $dff100 (bplcon0) içinde doğru çözünürlüğün gerekli olduğunu gördük;
Amiga programcıları, resimleri depolamak ve bir programdan diğerine aktarmak için özel bir format oluşturmaya karar verdiler:
 Amiga için bu format
IFF ILBM'dir ve pratikte, daha az yer kaplamak için belirli bir rutinle sıkıştırılmış bit düzlemlerinden
oluşur, palet ve
çözünürlük eklenir; bir program bir IFF görüntüsünü yüklediğinde, sıkıştırılmış DÜZLEMLERİ
açar, paleti renk kayıtlarına ($dff180,$dff182,
$dff184 vb.) ve çözünürlüğü $dff100, BPLCON0'a (Özetle) yerleştirir.
Aynı şekilde, bellekte bir görüntü olduğunda, onu IFF olarak kaydetmek için
BITPLANES'i IFF formatında sıkıştırmalı, paleti ve geri kalanını eklemelidir.
Iffconverter şu işlemleri yapar: bir RAW dosyasını yükleyebilir ve IFF olarak kaydedebilir,
eğer doğru PALETTE ve ÇÖZÜNÜRLÜK verilirse, veya
bir IFF görüntüsünü yükleyebilir ve RAW olarak kaydedebilir, ve PALETTE'yi
dc.b $180,xxx,$182,xxx formatında kaydedebilir, yani
copperlist'e eklenmesi gereken PALETTE'yi. Diğer bilgisayarlarda resimler için farklı formatlar kullanılır,
örneğin GIF, PCX ve TIFF MSDOS PC'lerde kullanılır;
RAW+PALETTE resimleri farklı şekilde SIKIŞTIRILMIŞ olmasının yanı sıra, bu bilgisayarlarda
görüntüleme sistemi de farklıdır, çünkü bitplane yerine CHUNKY sistemine sahiptirler.
 Bu sistem, 256 rengi yönetmek gerektiğinde kullanışlıdır, ancak
Amiga'nın SCROLL (kaydırma) özelliği kadar yetenekli değildir ve COPPER'ın WAIT ile yaptığı gibi PALETTE'yi değiştirme
olasılığı yoktur.
Normal Amiga'nın (AGA değil) olası grafik çözünürlükleri şunlardır:

320x256 PIXEL, LOW RES (düşük çözünürlük) olarak adlandırılır
640x256 PIXEL, HIGH RES (yüksek çözünürlük) olarak adlandırılır

Görüntü daha uzun (overscan ile 312 satır) veya iki kat daha uzun
(ancak titremeye neden olan interlace ile) olabilir.
Genişlik de OVERSCAN ile biraz artırılabilir.

LOW RES (320 piksel genişliğinde) görüntüler maksimum
32 renge kadar olabilir, ayrıca EHB (Extra Half Bright) ve
HAM (Hold And Modify) adlı 2 özel mod vardır ve sırasıyla 64 ve 4096 renk görüntüler, ancak
görüleceği üzere bazı özel sınırlamaları vardır.
HIGH RES (yüksek çözünürlük) görüntülerde maksimum 16
renk olabilir ve özel modları yoktur.
Oyunların neredeyse tamamı LOW RES'tir, çünkü bu modda mevcut renklerin çoğunu kullanmak
mümkün, bellek tasarrufu sağlanıyor (maalesef bellek SINIRLIDIR!) ve
daha yüksek hız elde edilebiliyor (HIGH RES, LOW RES'e göre işlemleri daha fazla yavaşlatıyor,
 ayrıca görüntü iki kat daha geniş olduğu için daha büyük bellek parçaları taşınması gerekiyor!
Renk görüntüleme tekniğini inceleyelim: lowres'te
maksimum renk sayısının 32 olduğunu (özel modları saymazsak) söylemiştik;
2, 4, 8, 16 veya 32 renkli bir video çözünürlüğü seçmek mümkündür. Bunun
nedeni, bunların BIT'lerin üst üste binmesiyle belirlenmesidir, bu nedenle her bit düzlemine
“ÜST ÜSTE KADIRDIĞIMIZ” her “PIKSEL”E 2 bit ekleriz ve bu da 2 bit “DAHA DERİN” hale gelir
: şimdi 2 bit ile sadece 0 ve 1, yani
2 renk elde edilebilir, bu nedenle 320x200 çözünürlükte 2 renk tek bir BITPLANE'e sahip olacaktır,
daha önce de belirttiğimiz gibi. Başka bir bitplane eklendiğinde olası renk sayısı
4'e çıkar, çünkü her PIXEL için 4 üst üste binme durumu
olabilir: 00,01,10,11, yani “her iki bit sıfır”, "birinci bit düzlemi
sıfır ve ikinci 1“, ”birinci bit düzlemi 1 ve ikinci sıfır“, ”her iki
bit düzlemi 1". Başka bir bit düzlemi eklendiğinde 8
farklı durum (8 farklı renge karşılık gelir) ortaya çıkabilir:
000,001,010,011,100,101,110,111 (3 bit düzlemi=3 bit/PIKSEL=8 olasılık)
Dördüncü bir bit düzlemi eklendiğinde, PIKSEL için 4 bit olasılığa ulaşılır,
yani 16 renk için 16 farklı olasılık:
0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111
Aynı şey beşinci bit düzlemi için de geçerlidir, bu da piksel başına bit sayısını 5'e çıkarır,
 yani 32 olası renk. Dolayısıyla her bit düzlemi renk sayısını ikiye katlar
:

0 bit düzlemi = sadece arka plan rengi COLOR00 ($dff180), 1 RENK
1 bit düzlemi = 2 RENK
2 bit düzlemi = 4 RENK (2*2, yani 2'nin ikinci kuvveti)
3 bit düzlemi = 8 RENK (2*2*2, yani 2'nin üçüncü kuvveti)
4 bit düzlemi = 16 RENK (2*2*2*2, yani 2'nin dördüncü kuvveti)
5 bit düzlemi = 32 RENK (2*2*2*2*2, yani 2'nin beşinci kuvveti)

Amiga, LOWRES'te mümkün olan 32 renk için 32 kayıt alanına sahiptir. Bu kayıt alanları
COLOR0'dan COLOR31'e kadar uzanır (numaralandırma, bitlerde olduğu gibi sıfırdan başlar).
 Color0, $dff180'dir ve onu diğerleri izler:

$dff182 = COLOR1
$dff184 = RENK2
$dff186 = RENK3
$dff188 = RENK4
$dff18a = RENK5
vb.

Örneğin, 16 renkli bir düşük çözünürlüklü görüntünün bir pikseli
“ARKA PLAN”, yani COLOR0 rengindeyse, bu, $dff180 üzerinde değişiklik yaparak değiştirilebilir ve
4 bit düzleminin tümünün sıfır olduğu anlamına gelir: 0000,
COLOR31 olarak adlandırılan 32 rengindeki bir piksel ise bu ikili kombinasyonun sonucudur: 1111.
Diğer renkler, diğer kombinasyonların sonucudur. Amiga 1200, CHIPSET AGA ile en fazla 8 bit düzlemine sahiptir
, bu sayede 256
renk (2'nin sekizinci kuvveti=256) üretebilir, AGA grafik programlarında
64 renk (6 düzlem), 128 renk (7 düzlem) çözünürlükler de seçilebilir.
Bir video ekranı PLAYFIELD olarak da adlandırılır.
320*256 çözünürlükte 2 renkli bir şeklin ne kadar bellek kapladığını hesaplayalım:
Her satır 320 pikseldir, bir bayt sekiz bitten oluştuğundan, bir satırda
40 bayt vardır (aslında 8*40=320). O halde, 40'ı, yani
satır başına bayt sayısını, satır sayısıyla, yani 256 ile çarpmamız yeterlidir: 40*256=10240.
Dolayısıyla, düşük çözünürlükte bir bit düzlemi 10240 bayt yer kaplar. O halde
4 renkli, yani 2 bit düzlemli bir şekli de hesaplayabiliriz: 40*256*2=20480.
Dolayısıyla, standart DÜŞÜK ÇÖZÜNÜRLÜKLÜ bir şekil için 40*256*bit düzlemlerini çarpmak yeterlidir.
LOWRES'te satır başına 320 bit, yani 40 bayt olduğu belirlenmiştir, HIRES'te
genişliği iki katı olduğu için satır başına 80 bayt olacaktır: 80*256*bitplanes.
Sonuç olarak, büyüklüğü hesaplamak için genel formül şöyledir:

Satır başına bayt * oyun alanı satırları * bit düzlemi sayısı

Şimdi BPLCON0'ı, çözünürlüğün ve
renk sayısının belirtildiği kaydı analiz edelim:    ( “=C 100” yazarak bir özeti okuyabilirsiniz )

$dff100 - BPLCON0

Bit Düzlemi Kontrol Kaydı 0    (1 kelime, yani 16 bit, 0'dan 15'e kadar)

BIT SAYISI            (not: bit 1 = AÇIK, bit 0 = KAPALI)

15    -    HIRES    Yüksek çözünürlük modu (1=640x256 , 0=320x256)
14    -    BPU2    \
13    -    BPU1     ) 3 bit, bit düzlemlerinin sayısını seçmek için
12    -    BPU0    /
11    -    HOMOD    Hold And Modify modu (HAM 4096 renk)
10    -    DBLPF    Çift oyun alanı
09    -    COLOR    kompozit video (GENLOCK için)
08    -    GAUD    Genlock ses
07    -    X
06    -    X
05    -    X
04    -    X
03    -    LPEN    Işıklı kalem (Optik kalem)
02    -    LACE    Aralıklı (320x512 veya 640x512)
01    -	ERSY    Harici yeniden senkronizasyon (GENLOCK için)
00    -    X

Bu kayıt BITMAPPED'dir, yani her bir biti bir işleve sahiptir:

- Bit 15, yüksek çözünürlük modunu etkinleştirir: bu grafik modu, 320 yerine
yatay satır başına 640 piksel görüntüler. DDFSTART/STOP
'u $003c ve $00d4 yerine $0038 ve $00d0'a koymayı unutmayın, aksi takdirde
sol kenarın ilk satırları görüntülenmez!
- Bit 14-12, hangi düzlemin değil, kaç düzlemin açılacağını belirlemek için kullanılır
; aslında 3 bit vardır ve 6 düzlem mümkündür.
Buraya, hangi düzlemi seçtiğinizi DEĞİL, kaç düzlemi yakmak istediğinizi bir sayı olarak yazmanız gerekir.
Örneğin: ‘3’, ‘0’, ‘6’.
3 bit ile 0'dan 7'ye kadar 8 sayı ifade edilebilir.
Tekrar ediyorum: 3 BIT'LİK BİNER SAYI İLE ÇALIŞIN,
DİĞER BİT'LERDEN FARKLI OLARAK, YAKILACAK VEYA SÖNDÜRÜLECEK TEK TEK BİT'LERLE ÇALIŞMAYIN!
N.B.: ‘0’ (=%000) yazıldığında tüm düzlemler söner, %101 yazıldığında
5 tanesi yanar; 6 düzlem ile 64 renkli HALF-BRIGHT modu etkinleştirilir.
- Bit 11, HAM modunu etkinleştirmek için kullanılır (6 düzlem yanmalıdır)
HAM, normal Amiga'larda 4096 renk görüntülenmesini sağlar, HAM8
ise Amiga 1200/4000'lerde 262144 renk görüntülenmesini sağlar.
- Bit 10, Dual PlayField modunu etkinleştirir, bu özel mod
2, 4 veya 6 düzlemde 1, 2 veya 3 düzlemden oluşan iki ekran oluşturmaya
her biri PlayField1 ve PlayField2 olarak adlandırılır ve birbirinin üzerine şeffaf olarak üst üste bindirilir
ve üstteki PlayField'ın rengi 0 şeffaf hale gelir.
Böylece, birçok oyunda bulunan paralaktik bir efekt yaratmak mümkündür.
 Örneğin, oyun alanı için 3 düzlemli bir PlayField
(8 renk) oyun alanı için ve başka bir PlayField arka plan için, belki
daha yavaş kayarak daha fazla derinlik hissi vermek için,
 ovaları ve dağları tasvir etmek için.
Bit ayarlandıktan sonra, tek sayıdaki düzlemler (1,3,5) playfield1'i oluştururken
çift sayıdaki düzlemler (2,4,6) ikincisini oluşturur: DPF biti etkinleştirildiğinde, donanım
düzlemleri bağımsız hale getirmek için gruplandırır, çünkü
daha sonra göreceğimiz gibi, çift ve tek uçlu uçlar için parametreleri ayıran kaydırma kayıtları ve diğer kayıtlar vardır,
 bunlar ayrıca çift modda iki tam oyun alanını bağımsız olarak kontrol etmek için de kullanılır
!
Not: DualPlayField modu, yalnızca 2 ekranın üst üste bindirilmesine izin verir ve her durumda
benzer grafik çözünürlüğe sahip olmalıdır (örneğin: Hires+Hires, Lowres+Lowres, vb.).
- Bit 9, Amiga'nın RGB monitörün yanında bulunan kompozit video çıkışını da etkinleştirir
.
 Şahsen, ben bunu her zaman etkinleştiririm,
 böylece ürünlerimi kullanırken standart RGB monitörü olmayanlar da
monitörde bir şeyler görebilirler. HER ZAMAN 1'E AYARLAYIN.
- Bit 8, Amiga'ya bağlı bir genlock'un sesini etkinleştirir:
Pratikte hiçbir işe yaramaz, bu yüzden üzerinde durmayalım.
- Bit 7, yalnızca A1200'ün gelişmiş yonga setlerinde kullanılır, normal Amiga'larda
hiçbir işlevi yoktur. Yine de, kullanılmayan bu bitleri
her zaman sıfırda bırakmayı unutmayın, aksi takdirde a1200'de demo/oyun/programınızın
çalışmasını tehlikeye atabilirsiniz.
- Bit 6 normal Amiga'larda işlevi yoktur, sıfırda bırakın.
- Bit 5'i sıfırda bırakın
- Bit 4'ü sıfırda bırakın
- Bit 3, elektronik fırçanın kayıtlarında
VHPOS ($dff006) ve VPOS ($dff004) optik kalemin koordinatlarını almak için kullanılır. Optik kalem
Amiga'da neredeyse hiç kullanılmaz, bu seçenek önemli değildir.
- Bit 2, InterLace modunu ayarlar, bu mod
çift dikey çözünürlüklü, ancak taramalı bir ekran görüntüsünün görüntülenmesini sağlar. (512 satır)
Bu modun nasıl çalıştığını daha sonra göreceğiz
- Bit 1, fırçanın hareketini Amiga dışındaki bir cihazın frekansı ile senkronize etmek için kullanılır,
 bu nedenle her zaman sıfırda bırakın.
- Bit 0'ı sıfırda bırakın

Bunu söyledikten sonra, copperlist'te $100 (BPLCON0) kullanımına ilişkin bazı örnekler verelim:

; 5432109876543210
dc.w $100,%0100001000000000    ; ---> 4 düzlem Lowres (320x256)
dc.w $100,%1011001000000100    ; ---> 3 düzlem Hires+Interlace (640x512)
dc.w $100,%0110001000000100    ; ---> 6 düzlem HALF-BRIGHT Lowres+Lace
dc.w $100,%0110101000000000    ; ---> 6 düzlem HAM lowres (4096 renk)
dc.w $100,%0110011000000000    ; ---> DualPlayField 3+3 düzlem Lowres
dc.w $100,%1100011000000100    ; ---> DualPlayField 2+2 Hires+interlace

Ders 3'te BPLCON0'ı copperlist'te $200 değeriyle kullandık:

dc.w    $100,$200

Aslında sadece genlock'u etkinleştirmek için gerekli olan bit 9'u ayarladık:

; 5432109876543210
dc.w	$100,%0000001000000000

Genlock, Amiga ile oluşturulan başlıkları veya grafikleri televizyon ekranına
üst üste bindirmek için kullanılan bir cihazdır, bu nedenle bu aksesuara sahip olmayanlar
bit 9'un etkin olduğu bir copperlist ile
etkinleştirilmiş bir copperlist ile bit devre dışı bırakılmış bir copperlist arasında bir değişiklik göremez, ancak genlock'u bizim copperlist'lerimizle kullanmak isteyenler için ve eski
Amiga 1000'in renkli monitör için bir video kompozit çıkışı olduğu için
bit'i her zaman 1'de tutmak daha iyidir.
Dolayısıyla, dc.w $100,0 ile de RGB'de aynı sonucu elde ederdik.
Gördüğünüz gibi, bit düzlemleri SIFIR'dır, bu nedenle sadece arka plan rengi vardır ve
üzerine baskı yoktur. Bit düzlemlerini “AÇMAK” için, istediğimiz
bit düzlemi sayısını ikili olarak, kaydın 12,13,14 bitlerine yazmak yeterlidir.

Örneğin, 1 bit düzlemli (2 renkli) bir ekran yapmak için: (320x256!)

; 5432109876543210
dc.w    $100,%0001001000000000    ; BPLCON0 - bit 12 açık!! (1 = %001)

*

2 bitplane'li bir ekran için: (4 renk)

; 5432109876543210
dc.w    $100,%0010001000000000    ; BPLCON0 - bit 13 açık!! (2 = %010)

*

3 bit düzlemli bir ekran için: (8 renk)

; 5432109876543210
dc.w    $100,%0011001000000000    ; bit 13 ve 12 açık!! (3 = %011)

*

4 bit düzlemli ekran için: (16 renk)

; 5432109876543210
dc.w    $100,%0100001000000000    ; BPLCON0 - bit 14 açık!! (4 = %100)

*

5 bit düzlemli bir ekran için: (32 renk)

; 5432109876543210
dc.w    $100,%0101001000000000    ; bitler 14,12 yanıyor!! (5 = %101)

*

6 bit düzlemli ekran için: (EHB ve HAM 4096 renk özel modları için)

; 5432109876543210
dc.w    $100,%0110001000000000    ; bit 14,13 yanıyor!! (6 = %110)

(Bu modda, HAM bitini (11) 1'e ayarlamazsanız ekran
Extra Half Bright modunda olur, bit 11 ayarlanırsa ekran HAM modunda olur.

*

Bu durumda, kayıt defterinin 3 bit 12,13,14
kısımlarına gerekli bit düzlemi sayısını girmeniz yeterlidir. Ekranı yüksek çözünürlükte, 640 piksel genişliğinde
320 piksel genişliğinde bir ekran istiyorsanız, soldaki ilk bit olan 15'i 1'e ayarlamanız yeterlidir.
HIRES'te maksimum bit düzlemi sayısı 4 (16 renk) olduğunu ve
DFFSTART ($dff092) ve DFFSTOP ($dff094) değerlerini LOWRES'e göre değiştirmeniz gerektiğini unutmayın:

dc.w    $92,$003c    ; DdfStart normal HIRES
dc.w    $94,$00d4    ; DdfStop normal HIRES

Aynı şey tarama için de geçerlidir (256 yerine 512 satır uzunluğu), 
bit 2'yi 1'e ayarlamak yeterlidir.

BPLCON0 doğru şekilde ayarlandıktan sonra, “AKTİF” hale getirdiğimiz bitplane'lerin
yerini belirtmek gerekir. Bunu yapmak için, adreslerini
uygun kayıtlara girmek yeterlidir. Bunlar şunlardır:

$dff0e0    = BPL0PT (bitplane 1 işaretçisi)
$dff0e4    = BPL1PT (bit düzlemi 2 işaretçisi)
$dff0e8    = BPL2PT (bit düzlemi 3 işaretçisi)
$dff0ec    = BPL3PT (bit düzlemi 4 işaretçisi)
$dff0f0    = BPL4PT (bit düzlemi 5 işaretçisi)
$dff0f4    = BPL5PT (bit düzlemi işaretçisi 6)

Burada da sıfırdan başlıyoruz, dolayısıyla altıncıyı tanımlamak için 5'e ulaşıyoruz.
Bazen ise $dff0e0 BPL1PT ile gösterilebilir ve
sonuç olarak altıncıyı tanımlamak için 6'ya ulaşırız. Asmone'nin yardım bölümü
BPL0PT'den başlar, “=c 0e0” yazarak kontrol edebilirsiniz
Bir şekli görüntülemek için, doğru
BPLCON0 ve doğru renklerle bir bakır listesini işaret etmek yeterlidir, ardından bit düzlemlerini de işaret etmek gerekir,
örneğin şöyle:

MOVE.L    #BITPLANE0,$dff0e0    ; BPL0PT'deki BITPLANE0 adresi
MOVE.L    #BITPLANE1,$dff0e4    ; BPL1PT
MOVE.L    #BITPLANE2,$dff0e8    ; BPL2PT
...

Ve resim sihirli bir şekilde ortaya çıkacaktır. Bitplanes yine de
copperlist içinde doğrudan işaretlenir, çünkü işaretçiler her
kare için yeniden yazılmalıdır.

“Özel” kayıtları bakır listesine eklemeyi asla unutmayın.
Şu anda bunları sıfırlanmış veya normal değerleriyle kullanacağız, aksi takdirde
workbench'in bakır listesinin değerini alırlar ve bu kayıtlar sıfırlanmamışsa görüntüleme bozulabilir
(örneğin, kickstart 1.3'ün workbench'inde MODULI sıfırlanmıştır, ancak kickstart 2.0'da
farklı değerlere sahiptir: kick 1.3'te çalışan oyunlar ve grafik demolar
kick 2.0'da ise şekilleri yanlış görüntüler, bunlar genellikle
modül kayıtlarının, $dff108 ve $dff10a'nın eksik olduğu bakır listesiyle yapılmıştır,
 bunlar kick1.3'te sıfırdır, bu nedenle testte çalışıyordu, ancak kick 2.0'da
görüntüleme bozuluyor. Bu sorunları önlemek için her
copperlist'te, kullanmadıklarımız da dahil olmak üzere tüm kayıtları tanımlamak her zaman iyidir
; söz konusu kayıtlar şunlardır:

$dff08e - DIWSTRT, video penceresinin başlangıcı - normalde $2c81
$dff090 - DIWSTOP, video penceresinin sonu - normalde $2cc1
$dff092 - DDFSTRT, veri alma başlangıcı - normalde $0038
$dff094 - DDFSTOP, veri alma durdurma - normalde $00d0
$dff102 - BPLCON1, Bitplane kontrol 1 - normalde $0000
$dff104 - BPLCON2, Bitplane kontrol 2 - normalde $0000
$dff108 - BPL1MOD, çift bitplanes modülü - normalde $0000
$dff10A - BPL2MOD, tek bitplanes modülü - normalde $0000

Bu kayıtlar hakkında, özel efektler oluşturmak için kullandığımızda konuşacağız.
Şimdilik, bakır listesinin başına her zaman
bu kayıtları standart değerleriyle eklemeyi unutmayın:

COPPERLIST:
dc.w    $8e,$2c81    ; DiwStrt
dc.w    $90,$2cc1    ; DiwStop
dc.w    $92,$0038    ; DdfStart * NOT: HIRES 640x256 için $003c
dc.w    $94,$00d0    ; DdfStop * NOT: HIRES 640x256 için $00d4
dc.w    $102,0        ; BplCon1
dc.w    $104,0        ; BplCon2
dc.w    $108,0        ; Bpl1Mod
dc.w    $10a,0        ; Bpl2Mod

dc.w    $100,xxxx    ; Bplcon0 - Renkleri ve çözünürlüğü tanımlayalım

;    Buraya şeklin renklerini koyabiliriz; bu parça
;    copperlist doğrudan KEFCON iffconverter tarafından oluşturulur,
;    istediğiniz bir adla ayrı olarak kaydedin, daha sonra
;    örneğin başka bir tampona yükleyerek editörün KES&YAPIŞTIR seçeneği ile buraya ekleyebilirsiniz
;    .

dc.w $0180,$0010,$0182,$0111,$0184,$0022,$0186,$0222
dc.w $0188,$0333,$018a,$0043,$018c,$0333,$018e,$0154
dc.w $0190,$0444,$0192,$0455,$0194,$0165,$0196,$0655
dc.w $0198,$0376,$019a,$0666,$019c,$0387,$019e,$0766
dc.w $01a0,$0777,$01a2,$0598,$01a4,$0498,$01a6,$0877
dc.w $01a8,$0888,$01aa,$05a9,$01ac,$0988,$01ae,$0999
dc.w $01b0,$06ba,$01b2,$0a9a,$01b4,$0baa,$01b6,$07cb
dc.w $01b8,$0bab,$01ba,$0cbc,$01bc,$0dcd,$01be,$0eef

;    Gördüğünüz gibi burada Amiga'nın 32 renk kaydı tanımlanmıştır,
;    aslında KEFCON ile 32 renkli bir resim yükledim ve bu
;    RAW formatındaki resimle birlikte oluşturulan PALETTE'dir.

;    Burada WAIT ile video efektleri yapabilirsiniz....

dc.w    $FFFF,$FFFE    ; Copperlist sonu


Bu copperlist, bir resmi görüntülemek için yeterlidir.
Şimdi, 3 bit düzlemli, yani 8 renkli bir PLAYFIELD
görüntüleme örneğiyle devam edelim. Bu dersin ilk örneğinde,
RAW formatına dönüştürülmüş bir resmi görüntülüyoruz ve bu resim
: Resmi belleğe “YÜKLEMEK” için, ASMONE'de INCBIN adlı bir komut vardır.
Bu komut, diskten belirli bir veri dosyasını yükleyip
programımızın incbin'in bulunduğu noktasına kopyalamayı sağlar
: Örneğin, bir copperlist hazırlayıp bunu
dosya olarak kaydetsem, şu şekilde yükleyebiliriz:

COPPERLIST:
incbin    “copper1”

Sonuç, copper1 dosyasında bulunan kelimelere eşdeğer birçok dc.w koymakla aynıdır.
 Bizim durumumuzda, görüntüyü bir
PIC etiketi altında yükleriz:

PIC:
incbin    “amiga.320*256*3”

Resim yine de METİN biçiminde değil, bit düzlemlerini oluşturan baytlar biçimindedir
: bunu bir metin tamponuna yüklemeyi deneyin, bunun
metin olmadığını göreceksiniz.

Gördüğünüz gibi, resmin adı resmin özelliklerine göre verilmiştir
; resimleri, özelliklerini yansıtan isimler seçmek, dönüştürdüğünüz RAW resimlerin boyutunu ve
bitplane sayısını unutmamanız için önemlidir.
 Ancak
bu ham görüntünün uzunluğundan çözünürlük ve bit düzlemlerinin sayısı
çıkarılabilir: 30720 bayt uzunluğundadır, yani 40*256*3 (40 bayt/satır*256 satır,
3 bit düzlemi ile çarpıldığında 30720 olur). Bu nedenle COPPER'a resmin PIC etiketinde olduğunu söylemek yeterlidir
ve işlem tamamdır.

Ancak, hata riski olmadan bit düzlemlerini işaretlemek için
işaretçileri copperlist'e koymak gerekir. Aslında bit düzlemlerinin işaretçileri
her biri bir kelime, yani bir adresin yarısını içerebilir (aslında bir
adres bir longword uzunluğundadır! örneğin $00020000). İşlemciyi kullanırsak
tek bir move.l ile 2 kelimelik kayıt yükleyebiliriz.

MOVE.L    #BITPLANE00,$dff0e0    ; BPL0PT
MOVE.L    #BITPLANE01,$dff0e4    ; BPL1PT ($dff0e0'dan 2 kelime ileride)

Ancak bakır listesinde, bilindiği gibi her hareket sadece bir KELİME olabilir:

MOVE.W    #$123,$dff180    dc.w    $180,$123

Bit düzlemlerine işaret eden durumlarda, her adresi
bir LONGWORD uzunluğunda 2 kelimeye “BÖLÜMÜŞ” olmalıyız, böylece şunu yapabiliriz:

MOVE.W    #BITPL,$dff0e0    ; BPL0PTH (H=adresin ÜST kelimesi)
MOVE.W    #ANE00,$dff0e2    ; BPL0PTL (L=adresin ALT kelimesi)
MOVE.W    #BITPL,$dff0e4    ; BPL1PTH
MOVE.W    #ANE01,$dff0e6    ; BPL1PTL

BPLxPTH    = BitPLane x PoinTer Yüksek kelime, yüksek kelime işaretçisi
BPLxPTL	= BitPLane x PoinTer Low word , düşük kelime işaretçisi

BITPLANE00'ı (bir uzun kelime uzunluğunda) 2 kelime BITPL ve ANE00'a böldük ve
2 MOVE.W ile MOVE.L ile aynı sonucu elde ettik, bu da
copperlist'e uygundur, burada şöyle çeviririz:

dc.w    $e0,BITPL	; BPL0PTH \ilk bitplane
dc.w    $e2,ANE00    ; BPL0PTL /

dc.w    $e4,BITPL    ; BPL1PTH \ikinci bitplane
dc.w    $e6,ANE01    ; BPL1PTL /

(aslında $dff0e0, bakır listesinde $e0 olarak çevrilir, vb.)

Bu bölme, LONGWORD'ÜN ÜST WORD VE ALT WORD'E BÖLÜNMESİ olarak adlandırılır.
Burada ÜST word soldaki, BITPL, ALT word ise sağdaki,
burada ANE00'dır. Gerçek adreslerle bir örnek verelim:

Bitplane0 $23400'da, bitplane1 $25c00'da bulunur.

dc.w    $e0,$0002    \ilk bitplane (yüksek kelime)    \$00023400
dc.w    $e2,$3400    /        (alçak kelime)    /

dc.w    $e4,$0002    \ikinci bitplane (yüksek kelime)	\$00025c00
dc.w    $e6,$5c00    /         (düşük kelime)    /

Doğru adresleri
copperlist'e koymak için şeklin hangi adreste olduğunu kontrol etmek ve
söz konusu kelimeleri elle değiştirmek gerektiğini düşünüyorsunuzdur. Oysa, adresleri “BÖLMEK” vecopperlist'e doğru yere yerleştirmek için yapmamız gereken tek şey, on
kadar komuttan oluşan küçük bir rutin. Bu rutin,
istediğimiz bitplane sayısına sahip herhangi bir boyuttaki herhangi bir şekli
işaretlemek için kullanılabilir, tek yapmamız gereken parametreleri değiştirmek!!! İşin püf noktası, 68000'in
özel bir komutunun kullanılmasıdır. SWAP, İngilizce'de DEĞİŞTİR anlamına gelir,
ve aslında bir longword'daki 2 kelimeyi DEĞİŞTİREREK
YÜKSEK olanı ALÇAK yapar ve tersini yapar:

MOVE.L    #CANETOPO,d0    ; d0'a CANETOPO uzun kelimesini koyuyoruz

SWAP    d0        ; KELİMELERİ DEĞİŞTİRİYORUZ: sonuç olarak
; d0'da TOPOCANE var!!!!

Bu komut sadece VERİ kayıtlarında çalışır.
Aynı şekilde $00023400, 34000002 olarak değiştirilir.
Rutini görelim:


MOVE.L    #PIC,d0        ; d0'a PIC'in adresini koyarız,
; yani ilk bit düzleminin başladığı yeri

LEA    BPLPOINTERS,A1    ; a1'e
; COPPERLIST'teki planes'lerin işaretçilerinin adresini koyar
MOVEQ    #2,D1        ; bitplanes sayısı -1 (burada 3 tane var)
; DBRA ile döngüyü gerçekleştirmek için
POINTBP:
move.w    d0,6(a1)    ; düzlemin adresinin ALT kelimesini
; copperlist'teki doğru kelimeye kopyalar
swap    d0        ; d0'daki 2 kelimeyi değiştirir (ör: 1234 > 3412)
; ALT kelimesinin yerine
; ALT kelimesini koyarak, move.w ile kopyalanmasını sağlar!!
move.w    d0,2(a1)    ; plane adresinin ÜST kelimesini
; copperlist'teki doğru kelimeye kopyalar
swap    d0        ; d0'daki 2 kelimeyi değiştirir (ör: 3412 > 1234)
; adresi yerine geri koyar.
ADD.L    #40*256,d0    ; D0'a 10240 ekleyerek,
; ikinci bit düzlemine (birinciden sonra bulunur)
; (yani bir düzlemin uzunluğunu ekleyerek)
; ilk döngüden sonraki döngülerde
; üçüncü, dördüncü bit düzlemine vb.

addq.w    #8,a1        ; a1 şimdi yazılacak bakır listesindeki
; bplpointers'ların adreslerini içerir.
dbra    d1,POINTBP    ; D1 kez POINTBP'yi tekrar yap (D1=bit düzlemlerinin sayısı)

burada bakır listesinin bu kısmını değiştiriyoruz:

BPLPOINTERS:
dc.w $e0,$0000,$e2,$0000    ;birinci     bit düzlemi (BPL0PT)
dc.w $e4,$0000,$e6,$0000    ;ikinci bit düzlemi (BPL1PT)
dc.w $e8,$0000,$ea,$0000    ;üçüncü     bit düzlemi (BPL2PT)

Rutin, bit düzleminin adresini alır ve
BASSA kelimesini copperlist'teki $e2'den sonraki kelimeye, yani adresin
bassa kelimesinin işaretçisine kopyalar (bu, BPLPOINTERS'tan 6 bayt sonra bulunur, bu nedenle
move.w    d0,6(a1) kullanılır, burada a1'de BPLPOINTERS'ın adresi bulunur).
Alt kelimeyi düzelttikten sonra, SWAP ile alt kelimeyi üst kelime ile değiştiririz
ve ardından move.w d0,2(a1) ile alt kelime yerine üst kelimeyi
$e0'dan sonraki kelimeye, yani ilk bitplane'in üst kelimesinin işaretçisine kopyalarız.
 Bu, BPLPOINTERS'tan 2 bayt sonra bulunur.
Bu noktada ilk bit düzlemini İŞARETLEDİK: (ör. $23400)


BPLPOINTERS:
dc.w $00e0,$0002,$00e2,$3400	; BPL0PT - ilk bit düzlemi * İŞARETLENMİŞ *
dc.w $00e4,$0000,$00e6,$0000    ; BPL1PT - ikinci bit düzlemi
dc.w $00e8,$0000,$00ea,$0000    ; BPL2PT - üçüncü bit düzlemi

^        ^
|        |
2(a1)     6(a1)    ; kelimeleri doğru yere
; yerleştirmek için ofsetlerin kullanımına dikkat edin
.

NOT: move.w d0,x(a1) ile uzun kelimenin alt kelimesini d0'a kopyalarız çünkü
kopyalama şu şekilde gerçekleşir:

move.w    #CANETOPO,2(a1)    ; 2(a1) 'ye TOPO kopyalanır

Daha sonra, bir ADD ile bir sonraki bit düzlemine geçebilmek için adresi başka bir SWAP ile yerine geri koyarız.
L #LUNGHEZZABITPLANE,d0.
Bir addq.w #8,a1 ile ikinci bit düzlemine geçiyoruz, çünkü
a1'de BPLPOINTERS adresi varsa, 8 bayt (4 kelime) ekleyerek
bu noktaya geçiyoruz:

BPLPOINTERS:
dc.w $00e0,$0002,$00e2,$3400	; BPL0PT - birinci bit düzlemi * HEDEF *
a1PUNTAQUA:
dc.w $00e4,$0000,$00e6,$0000    ; BPL1PT - ikinci bit düzlemi
dc.w $00e8,$0000,$00ea,$0000    ; BPL2PT - üçüncü bit düzlemi

Bu rutini “DBRA d1,label” döngüsüyle tekrarlayalım, bu durumda
3 kez, 3 bit düzlemini işaretlemek için. (Hatırlayacağınız gibi, DBRA döngüsünde
döngü sayan kayıt defterine istenen sayıdan 1 eksik sayı yazılmalıdır, bu
sayılmayan ilk sayıdır: burada d1'e 2 değeri yazılır.

Bu rutin, bakırla efektler üreten rutinlerin klasik yapısına sahiptir,
 bu nedenle tam olarak anlamak çok önemlidir. Benzer bir rutin
Lezione3h.s'de bulunabilir, o durumda bakır listesindeki 29 beklemeyi değiştirmek için DBRA döngüleri vardı
.

Lezione4a.s dosyasını yükleyerek bu rutinin çalışmasını DEBUG ile pratikte görebilirsiniz.
PUNTABITPLANES

Bu noktada, görüntünün görüntülenmesinde sorun yaşamamak için listemizde sadece iki “SON DÜZENLEME” kaldı
: AGA yonga setini devre dışı bırakmak için birkaç komut
çalışmamızı Amiga 1200 ve 4000 ile uyumlu hale getiren AGA yonga setini devre dışı bırakmak için ve spriteleri ortadan kaldırmak için bakır listesinde birkaç satır daha eklemek
gerekir, aksi takdirde spriteler çizimimizde rastgele dolaşarak
aralıklı bozukluklara neden olurlar. AGA'yı devre dışı bırakmak için şu 2 satır yeterlidir:
move.w    #0,$dff1fc        ; FMODE - AGA'yı devre dışı bırak

move.w    #0,$dff1fc        ; FMODE - AGA'yı devre dışı bırak
move.w    #$c00,$dff106        ; BPLCON3 - AGA'yı devre dışı bırak

Ve emin olmak istiyorsanız şunu da ekleyebilirsiniz: (palette sprite)

move.w    #$11,$dff10c        ; BPLCON4 - Sprite paletini sıfırla

Yeni copperlist'i işaret ettikten sonra bunları çalıştırmanız yeterlidir.
Sarhoş sprite'ları durdurmak için ise, bunların işaretçilerini SIFIR'a ayarlamanız yeterlidir:

dc.w	$120,$0000,$122,$0000,$124,$0000,$126,$0000,$128,$0000
dc.w	$12a,$0000,$12c,$0000,$12e,$0000,$130,$0000,$132,$0000
dc.w	$134,$0000,$136,$0000,$138,$0000,$13a,$0000,$13c,$0000
dc.w	$13e,$0000

(Not: $dff120 ile $dff13e arasındaki kayıtlar SPR0PT, SPR1PT... SPR7PT olarak adlandırılır.)

Sprite'lar hakkında daha sonra konuşacağız, şimdilik bunları ortadan kaldırmanız yeterlidir
basit bir COPY+INSERT (Amiga+b+c+i) ile bu metin parçasını
copperlist'inize ekleyin. Sprite'lar bitplanes sıfırlandığında görünmüyordu,
 ancak tek bir bitplane bile açıldığında sprite'lar ortaya çıkıyor.

Sonunda, bir şeklin nasıl görüntülendiğini pratikte görebilirsiniz
Lezione4b.s dosyasını istediğiniz bir Fx metin tamponuna yükleyin.

Şekle bakır efektleri eklemeyi denediniz mi? Örneği yükleyin
Lezione4c.s daha önce gördüğümüz bazı efektlerin birleşimini görmek için.

Bit düzlemleri olan bir bakır listesinde WAIT'in önemini şimdi anladınız mı?
Her satırın rengini (ve sadece rengini değil) değiştirebiliriz!
Artık dersin içindeki resim yerine kendi yaptığınız bir resmi görüntüleyebiliriz.
 Bunu yapmak için 320x256 boyutunda 8 renkli bir resme ihtiyacınız var,
 eğer yoksa bir çizim programı ile basitçe yapın
veya ADPRO veya başka bir programla bir resmi bu formata dönüştürün
bu formata dönüştürün. Bu görüntüyü IFF formatında (formatlanmış bir diskte)
 istediğiniz adla kaydettikten sonra, örneğin “FIGURA” adını verdiğinizi varsayalım,
bunu RAW formatına, yani Copper tarafından okunabilen bitplane'lerin GERÇEK formatına
dönüştürmeniz gerekir. Bunu, birçok işlevi olan ancak daha sonra bahsedeceğimiz iffconverter ile bu diske,
“KEFCON”a yükleyin.
Yüklemeden önce şu talimatları okuyun:
Dönüştürücü donanım assembler ile programlanmıştır, bu nedenle
çoklu görevleri desteklemez ve dersleri okumak için penceresini “taşıyamazsınız”,
çünkü penceresi sisteme ait değil, kendi copperlist'ine aittir, ancak
AGA ile uyumludur ve sorun yaratmaz (eski programcılar!).
Önce, biçimlendirilmiş bir diske resmi hazırlayın, ardından
KEFCON'u df0: (dahili disk sürücüsü) veya df1: (harici disk sürücüsü)
 varsa, yükledikten sonra ekleyin.
Yükledikten sonra, üstte bir komut paneli ve seçenekler görünecektir.
Bizi ilgilendirenler şunlardır: ( “DÜĞMELER” için bir şema hazırladım)

------          ----------
| SAVE |    | IFF ILBM |
------      ----------

------         ----------
| LOAD |    | READ DIR |
------      ----------

------
| QUIT |
------

------------------------------------
| BURADA KÜÇÜK BİR PENCERE VAR | -Dosya adını yazmanız gereken yer
------------------------------------

LOAD, SAVE ve QUIT doğal olarak YÜKLE, KAYDET ve PROGRAMDAN ÇIK anlamına gelir
READ DIR, sağdaki pencerede diskteki dosya listesini
yani dizini görüntülemek için kullanılır.
IFF ILBM, kaydedilebilecek veya yüklenebilecek dosya türünü gösteren bir düğmedir,
 bu durumda doğru olarak IFF ILBM'dir çünkü
bir iff resmi yüklememiz gerekiyor daha sonra RAW olarak kaydetmek için
bu düğmeye tıklamanız yeterlidir, düğme “RAW NORM” olarak değişecek ve resim
RAW olarak kaydedilecektir; olası formatlar arasında SPRITE ve RAW BLIT de vardır,
bunları daha sonra kullanacağız. Şu anda sadece “RAW NORM” ve “COPPER” ile ilgileniyoruz
COPPER ile renk PALETİ doğrudan DC.W ile bir metin dosyasına kaydedilir
ve copperlist'imize eklenir!
Dönüştürme yapmak için, sol altta “allocated GFX-buffer” yazan şerit pencereye tıklayın
ve “df0:” olarak değişecektir
yani dahili sürücüye dönüşecektir. Eğer iff resminin bulunduğu diski df0:
'ya taktıysanız, olduğu gibi bırakın veya diski taktığınız sürücünün adını belirtin (
örneğin df1: veya dh0: sabit disk için). Dosya listesini okumak için
READ DIR'e basın ve resminizin adının üzerine fare ile tıklayarak
“LOAD” düğmesine basarak seçin.
Bu noktada, resmi görebilirsiniz ve
tırnak tuşlarıyla yukarı ve aşağı kaydırarak tam olarak görüntüleyebilirsiniz.
Resim yüklendikten sonra, özellikleri
şerit pencerede görünür: "bitplane $2800, total $7800". Aslında her bir
bitplane 2800 $ uzunluğundadır (yani 10240 ondalık, 40*256) ve toplamda
RAW şekil 7800 $ uzunluğundadır, yani 30720 (40*256*3).
Yukarıda diğer özellikler de belirtilmiştir:

WIDTH: 320 (genişlik), HEIGHT 256 (UZUNLUK), DEPTH 3 (BITPLAN SAYISI)

Şimdi “IFF ILBM” düğmesine tıklayın ve “RAW NORM” olarak değiştirin;
resmi RAW olarak kaydetmek için şerit pencerede sol tuşa bir kez daha basın
ve adı belirleyin, örneğin “df0:FIGURA.RAW” ve
“SAVE” düğmesine basın. INCBIN ile dahil edilecek RAW kaydedildi!
Şimdi COPPERLIST için renk paleti kalmıştır;
palet kaydetme modunu seçmek için “RAW NORM” gadget'ına 5 kez tıklayın, yani
 “COPPER” olana kadar tıklayın. Kaydetmek için şerit pencereye
tıklayın, bir isim verin, örneğin: “df0:FIGURA.S”,
ve “SAVE” düğmesine basın. Bu noktada çıkabilirsiniz, çünkü
hem .RAW hem de paletin metnini dc.w dosyasına kaydettik ve
copperlist'imize ekleyebiliriz.

Şekli görüntülemek için “Lezione4b.s” örneğini yükleyin ve şu 2
değişikliği yapın: yüklenecek şeklin adını kendi adınızla değiştirin
ve şeklinizin paletini ekleyerek önceden var olanı silin:

PIC:
incbin    “amiga.320*256*3”

şunu şekilde değiştirebilirsiniz:

PIC:
incbin    “df0:figura.raw”

veya komut satırına “v df0:” yazarak şunu yapabilirsiniz:

PIC:
incbin    “figura.raw”

Palet için 2 yol izleyebilirsiniz: ya “FIGURA.S” dosyasını başka bir
biffer'e yükleyin ve Amiga+b+c+i ile kopyalayın, ya da Asmone “I” komutunu kullanın, yani INSERT, bu komut, ESC tuşuna basarak komut satırına geçmeden önce
imlecin bulunduğu yere bir metin ekler.
Nasıl yaparsanız yapın, eski paleti editörün CUT (KES) komutuyla kaldırın:
Amiga+b ile bloğu seçin, Amiga+x ile silin.

Çalıştı mı? Umarım çalışmıştır, aksi takdirde bir adımda hata yapmışsınız demektir
ve tüm işlemi tekrarlamanız gerekir.

Güzel bir şekilde devam etmek için şimdi 32 renkli bir şekil görüntülemeyi deneyelim:
320x256 boyutunda, bu sefer 32 renkli olan normal şekle sahip olmanız yeterlidir
renkli (eğer yoksa DeLuxe Paint'i yükleyin ve birkaç
müstehcen şey çizin). Önceki resimde yaptığınız gibi dönüştürün, bu
kez yükleme işleminden sonra özelliklerin tahminlerle aynı olduğunu göreceksiniz
: “bitplane $2800, total $c800”, çünkü her bitplane her zaman
2800 bayt, toplam ise 800 c, yani 51200 ($2800*5) olur, çünkü bu
32 renkli ve 5 bitplane'den oluşan bir figürdür. .RAW ve paleti kaydedin,
örneğin FIGURA32.RAW ve FIGURA32.s gibi isimlerle.

Görüntülemek için kaynakta önceki iki değişikliği yapmanız gerekir, yani
yeni şekli incbin'den yükleyin ve eski paleti
yenisiyle değiştirin (fark edeceğiniz gibi, 32 renk kaydının tümünü içeren daha uzundur).
 Ayrıca, işaretleme rutininde bitplane sayısını değiştirmeniz
ve eksik bitplaneleri copperlist'e eklemeniz gerekir:

MOVE.L	#PIC,d0        ; d0'a PIC adresini koyun,
LEA    BPLPOINTERS,A1    ; a1'e COP'daki işaretçileri
**->    MOVEQ    #4,D1        ; bit düzlem sayısı -1 (burada 5!!!!!)
; DBRA ile döngüyü çalıştırmak için
POINTBP:
....

1) MOVEQ #2,d1'i MOVEQ #4,d1 olarak değiştirin, yani daha önce 3
DBRA döngüsü 3 bitplane için (3-1=2) çalıştırırken, şimdi 5 döngü (5-1=4) 5
bitplane için çalıştırıyoruz. Ancak bu durumda eksik bitplane işaretçilerini
bakır listesine eklemek gerekir:

BPLPOINTERS:
dc.w $e0,$0000,$e2,$0000    ;birinci     bit düzlemi - BPL0PT
dc.w $e4,$0000,$e6,$0000    ;ikinci bit düzlemi - BPL1PT
dc.w $e8,$0000,$ea,$0000	;üçüncü bit düzlemi - BPL2PT
dc.w $ec,$0000,$ee,$0000    ;dördüncü bit düzlemi (ŞİMDİ EKLENDİ!)
dc.w $f0,$0000,$f2,$0000    ;beşinci bit düzlemi (ŞİMDİ EKLENDİ!)

Son ve en önemli değişiklik, 3 yerine 5 bitplane'i “açmak”tır.
Bu, copperlist'teki $dff100 (bplcon0) değiştirilerek yapılabilir:


; 5432109876543210
dc.w    $100,%0101001000000000    ; bitler 14,12 açık!! (5 = %101)

Her şeyi bir araya getirdiğinizde 32 renkli bir resim görünmelidir.

Bu iki örnekten, 2, 4 ve 16 renkli resimleri nasıl görüntüleyebileceğinizi kolayca anlayabilirsiniz
! 
bitplanes'i işaret eden rutindeki döngü sayısını değiştirip doğru bitleri $dff100 (BPLCON0) içine yerleştirmeniz yeterlidir.

Şimdi, iki özel grafik modunu etkinleştirerek 64 renkli EHB ve 4096 renkli HAM formatında bir resim görüntüleyelim.

HAM formatındaki resimden başlayalım: HAM'da 320x256 boyutunda bir resim yapın veya
dergi disklerinde veya
“SEXY” resim disklerinde sıklıkla bulunan ham resimlerden birini arayın. Bu resimler çoğunlukla HAM'da bulunur, çünkü çıplak bir kadının resminde gerçekçilik
çok önemlidir. Hatta çıplak bir kadını görmek, bir meyve sepetini görmekten daha
hoş olduğunu düşünüyorum.
Resmi HAM 320x256 formatında KEFCON ile yükleyin ve RAW
ve COPPERLIST dosyalarını kaydedin.
Ne yazık ki KEFCON'da bir programlama hatası var, bu nedenle
A4000'e 6 bitplanes resimler yüklendiğinde, HAM veya EHB olsun,
komut satırındaki siyah ve noktalama işaretleri (,.:) bir tür “parçalanma” meydana geliyor
(Amiga500/2000/600'de ise çalışıyor!), bu nedenle
sadece kelimeleri doğru görebilirsiniz, ancak bu bir sorun değildir, çünkü
çubuk pencereye tıklayıp, örneğin, görünen PIC adının sonuna bir .RAW eklemeniz
ve ardından copperlist'i kaydetmek için bir .s eklemeniz yeterlidir.
Yapılması gereken değişiklikler, son işaretçilerin bit düzlemine 6
, paletin değiştirilmesi ve işaretleme rutininin döngü sayısının
6 olarak ayarlanmasıdır:


BPLPOINTERS:
dc.w $e0,$0000,$e2,$0000    ;birinci     bit düzlemi - BPL0PT
dc.w $e4,$0000,$e6,$0000	;ikinci bit düzlemi - BPL1PT
dc.w $e8,$0000,$ea,$0000    ;üçüncü     bit düzlemi - BPL2PT
dc.w $ec,$0000,$ee,$0000    ;dördüncü     bit düzlemi - BPL3PT
dc.w $f0,$0000,$f2,$0000    ;beşinci     bit düzlemi - BPL4PT
dc.w $f4,$0000,$f6,$0000    ;altıncı     bit düzlemi (ŞİMDİ EKLENDİ!)


**->    MOVEQ    #5,D1        ; bit düzlem sayısı -1 (burada 6!!!!!)
; DBRA ile döngüyü gerçekleştirmek için
POINTBP:
...

BPLCON0:

; 5432109876543210
dc.w $100,%0110101000000000    ; ---> 6 düzlem HAM düşük çözünürlükte (4096 renk)
; BIT 11 ayarlı = HAM!

HAM'ın teorik çalışması daha sonra daha ayrıntılı olarak ele alınacaktır.

*

Bir görüntüyü Extra Half Bright olarak görüntülemek için, görüntüyü
KEFCON ile dönüştürün, incbin'den yükleyin, paleti değiştirin,
6 bitplanes'i rutine yönlendirin ve bplcon0'ın 11 bitini sıfırlayın:

; 5432109876543210
dc.w $100,%0110001000000000    ; ---> 6 düzlem EHB düşük çözünürlükte (64 renk)
; BIT 11 sıfırlandı = Ekstra Yarım Parlak

NOT: EHB modunda 64 renk vardır, ancak bunların hepsi serbestçe seçilemez
çünkü Amiga sadece 32 renk kaydı vardır; diğer 32
renk ilk 32 renk gibidir ancak daha koyu, “YARIM IŞIK” yani “HALF BRIGHT”tır.

Şimdi şekilleri görüntüleyebildiğimize göre, kaydırma kayıtlarıyla ne tür efektler yapabileceğimizi görelim.
“r” ile LEZIONE5.TXT dosyasını yükleyin.
